// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;
import 'package:objective_c/objective_c.dart' as objc;
import 'package:ffi/ffi.dart' as pkg_ffi;

/// Bindings for CoreImage.
class CoreImageBindings {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  CoreImageBindings(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  CoreImageBindings.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  late final ffi.Pointer<ffi.Pointer<objc.ObjCObject>>
      _kCIContextOutputColorSpace =
      _lookup<ffi.Pointer<objc.ObjCObject>>('kCIContextOutputColorSpace');

  objc.NSString get kCIContextOutputColorSpace =>
      objc.NSString.castFromPointer(_kCIContextOutputColorSpace.value,
          retain: true, release: true);

  set kCIContextOutputColorSpace(objc.NSString value) {
    objc.NSString.castFromPointer(_kCIContextOutputColorSpace.value,
            retain: false, release: true)
        .ref
        .release();
    _kCIContextOutputColorSpace.value = value.ref.retainAndReturnPointer();
  }

  late final ffi.Pointer<ffi.Pointer<objc.ObjCObject>>
      _kCIContextWorkingColorSpace =
      _lookup<ffi.Pointer<objc.ObjCObject>>('kCIContextWorkingColorSpace');

  objc.NSString get kCIContextWorkingColorSpace =>
      objc.NSString.castFromPointer(_kCIContextWorkingColorSpace.value,
          retain: true, release: true);

  set kCIContextWorkingColorSpace(objc.NSString value) {
    objc.NSString.castFromPointer(_kCIContextWorkingColorSpace.value,
            retain: false, release: true)
        .ref
        .release();
    _kCIContextWorkingColorSpace.value = value.ref.retainAndReturnPointer();
  }

  late final ffi.Pointer<ffi.Pointer<objc.ObjCObject>>
      _kCIContextWorkingFormat =
      _lookup<ffi.Pointer<objc.ObjCObject>>('kCIContextWorkingFormat');

  objc.NSString get kCIContextWorkingFormat =>
      objc.NSString.castFromPointer(_kCIContextWorkingFormat.value,
          retain: true, release: true);

  set kCIContextWorkingFormat(objc.NSString value) {
    objc.NSString.castFromPointer(_kCIContextWorkingFormat.value,
            retain: false, release: true)
        .ref
        .release();
    _kCIContextWorkingFormat.value = value.ref.retainAndReturnPointer();
  }

  late final ffi.Pointer<ffi.Pointer<objc.ObjCObject>>
      _kCIContextHighQualityDownsample =
      _lookup<ffi.Pointer<objc.ObjCObject>>('kCIContextHighQualityDownsample');

  objc.NSString get kCIContextHighQualityDownsample =>
      objc.NSString.castFromPointer(_kCIContextHighQualityDownsample.value,
          retain: true, release: true);

  set kCIContextHighQualityDownsample(objc.NSString value) {
    objc.NSString.castFromPointer(_kCIContextHighQualityDownsample.value,
            retain: false, release: true)
        .ref
        .release();
    _kCIContextHighQualityDownsample.value = value.ref.retainAndReturnPointer();
  }

  late final ffi.Pointer<ffi.Pointer<objc.ObjCObject>>
      _kCIContextOutputPremultiplied =
      _lookup<ffi.Pointer<objc.ObjCObject>>('kCIContextOutputPremultiplied');

  objc.NSString get kCIContextOutputPremultiplied =>
      objc.NSString.castFromPointer(_kCIContextOutputPremultiplied.value,
          retain: true, release: true);

  set kCIContextOutputPremultiplied(objc.NSString value) {
    objc.NSString.castFromPointer(_kCIContextOutputPremultiplied.value,
            retain: false, release: true)
        .ref
        .release();
    _kCIContextOutputPremultiplied.value = value.ref.retainAndReturnPointer();
  }

  late final ffi.Pointer<ffi.Pointer<objc.ObjCObject>>
      _kCIContextCacheIntermediates =
      _lookup<ffi.Pointer<objc.ObjCObject>>('kCIContextCacheIntermediates');

  objc.NSString get kCIContextCacheIntermediates =>
      objc.NSString.castFromPointer(_kCIContextCacheIntermediates.value,
          retain: true, release: true);

  set kCIContextCacheIntermediates(objc.NSString value) {
    objc.NSString.castFromPointer(_kCIContextCacheIntermediates.value,
            retain: false, release: true)
        .ref
        .release();
    _kCIContextCacheIntermediates.value = value.ref.retainAndReturnPointer();
  }

  late final ffi.Pointer<ffi.Pointer<objc.ObjCObject>>
      _kCIContextUseSoftwareRenderer =
      _lookup<ffi.Pointer<objc.ObjCObject>>('kCIContextUseSoftwareRenderer');

  objc.NSString get kCIContextUseSoftwareRenderer =>
      objc.NSString.castFromPointer(_kCIContextUseSoftwareRenderer.value,
          retain: true, release: true);

  set kCIContextUseSoftwareRenderer(objc.NSString value) {
    objc.NSString.castFromPointer(_kCIContextUseSoftwareRenderer.value,
            retain: false, release: true)
        .ref
        .release();
    _kCIContextUseSoftwareRenderer.value = value.ref.retainAndReturnPointer();
  }

  late final ffi.Pointer<ffi.Pointer<objc.ObjCObject>>
      _kCIContextPriorityRequestLow =
      _lookup<ffi.Pointer<objc.ObjCObject>>('kCIContextPriorityRequestLow');

  objc.NSString get kCIContextPriorityRequestLow =>
      objc.NSString.castFromPointer(_kCIContextPriorityRequestLow.value,
          retain: true, release: true);

  set kCIContextPriorityRequestLow(objc.NSString value) {
    objc.NSString.castFromPointer(_kCIContextPriorityRequestLow.value,
            retain: false, release: true)
        .ref
        .release();
    _kCIContextPriorityRequestLow.value = value.ref.retainAndReturnPointer();
  }

  late final ffi.Pointer<ffi.Pointer<objc.ObjCObject>>
      _kCIContextAllowLowPower =
      _lookup<ffi.Pointer<objc.ObjCObject>>('kCIContextAllowLowPower');

  objc.NSString get kCIContextAllowLowPower =>
      objc.NSString.castFromPointer(_kCIContextAllowLowPower.value,
          retain: true, release: true);

  set kCIContextAllowLowPower(objc.NSString value) {
    objc.NSString.castFromPointer(_kCIContextAllowLowPower.value,
            retain: false, release: true)
        .ref
        .release();
    _kCIContextAllowLowPower.value = value.ref.retainAndReturnPointer();
  }

  late final ffi.Pointer<ffi.Pointer<objc.ObjCObject>> _kCIContextName =
      _lookup<ffi.Pointer<objc.ObjCObject>>('kCIContextName');

  objc.NSString get kCIContextName =>
      objc.NSString.castFromPointer(_kCIContextName.value,
          retain: true, release: true);

  set kCIContextName(objc.NSString value) {
    objc.NSString.castFromPointer(_kCIContextName.value,
            retain: false, release: true)
        .ref
        .release();
    _kCIContextName.value = value.ref.retainAndReturnPointer();
  }

  late final ffi.Pointer<ffi.Pointer<objc.ObjCObject>> _kCIContextMemoryLimit =
      _lookup<ffi.Pointer<objc.ObjCObject>>('kCIContextMemoryLimit');

  objc.NSString get kCIContextMemoryLimit =>
      objc.NSString.castFromPointer(_kCIContextMemoryLimit.value,
          retain: true, release: true);

  set kCIContextMemoryLimit(objc.NSString value) {
    objc.NSString.castFromPointer(_kCIContextMemoryLimit.value,
            retain: false, release: true)
        .ref
        .release();
    _kCIContextMemoryLimit.value = value.ref.retainAndReturnPointer();
  }
}

@ffi.Native<
    ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>()
external ffi.Pointer<objc.ObjCObject>
    _CoreImageBindings_protocolTrampoline_1mbt9g9(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<
    ffi.Bool Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>()
external bool _CoreImageBindings_protocolTrampoline_e3qsqz(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _CoreImageBindings_wrapListenerBlock_18v1jvf(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
    ffi.Pointer<objc.ObjCBlockImpl> Function(
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
        ffi.Pointer<objc.DOBJC_Context>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl>
    _CoreImageBindings_wrapBlockingBlock_18v1jvf(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>)>()
external void _CoreImageBindings_protocolTrampoline_18v1jvf(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
);

@ffi.Native<
    instancetype Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>,
        ffi.Pointer<objc.ObjCObject>)>()
external instancetype _CoreImageBindings_protocolTrampoline_xr62hr(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObject> arg1,
);

@ffi.Native<
    CGRect Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>()
external CGRect _CoreImageBindings_protocolTrampoline_1c3uc0w(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<
    ffi.Size Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>()
external int _CoreImageBindings_protocolTrampoline_150qdkd(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<
    ffi.Int Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>()
external int _CoreImageBindings_protocolTrampoline_1l0nlq(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<
    ffi.Pointer<ffi.Void> Function(
        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>()
external ffi.Pointer<ffi.Void> _CoreImageBindings_protocolTrampoline_3fl8pv(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<
    ffi.Pointer<__IOSurface> Function(
        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>()
external ffi.Pointer<__IOSurface> _CoreImageBindings_protocolTrampoline_tg5r79(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<
    ffi.Pointer<__CVBuffer> Function(
        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>()
external ffi.Pointer<__CVBuffer> _CoreImageBindings_protocolTrampoline_vfhx8p(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<
    ffi.Uint64 Function(ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>()
external int _CoreImageBindings_protocolTrampoline_k3xjiw(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<
    ffi.UnsignedLong Function(
        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>()
external int _CoreImageBindings_protocolTrampoline_1ckyi24(
  ffi.Pointer<objc.ObjCObject> target,
  ffi.Pointer<ffi.Void> arg0,
);

final class CGPoint extends ffi.Struct {
  @ffi.Double()
  external double x;

  @ffi.Double()
  external double y;
}

final class CGSize extends ffi.Struct {
  @ffi.Double()
  external double width;

  @ffi.Double()
  external double height;
}

final class CGRect extends ffi.Struct {
  external CGPoint origin;

  external CGSize size;
}

final class CGAffineTransform extends ffi.Struct {
  @ffi.Double()
  external double a;

  @ffi.Double()
  external double b;

  @ffi.Double()
  external double c;

  @ffi.Double()
  external double d;

  @ffi.Double()
  external double tx;

  @ffi.Double()
  external double ty;
}

final class __IOSurface extends ffi.Opaque {}

final class __CFDictionary extends ffi.Opaque {}

final class CGContext extends ffi.Opaque {}

final class CGColor extends ffi.Opaque {}

final class CGColorSpace extends ffi.Opaque {}

final class CGImage extends ffi.Opaque {}

final class CGLayer extends ffi.Opaque {}

late final _class_CIColor = objc.getClass("CIColor");
late final _sel_isKindOfClass_ = objc.registerName("isKindOfClass:");
final _objc_msgSend_19nvye5 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        bool Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
typedef instancetype = ffi.Pointer<objc.ObjCObject>;
typedef Dartinstancetype = objc.ObjCObjectBase;
late final _sel_colorWithCGColor_ = objc.registerName("colorWithCGColor:");
final _objc_msgSend_1rsocyz = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<CGColor>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<CGColor>)>();
late final _sel_colorWithRed_green_blue_alpha_ =
    objc.registerName("colorWithRed:green:blue:alpha:");
final _objc_msgSend_q2wq4h = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Double,
                ffi.Double,
                ffi.Double,
                ffi.Double)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, double, double, double, double)>();
late final _sel_colorWithRed_green_blue_ =
    objc.registerName("colorWithRed:green:blue:");
final _objc_msgSend_woct4u = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Double,
                ffi.Double,
                ffi.Double)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, double, double, double)>();
late final _sel_colorWithRed_green_blue_alpha_colorSpace_ =
    objc.registerName("colorWithRed:green:blue:alpha:colorSpace:");
final _objc_msgSend_1siluy7 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Double,
                ffi.Double,
                ffi.Double,
                ffi.Double,
                ffi.Pointer<CGColorSpace>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            double,
            double,
            double,
            double,
            ffi.Pointer<CGColorSpace>)>();
late final _sel_colorWithRed_green_blue_colorSpace_ =
    objc.registerName("colorWithRed:green:blue:colorSpace:");
final _objc_msgSend_pn5m2e = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Double,
                ffi.Double,
                ffi.Double,
                ffi.Pointer<CGColorSpace>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            double,
            double,
            double,
            ffi.Pointer<CGColorSpace>)>();
late final _sel_colorWithString_ = objc.registerName("colorWithString:");
final _objc_msgSend_1sotr3r = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
late final _sel_initWithCGColor_ = objc.registerName("initWithCGColor:");
late final _sel_initWithRed_green_blue_alpha_ =
    objc.registerName("initWithRed:green:blue:alpha:");
late final _sel_initWithRed_green_blue_ =
    objc.registerName("initWithRed:green:blue:");
late final _sel_initWithRed_green_blue_alpha_colorSpace_ =
    objc.registerName("initWithRed:green:blue:alpha:colorSpace:");
late final _sel_initWithRed_green_blue_colorSpace_ =
    objc.registerName("initWithRed:green:blue:colorSpace:");
late final _sel_numberOfComponents = objc.registerName("numberOfComponents");
final _objc_msgSend_h0gkbf = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Size Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_components = objc.registerName("components");
final _objc_msgSend_fw5q0a = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<ffi.Double> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<ffi.Double> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_alpha = objc.registerName("alpha");
final _objc_msgSend_1ukqyt8 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Double Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        double Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
final _objc_msgSend_1ukqyt8Fpret = objc.msgSendFpretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Double Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        double Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_colorSpace = objc.registerName("colorSpace");
final _objc_msgSend_19mkw1n = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<CGColorSpace> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<CGColorSpace> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_red = objc.registerName("red");
late final _sel_green = objc.registerName("green");
late final _sel_blue = objc.registerName("blue");
late final _sel_stringRepresentation =
    objc.registerName("stringRepresentation");
final _objc_msgSend_151sglz = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_blackColor = objc.registerName("blackColor");
late final _sel_whiteColor = objc.registerName("whiteColor");
late final _sel_grayColor = objc.registerName("grayColor");
late final _sel_redColor = objc.registerName("redColor");
late final _sel_greenColor = objc.registerName("greenColor");
late final _sel_blueColor = objc.registerName("blueColor");
late final _sel_cyanColor = objc.registerName("cyanColor");
late final _sel_magentaColor = objc.registerName("magentaColor");
late final _sel_yellowColor = objc.registerName("yellowColor");
late final _sel_clearColor = objc.registerName("clearColor");
late final _sel_init = objc.registerName("init");
late final _sel_new = objc.registerName("new");
late final _sel_allocWithZone_ = objc.registerName("allocWithZone:");
final _objc_msgSend_1cwp428 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.NSZone>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.NSZone>)>();
late final _sel_alloc = objc.registerName("alloc");
late final _sel_self = objc.registerName("self");
ffi.Pointer<objc.ObjCObject> _ObjCBlock_objcObjCObject_ffiVoid_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<ffi.Void> arg0)>>()
        .asFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_objcObjCObject_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_objcObjCObject_ffiVoid_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_objcObjCObject_ffiVoid_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0) =>
        (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_objcObjCObject_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_objcObjCObject_ffiVoid_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_objcObjCObject_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc
      .ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>(
              pointer,
              retain: retain,
              release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>
      fromFunctionPointer(
              ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.Pointer<objc.ObjCObject> Function(
                              ffi.Pointer<ffi.Void> arg0)>>
                  ptr) =>
          objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>(
              objc.newPointerBlock(_ObjCBlock_objcObjCObject_ffiVoid_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc
      .ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>
      fromFunction(objc.ObjCObjectBase Function(ffi.Pointer<ffi.Void>) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<
                  ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>(
              objc.newClosureBlock(
                  _ObjCBlock_objcObjCObject_ffiVoid_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0) =>
                      fn(arg0).ref.retainAndAutorelease(),
                  keepIsolateAlive),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_objcObjCObject_ffiVoid_CallExtension on objc
    .ObjCBlock<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>)> {
  objc.ObjCObjectBase call(ffi.Pointer<ffi.Void> arg0) => objc.ObjCObjectBase(
      ref.pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                      ffi.Pointer<objc.ObjCBlockImpl> block,
                      ffi.Pointer<ffi.Void> arg0)>>()
          .asFunction<
              ffi.Pointer<objc.ObjCObject> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0),
      retain: true,
      release: true);
}

late final _sel_retain = objc.registerName("retain");
late final _sel_autorelease = objc.registerName("autorelease");
late final _sel_supportsSecureCoding =
    objc.registerName("supportsSecureCoding");
final _objc_msgSend_91o635 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        bool Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
bool _ObjCBlock_bool_ffiVoid_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<ffi.Void> arg0)>>()
        .asFunction<bool Function(ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_bool_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Bool Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_bool_ffiVoid_fnPtrTrampoline, false)
        .cast();
bool _ObjCBlock_bool_ffiVoid_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    (objc.getBlockClosure(block) as bool Function(ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_bool_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Bool Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_bool_ffiVoid_closureTrampoline, false)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_bool_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>
      fromFunctionPointer(
              ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.Bool Function(ffi.Pointer<ffi.Void> arg0)>>
                  ptr) =>
          objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>(
              objc.newPointerBlock(_ObjCBlock_bool_ffiVoid_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)> fromFunction(
          bool Function(ffi.Pointer<ffi.Void>) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>(
          objc.newClosureBlock(_ObjCBlock_bool_ffiVoid_closureCallable,
              (ffi.Pointer<ffi.Void> arg0) => fn(arg0), keepIsolateAlive),
          retain: false,
          release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_bool_ffiVoid_CallExtension
    on objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)> {
  bool call(ffi.Pointer<ffi.Void> arg0) => ref.pointer.ref.invoke
      .cast<
          ffi.NativeFunction<
              ffi.Bool Function(ffi.Pointer<objc.ObjCBlockImpl> block,
                  ffi.Pointer<ffi.Void> arg0)>>()
      .asFunction<
          bool Function(ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0);
}

late final _sel_encodeWithCoder_ = objc.registerName("encodeWithCoder:");
final _objc_msgSend_xtuoz7 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObject>)>();
void _ObjCBlock_ffiVoid_ffiVoid_NSCoder_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1)>>()
        .asFunction<
            void Function(ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_ffiVoid_NSCoder_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_NSCoder_fnPtrTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_NSCoder_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiVoid_ffiVoid_NSCoder_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_ffiVoid_ffiVoid_NSCoder_closureTrampoline)
        .cast();
void _ObjCBlock_ffiVoid_ffiVoid_NSCoder_listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1) {
  (objc.getBlockClosure(block) as void Function(
      ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  objc.objectRelease(block.cast());
}

ffi.NativeCallable<
        ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSCoder_listenerCallable = ffi.NativeCallable<
            ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_NSCoder_listenerTrampoline)
      ..keepIsolateAlive = false;
void _ObjCBlock_ffiVoid_ffiVoid_NSCoder_blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObject> arg1) {
  try {
    (objc.getBlockClosure(block) as void Function(
        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
  } catch (e) {
  } finally {
    objc.signalWaiter(waiter);
    objc.objectRelease(block.cast());
  }
}

ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSCoder_blockingCallable = ffi.NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>.isolateLocal(
        _ObjCBlock_ffiVoid_ffiVoid_NSCoder_blockingTrampoline)
      ..keepIsolateAlive = false;
ffi.NativeCallable<
        ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObject>)>
    _ObjCBlock_ffiVoid_ffiVoid_NSCoder_blockingListenerCallable = ffi
        .NativeCallable<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>.listener(
        _ObjCBlock_ffiVoid_ffiVoid_NSCoder_blockingTrampoline)
      ..keepIsolateAlive = false;

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid_NSCoder {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              ffi.Void Function(ffi.Pointer<ffi.Void>,
                  objc.NSCoder)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1)>>
              ptr) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>(
          objc.newPointerBlock(_ObjCBlock_ffiVoid_ffiVoid_NSCoder_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
      ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)> fromFunction(
          void Function(ffi.Pointer<ffi.Void>, objc.NSCoder) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>(
          objc.newClosureBlock(
              _ObjCBlock_ffiVoid_ffiVoid_NSCoder_closureCallable,
              (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
                  fn(arg0, objc.NSCoder.castFromPointer(arg1, retain: true, release: true)),
              keepIsolateAlive),
          retain: false,
          release: true);

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>
      listener(void Function(ffi.Pointer<ffi.Void>, objc.NSCoder) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSCoder_listenerCallable.nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
            arg0,
            objc.NSCoder.castFromPointer(arg1, retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _CoreImageBindings_wrapListenerBlock_18v1jvf(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
            ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>(wrapper,
        retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>
      blocking(void Function(ffi.Pointer<ffi.Void>, objc.NSCoder) fn,
          {bool keepIsolateAlive = true}) {
    final raw = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSCoder_blockingCallable.nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
            arg0,
            objc.NSCoder.castFromPointer(arg1, retain: false, release: true)),
        keepIsolateAlive);
    final rawListener = objc.newClosureBlock(
        _ObjCBlock_ffiVoid_ffiVoid_NSCoder_blockingListenerCallable
            .nativeFunction
            .cast(),
        (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) => fn(
            arg0,
            objc.NSCoder.castFromPointer(arg1, retain: false, release: true)),
        keepIsolateAlive);
    final wrapper = _CoreImageBindings_wrapBlockingBlock_18v1jvf(
        raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
            ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>(wrapper,
        retain: false, release: true);
  }
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>`.
extension ObjCBlock_ffiVoid_ffiVoid_NSCoder_CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>, objc.NSCoder)> {
  void call(ffi.Pointer<ffi.Void> arg0, objc.NSCoder arg1) => ref
          .pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Void Function(
                      ffi.Pointer<objc.ObjCBlockImpl> block,
                      ffi.Pointer<ffi.Void> arg0,
                      ffi.Pointer<objc.ObjCObject> arg1)>>()
          .asFunction<
              void Function(ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()(
      ref.pointer, arg0, arg1.ref.pointer);
}

late final _sel_initWithCoder_ = objc.registerName("initWithCoder:");
instancetype _ObjCBlock_instancetype_ffiVoid_NSCoder_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                instancetype Function(ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObject> arg1)>>()
        .asFunction<
            instancetype Function(ffi.Pointer<ffi.Void>,
                ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_instancetype_ffiVoid_NSCoder_fnPtrCallable =
    ffi.Pointer.fromFunction<
                instancetype Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_instancetype_ffiVoid_NSCoder_fnPtrTrampoline)
        .cast();
instancetype _ObjCBlock_instancetype_ffiVoid_NSCoder_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block,
        ffi.Pointer<ffi.Void> arg0,
        ffi.Pointer<objc.ObjCObject> arg1) =>
    (objc.getBlockClosure(block) as instancetype Function(
        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_instancetype_ffiVoid_NSCoder_closureCallable =
    ffi.Pointer.fromFunction<
                instancetype Function(ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_instancetype_ffiVoid_NSCoder_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObject>?> Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>`.
abstract final class ObjCBlock_instancetype_ffiVoid_NSCoder {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
          objc.Retained<ffi.Pointer<objc.ObjCObject>?> Function(
              ffi.Pointer<ffi.Void>, objc.NSCoder)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
              objc.Retained<ffi.Pointer<objc.ObjCObject>?> Function(
                  ffi.Pointer<ffi.Void>,
                  objc.NSCoder)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
          objc.Retained<ffi.Pointer<objc.ObjCObject>?> Function(
              ffi.Pointer<ffi.Void>, objc.NSCoder)>
      fromFunctionPointer(ffi.Pointer<ffi.NativeFunction<instancetype Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>> ptr) =>
          objc.ObjCBlock<
                  objc.Retained<ffi.Pointer<objc.ObjCObject>?> Function(
                      ffi.Pointer<ffi.Void>, objc.NSCoder)>(
              objc.newPointerBlock(
                  _ObjCBlock_instancetype_ffiVoid_NSCoder_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObject>?> Function(ffi.Pointer<ffi.Void>, objc.NSCoder)> fromFunction(
          Dartinstancetype? Function(ffi.Pointer<ffi.Void>, objc.NSCoder) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObject>?> Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>(
          objc.newClosureBlock(
              _ObjCBlock_instancetype_ffiVoid_NSCoder_closureCallable,
              (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1) =>
                  fn(arg0, objc.NSCoder.castFromPointer(arg1, retain: true, release: true))
                      ?.ref
                      .retainAndReturnPointer() ??
                  ffi.nullptr,
              keepIsolateAlive),
          retain: false,
          release: true);
}

/// Call operator for `objc.ObjCBlock<objc.Retained<ffi.Pointer<objc.ObjCObject>?> Function(ffi.Pointer<ffi.Void>, objc.NSCoder)>`.
extension ObjCBlock_instancetype_ffiVoid_NSCoder_CallExtension
    on objc.ObjCBlock<
        objc.Retained<ffi.Pointer<objc.ObjCObject>?> Function(
            ffi.Pointer<ffi.Void>, objc.NSCoder)> {
  Dartinstancetype? call(ffi.Pointer<ffi.Void> arg0, objc.NSCoder arg1) => ref
              .pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      instancetype Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1)>>()
              .asFunction<instancetype Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()
              (ref.pointer, arg0, arg1.ref.pointer)
              .address ==
          0
      ? null
      : objc.ObjCObjectBase(
          ref.pointer.ref.invoke
              .cast<ffi.NativeFunction<instancetype Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>>()
              .asFunction<instancetype Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()(ref.pointer, arg0, arg1.ref.pointer),
          retain: false,
          release: true);
}

/// CIColor
class CIColor extends objc.NSObject
    implements objc.NSSecureCoding, objc.NSCopying {
  CIColor._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('CIColor', macOS: (false, (10, 4, 0)));
  }

  /// Constructs a [CIColor] that points to the same underlying object as [other].
  CIColor.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [CIColor] that wraps the given raw object pointer.
  CIColor.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [CIColor].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_CIColor);
  }

  /// colorWithCGColor:
  static CIColor colorWithCGColor_(ffi.Pointer<CGColor> c) {
    objc.checkOsVersionInternal('CIColor.colorWithCGColor:',
        macOS: (false, (10, 4, 0)));
    final _ret =
        _objc_msgSend_1rsocyz(_class_CIColor, _sel_colorWithCGColor_, c);
    return CIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// colorWithRed:green:blue:alpha:
  static CIColor colorWithRed_green_blue_alpha_(
      double r, double g, double b, double a) {
    objc.checkOsVersionInternal('CIColor.colorWithRed:green:blue:alpha:',
        macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_q2wq4h(
        _class_CIColor, _sel_colorWithRed_green_blue_alpha_, r, g, b, a);
    return CIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// colorWithRed:green:blue:
  static CIColor colorWithRed_green_blue_(double r, double g, double b) {
    objc.checkOsVersionInternal('CIColor.colorWithRed:green:blue:',
        macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_woct4u(
        _class_CIColor, _sel_colorWithRed_green_blue_, r, g, b);
    return CIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// colorWithRed:green:blue:alpha:colorSpace:
  static CIColor? colorWithRed_green_blue_alpha_colorSpace_(double r, double g,
      double b, double a, ffi.Pointer<CGColorSpace> colorSpace) {
    objc.checkOsVersionInternal(
        'CIColor.colorWithRed:green:blue:alpha:colorSpace:',
        macOS: (false, (10, 12, 0)));
    final _ret = _objc_msgSend_1siluy7(_class_CIColor,
        _sel_colorWithRed_green_blue_alpha_colorSpace_, r, g, b, a, colorSpace);
    return _ret.address == 0
        ? null
        : CIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// colorWithRed:green:blue:colorSpace:
  static CIColor? colorWithRed_green_blue_colorSpace_(
      double r, double g, double b, ffi.Pointer<CGColorSpace> colorSpace) {
    objc.checkOsVersionInternal('CIColor.colorWithRed:green:blue:colorSpace:',
        macOS: (false, (10, 12, 0)));
    final _ret = _objc_msgSend_pn5m2e(_class_CIColor,
        _sel_colorWithRed_green_blue_colorSpace_, r, g, b, colorSpace);
    return _ret.address == 0
        ? null
        : CIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// colorWithString:
  static CIColor colorWithString_(objc.NSString representation) {
    objc.checkOsVersionInternal('CIColor.colorWithString:',
        macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_1sotr3r(
        _class_CIColor, _sel_colorWithString_, representation.ref.pointer);
    return CIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// initWithCGColor:
  CIColor initWithCGColor_(ffi.Pointer<CGColor> c) {
    objc.checkOsVersionInternal('CIColor.initWithCGColor:',
        macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_1rsocyz(
        this.ref.retainAndReturnPointer(), _sel_initWithCGColor_, c);
    return CIColor.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithRed:green:blue:alpha:
  CIColor initWithRed_green_blue_alpha_(
      double r, double g, double b, double a) {
    objc.checkOsVersionInternal('CIColor.initWithRed:green:blue:alpha:',
        macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_q2wq4h(this.ref.retainAndReturnPointer(),
        _sel_initWithRed_green_blue_alpha_, r, g, b, a);
    return CIColor.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithRed:green:blue:
  CIColor initWithRed_green_blue_(double r, double g, double b) {
    objc.checkOsVersionInternal('CIColor.initWithRed:green:blue:',
        macOS: (false, (10, 11, 0)));
    final _ret = _objc_msgSend_woct4u(this.ref.retainAndReturnPointer(),
        _sel_initWithRed_green_blue_, r, g, b);
    return CIColor.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithRed:green:blue:alpha:colorSpace:
  CIColor? initWithRed_green_blue_alpha_colorSpace_(double r, double g,
      double b, double a, ffi.Pointer<CGColorSpace> colorSpace) {
    objc.checkOsVersionInternal(
        'CIColor.initWithRed:green:blue:alpha:colorSpace:',
        macOS: (false, (10, 12, 0)));
    final _ret = _objc_msgSend_1siluy7(this.ref.retainAndReturnPointer(),
        _sel_initWithRed_green_blue_alpha_colorSpace_, r, g, b, a, colorSpace);
    return _ret.address == 0
        ? null
        : CIColor.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithRed:green:blue:colorSpace:
  CIColor? initWithRed_green_blue_colorSpace_(
      double r, double g, double b, ffi.Pointer<CGColorSpace> colorSpace) {
    objc.checkOsVersionInternal('CIColor.initWithRed:green:blue:colorSpace:',
        macOS: (false, (10, 12, 0)));
    final _ret = _objc_msgSend_pn5m2e(this.ref.retainAndReturnPointer(),
        _sel_initWithRed_green_blue_colorSpace_, r, g, b, colorSpace);
    return _ret.address == 0
        ? null
        : CIColor.castFromPointer(_ret, retain: false, release: true);
  }

  /// numberOfComponents
  int get numberOfComponents {
    objc.checkOsVersionInternal('CIColor.numberOfComponents',
        macOS: (false, (10, 4, 0)));
    return _objc_msgSend_h0gkbf(this.ref.pointer, _sel_numberOfComponents);
  }

  /// components
  ffi.Pointer<ffi.Double> get components {
    objc.checkOsVersionInternal('CIColor.components',
        macOS: (false, (10, 4, 0)));
    return _objc_msgSend_fw5q0a(this.ref.pointer, _sel_components);
  }

  /// alpha
  double get alpha {
    objc.checkOsVersionInternal('CIColor.alpha', macOS: (false, (10, 4, 0)));
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_alpha)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_alpha);
  }

  /// colorSpace
  ffi.Pointer<CGColorSpace> get colorSpace {
    objc.checkOsVersionInternal('CIColor.colorSpace',
        macOS: (false, (10, 4, 0)));
    return _objc_msgSend_19mkw1n(this.ref.pointer, _sel_colorSpace);
  }

  /// red
  double get red {
    objc.checkOsVersionInternal('CIColor.red', macOS: (false, (10, 4, 0)));
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_red)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_red);
  }

  /// green
  double get green {
    objc.checkOsVersionInternal('CIColor.green', macOS: (false, (10, 4, 0)));
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_green)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_green);
  }

  /// blue
  double get blue {
    objc.checkOsVersionInternal('CIColor.blue', macOS: (false, (10, 4, 0)));
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_blue)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_blue);
  }

  /// stringRepresentation
  objc.NSString get stringRepresentation {
    objc.checkOsVersionInternal('CIColor.stringRepresentation',
        macOS: (false, (10, 4, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_stringRepresentation);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// blackColor
  static CIColor getBlackColor() {
    objc.checkOsVersionInternal('CIColor.blackColor',
        macOS: (false, (10, 12, 0)));
    final _ret = _objc_msgSend_151sglz(_class_CIColor, _sel_blackColor);
    return CIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// whiteColor
  static CIColor getWhiteColor() {
    objc.checkOsVersionInternal('CIColor.whiteColor',
        macOS: (false, (10, 12, 0)));
    final _ret = _objc_msgSend_151sglz(_class_CIColor, _sel_whiteColor);
    return CIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// grayColor
  static CIColor getGrayColor() {
    objc.checkOsVersionInternal('CIColor.grayColor',
        macOS: (false, (10, 12, 0)));
    final _ret = _objc_msgSend_151sglz(_class_CIColor, _sel_grayColor);
    return CIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// redColor
  static CIColor getRedColor() {
    objc.checkOsVersionInternal('CIColor.redColor',
        macOS: (false, (10, 12, 0)));
    final _ret = _objc_msgSend_151sglz(_class_CIColor, _sel_redColor);
    return CIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// greenColor
  static CIColor getGreenColor() {
    objc.checkOsVersionInternal('CIColor.greenColor',
        macOS: (false, (10, 12, 0)));
    final _ret = _objc_msgSend_151sglz(_class_CIColor, _sel_greenColor);
    return CIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// blueColor
  static CIColor getBlueColor() {
    objc.checkOsVersionInternal('CIColor.blueColor',
        macOS: (false, (10, 12, 0)));
    final _ret = _objc_msgSend_151sglz(_class_CIColor, _sel_blueColor);
    return CIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// cyanColor
  static CIColor getCyanColor() {
    objc.checkOsVersionInternal('CIColor.cyanColor',
        macOS: (false, (10, 12, 0)));
    final _ret = _objc_msgSend_151sglz(_class_CIColor, _sel_cyanColor);
    return CIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// magentaColor
  static CIColor getMagentaColor() {
    objc.checkOsVersionInternal('CIColor.magentaColor',
        macOS: (false, (10, 12, 0)));
    final _ret = _objc_msgSend_151sglz(_class_CIColor, _sel_magentaColor);
    return CIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// yellowColor
  static CIColor getYellowColor() {
    objc.checkOsVersionInternal('CIColor.yellowColor',
        macOS: (false, (10, 12, 0)));
    final _ret = _objc_msgSend_151sglz(_class_CIColor, _sel_yellowColor);
    return CIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// clearColor
  static CIColor getClearColor() {
    objc.checkOsVersionInternal('CIColor.clearColor',
        macOS: (false, (10, 12, 0)));
    final _ret = _objc_msgSend_151sglz(_class_CIColor, _sel_clearColor);
    return CIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// init
  CIColor init() {
    objc.checkOsVersionInternal('CIColor.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return CIColor.castFromPointer(_ret, retain: false, release: true);
  }

  /// new
  static CIColor new$() {
    final _ret = _objc_msgSend_151sglz(_class_CIColor, _sel_new);
    return CIColor.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static CIColor allocWithZone_(ffi.Pointer<objc.NSZone> zone) {
    final _ret =
        _objc_msgSend_1cwp428(_class_CIColor, _sel_allocWithZone_, zone);
    return CIColor.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static CIColor alloc() {
    final _ret = _objc_msgSend_151sglz(_class_CIColor, _sel_alloc);
    return CIColor.castFromPointer(_ret, retain: false, release: true);
  }

  /// self
  CIColor self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return CIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// retain
  CIColor retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return CIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// autorelease
  CIColor autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return CIColor.castFromPointer(_ret, retain: true, release: true);
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(_class_CIColor, _sel_supportsSecureCoding);
  }

  /// encodeWithCoder:
  void encodeWithCoder_(objc.NSCoder coder) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_encodeWithCoder_, coder.ref.pointer);
  }

  /// initWithCoder:
  CIColor? initWithCoder_(objc.NSCoder coder) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithCoder_, coder.ref.pointer);
    return _ret.address == 0
        ? null
        : CIColor.castFromPointer(_ret, retain: false, release: true);
  }

  /// Returns a new instance of CIColor constructed with the default `new` method.
  factory CIColor() => new$();
}

final class _CGLContextObject extends ffi.Opaque {}

final class _CGLPixelFormatObject extends ffi.Opaque {}

final class __CVBuffer extends ffi.Opaque {}

final class CGImageSource extends ffi.Opaque {}

enum CGImagePropertyOrientation {
  kCGImagePropertyOrientationUp(1),
  kCGImagePropertyOrientationUpMirrored(2),
  kCGImagePropertyOrientationDown(3),
  kCGImagePropertyOrientationDownMirrored(4),
  kCGImagePropertyOrientationLeftMirrored(5),
  kCGImagePropertyOrientationRight(6),
  kCGImagePropertyOrientationRightMirrored(7),
  kCGImagePropertyOrientationLeft(8);

  final int value;
  const CGImagePropertyOrientation(this.value);

  static CGImagePropertyOrientation fromValue(int value) => switch (value) {
        1 => kCGImagePropertyOrientationUp,
        2 => kCGImagePropertyOrientationUpMirrored,
        3 => kCGImagePropertyOrientationDown,
        4 => kCGImagePropertyOrientationDownMirrored,
        5 => kCGImagePropertyOrientationLeftMirrored,
        6 => kCGImagePropertyOrientationRight,
        7 => kCGImagePropertyOrientationRightMirrored,
        8 => kCGImagePropertyOrientationLeft,
        _ => throw ArgumentError(
            'Unknown value for CGImagePropertyOrientation: $value'),
      };
}

enum IOSurfaceLockOptions {
  kIOSurfaceLockReadOnly(1),
  kIOSurfaceLockAvoidSync(2);

  final int value;
  const IOSurfaceLockOptions(this.value);

  static IOSurfaceLockOptions fromValue(int value) => switch (value) {
        1 => kIOSurfaceLockReadOnly,
        2 => kIOSurfaceLockAvoidSync,
        _ =>
          throw ArgumentError('Unknown value for IOSurfaceLockOptions: $value'),
      };
}

enum IOSurfacePurgeabilityState {
  kIOSurfacePurgeableNonVolatile(0),
  kIOSurfacePurgeableVolatile(1),
  kIOSurfacePurgeableEmpty(2),
  kIOSurfacePurgeableKeepCurrent(3);

  final int value;
  const IOSurfacePurgeabilityState(this.value);

  static IOSurfacePurgeabilityState fromValue(int value) => switch (value) {
        0 => kIOSurfacePurgeableNonVolatile,
        1 => kIOSurfacePurgeableVolatile,
        2 => kIOSurfacePurgeableEmpty,
        3 => kIOSurfacePurgeableKeepCurrent,
        _ => throw ArgumentError(
            'Unknown value for IOSurfacePurgeabilityState: $value'),
      };
}

enum MTLPixelFormat {
  MTLPixelFormatInvalid(0),
  MTLPixelFormatA8Unorm(1),
  MTLPixelFormatR8Unorm(10),
  MTLPixelFormatR8Unorm_sRGB(11),
  MTLPixelFormatR8Snorm(12),
  MTLPixelFormatR8Uint(13),
  MTLPixelFormatR8Sint(14),
  MTLPixelFormatR16Unorm(20),
  MTLPixelFormatR16Snorm(22),
  MTLPixelFormatR16Uint(23),
  MTLPixelFormatR16Sint(24),
  MTLPixelFormatR16Float(25),
  MTLPixelFormatRG8Unorm(30),
  MTLPixelFormatRG8Unorm_sRGB(31),
  MTLPixelFormatRG8Snorm(32),
  MTLPixelFormatRG8Uint(33),
  MTLPixelFormatRG8Sint(34),
  MTLPixelFormatB5G6R5Unorm(40),
  MTLPixelFormatA1BGR5Unorm(41),
  MTLPixelFormatABGR4Unorm(42),
  MTLPixelFormatBGR5A1Unorm(43),
  MTLPixelFormatR32Uint(53),
  MTLPixelFormatR32Sint(54),
  MTLPixelFormatR32Float(55),
  MTLPixelFormatRG16Unorm(60),
  MTLPixelFormatRG16Snorm(62),
  MTLPixelFormatRG16Uint(63),
  MTLPixelFormatRG16Sint(64),
  MTLPixelFormatRG16Float(65),
  MTLPixelFormatRGBA8Unorm(70),
  MTLPixelFormatRGBA8Unorm_sRGB(71),
  MTLPixelFormatRGBA8Snorm(72),
  MTLPixelFormatRGBA8Uint(73),
  MTLPixelFormatRGBA8Sint(74),
  MTLPixelFormatBGRA8Unorm(80),
  MTLPixelFormatBGRA8Unorm_sRGB(81),
  MTLPixelFormatRGB10A2Unorm(90),
  MTLPixelFormatRGB10A2Uint(91),
  MTLPixelFormatRG11B10Float(92),
  MTLPixelFormatRGB9E5Float(93),
  MTLPixelFormatBGR10A2Unorm(94),
  MTLPixelFormatBGR10_XR(554),
  MTLPixelFormatBGR10_XR_sRGB(555),
  MTLPixelFormatRG32Uint(103),
  MTLPixelFormatRG32Sint(104),
  MTLPixelFormatRG32Float(105),
  MTLPixelFormatRGBA16Unorm(110),
  MTLPixelFormatRGBA16Snorm(112),
  MTLPixelFormatRGBA16Uint(113),
  MTLPixelFormatRGBA16Sint(114),
  MTLPixelFormatRGBA16Float(115),
  MTLPixelFormatBGRA10_XR(552),
  MTLPixelFormatBGRA10_XR_sRGB(553),
  MTLPixelFormatRGBA32Uint(123),
  MTLPixelFormatRGBA32Sint(124),
  MTLPixelFormatRGBA32Float(125),
  MTLPixelFormatBC1_RGBA(130),
  MTLPixelFormatBC1_RGBA_sRGB(131),
  MTLPixelFormatBC2_RGBA(132),
  MTLPixelFormatBC2_RGBA_sRGB(133),
  MTLPixelFormatBC3_RGBA(134),
  MTLPixelFormatBC3_RGBA_sRGB(135),
  MTLPixelFormatBC4_RUnorm(140),
  MTLPixelFormatBC4_RSnorm(141),
  MTLPixelFormatBC5_RGUnorm(142),
  MTLPixelFormatBC5_RGSnorm(143),
  MTLPixelFormatBC6H_RGBFloat(150),
  MTLPixelFormatBC6H_RGBUfloat(151),
  MTLPixelFormatBC7_RGBAUnorm(152),
  MTLPixelFormatBC7_RGBAUnorm_sRGB(153),
  MTLPixelFormatPVRTC_RGB_2BPP(160),
  MTLPixelFormatPVRTC_RGB_2BPP_sRGB(161),
  MTLPixelFormatPVRTC_RGB_4BPP(162),
  MTLPixelFormatPVRTC_RGB_4BPP_sRGB(163),
  MTLPixelFormatPVRTC_RGBA_2BPP(164),
  MTLPixelFormatPVRTC_RGBA_2BPP_sRGB(165),
  MTLPixelFormatPVRTC_RGBA_4BPP(166),
  MTLPixelFormatPVRTC_RGBA_4BPP_sRGB(167),
  MTLPixelFormatEAC_R11Unorm(170),
  MTLPixelFormatEAC_R11Snorm(172),
  MTLPixelFormatEAC_RG11Unorm(174),
  MTLPixelFormatEAC_RG11Snorm(176),
  MTLPixelFormatEAC_RGBA8(178),
  MTLPixelFormatEAC_RGBA8_sRGB(179),
  MTLPixelFormatETC2_RGB8(180),
  MTLPixelFormatETC2_RGB8_sRGB(181),
  MTLPixelFormatETC2_RGB8A1(182),
  MTLPixelFormatETC2_RGB8A1_sRGB(183),
  MTLPixelFormatASTC_4x4_sRGB(186),
  MTLPixelFormatASTC_5x4_sRGB(187),
  MTLPixelFormatASTC_5x5_sRGB(188),
  MTLPixelFormatASTC_6x5_sRGB(189),
  MTLPixelFormatASTC_6x6_sRGB(190),
  MTLPixelFormatASTC_8x5_sRGB(192),
  MTLPixelFormatASTC_8x6_sRGB(193),
  MTLPixelFormatASTC_8x8_sRGB(194),
  MTLPixelFormatASTC_10x5_sRGB(195),
  MTLPixelFormatASTC_10x6_sRGB(196),
  MTLPixelFormatASTC_10x8_sRGB(197),
  MTLPixelFormatASTC_10x10_sRGB(198),
  MTLPixelFormatASTC_12x10_sRGB(199),
  MTLPixelFormatASTC_12x12_sRGB(200),
  MTLPixelFormatASTC_4x4_LDR(204),
  MTLPixelFormatASTC_5x4_LDR(205),
  MTLPixelFormatASTC_5x5_LDR(206),
  MTLPixelFormatASTC_6x5_LDR(207),
  MTLPixelFormatASTC_6x6_LDR(208),
  MTLPixelFormatASTC_8x5_LDR(210),
  MTLPixelFormatASTC_8x6_LDR(211),
  MTLPixelFormatASTC_8x8_LDR(212),
  MTLPixelFormatASTC_10x5_LDR(213),
  MTLPixelFormatASTC_10x6_LDR(214),
  MTLPixelFormatASTC_10x8_LDR(215),
  MTLPixelFormatASTC_10x10_LDR(216),
  MTLPixelFormatASTC_12x10_LDR(217),
  MTLPixelFormatASTC_12x12_LDR(218),
  MTLPixelFormatASTC_4x4_HDR(222),
  MTLPixelFormatASTC_5x4_HDR(223),
  MTLPixelFormatASTC_5x5_HDR(224),
  MTLPixelFormatASTC_6x5_HDR(225),
  MTLPixelFormatASTC_6x6_HDR(226),
  MTLPixelFormatASTC_8x5_HDR(228),
  MTLPixelFormatASTC_8x6_HDR(229),
  MTLPixelFormatASTC_8x8_HDR(230),
  MTLPixelFormatASTC_10x5_HDR(231),
  MTLPixelFormatASTC_10x6_HDR(232),
  MTLPixelFormatASTC_10x8_HDR(233),
  MTLPixelFormatASTC_10x10_HDR(234),
  MTLPixelFormatASTC_12x10_HDR(235),
  MTLPixelFormatASTC_12x12_HDR(236),
  MTLPixelFormatGBGR422(240),
  MTLPixelFormatBGRG422(241),
  MTLPixelFormatDepth16Unorm(250),
  MTLPixelFormatDepth32Float(252),
  MTLPixelFormatStencil8(253),
  MTLPixelFormatDepth24Unorm_Stencil8(255),
  MTLPixelFormatDepth32Float_Stencil8(260),
  MTLPixelFormatX32_Stencil8(261),
  MTLPixelFormatX24_Stencil8(262);

  final int value;
  const MTLPixelFormat(this.value);

  static MTLPixelFormat fromValue(int value) => switch (value) {
        0 => MTLPixelFormatInvalid,
        1 => MTLPixelFormatA8Unorm,
        10 => MTLPixelFormatR8Unorm,
        11 => MTLPixelFormatR8Unorm_sRGB,
        12 => MTLPixelFormatR8Snorm,
        13 => MTLPixelFormatR8Uint,
        14 => MTLPixelFormatR8Sint,
        20 => MTLPixelFormatR16Unorm,
        22 => MTLPixelFormatR16Snorm,
        23 => MTLPixelFormatR16Uint,
        24 => MTLPixelFormatR16Sint,
        25 => MTLPixelFormatR16Float,
        30 => MTLPixelFormatRG8Unorm,
        31 => MTLPixelFormatRG8Unorm_sRGB,
        32 => MTLPixelFormatRG8Snorm,
        33 => MTLPixelFormatRG8Uint,
        34 => MTLPixelFormatRG8Sint,
        40 => MTLPixelFormatB5G6R5Unorm,
        41 => MTLPixelFormatA1BGR5Unorm,
        42 => MTLPixelFormatABGR4Unorm,
        43 => MTLPixelFormatBGR5A1Unorm,
        53 => MTLPixelFormatR32Uint,
        54 => MTLPixelFormatR32Sint,
        55 => MTLPixelFormatR32Float,
        60 => MTLPixelFormatRG16Unorm,
        62 => MTLPixelFormatRG16Snorm,
        63 => MTLPixelFormatRG16Uint,
        64 => MTLPixelFormatRG16Sint,
        65 => MTLPixelFormatRG16Float,
        70 => MTLPixelFormatRGBA8Unorm,
        71 => MTLPixelFormatRGBA8Unorm_sRGB,
        72 => MTLPixelFormatRGBA8Snorm,
        73 => MTLPixelFormatRGBA8Uint,
        74 => MTLPixelFormatRGBA8Sint,
        80 => MTLPixelFormatBGRA8Unorm,
        81 => MTLPixelFormatBGRA8Unorm_sRGB,
        90 => MTLPixelFormatRGB10A2Unorm,
        91 => MTLPixelFormatRGB10A2Uint,
        92 => MTLPixelFormatRG11B10Float,
        93 => MTLPixelFormatRGB9E5Float,
        94 => MTLPixelFormatBGR10A2Unorm,
        554 => MTLPixelFormatBGR10_XR,
        555 => MTLPixelFormatBGR10_XR_sRGB,
        103 => MTLPixelFormatRG32Uint,
        104 => MTLPixelFormatRG32Sint,
        105 => MTLPixelFormatRG32Float,
        110 => MTLPixelFormatRGBA16Unorm,
        112 => MTLPixelFormatRGBA16Snorm,
        113 => MTLPixelFormatRGBA16Uint,
        114 => MTLPixelFormatRGBA16Sint,
        115 => MTLPixelFormatRGBA16Float,
        552 => MTLPixelFormatBGRA10_XR,
        553 => MTLPixelFormatBGRA10_XR_sRGB,
        123 => MTLPixelFormatRGBA32Uint,
        124 => MTLPixelFormatRGBA32Sint,
        125 => MTLPixelFormatRGBA32Float,
        130 => MTLPixelFormatBC1_RGBA,
        131 => MTLPixelFormatBC1_RGBA_sRGB,
        132 => MTLPixelFormatBC2_RGBA,
        133 => MTLPixelFormatBC2_RGBA_sRGB,
        134 => MTLPixelFormatBC3_RGBA,
        135 => MTLPixelFormatBC3_RGBA_sRGB,
        140 => MTLPixelFormatBC4_RUnorm,
        141 => MTLPixelFormatBC4_RSnorm,
        142 => MTLPixelFormatBC5_RGUnorm,
        143 => MTLPixelFormatBC5_RGSnorm,
        150 => MTLPixelFormatBC6H_RGBFloat,
        151 => MTLPixelFormatBC6H_RGBUfloat,
        152 => MTLPixelFormatBC7_RGBAUnorm,
        153 => MTLPixelFormatBC7_RGBAUnorm_sRGB,
        160 => MTLPixelFormatPVRTC_RGB_2BPP,
        161 => MTLPixelFormatPVRTC_RGB_2BPP_sRGB,
        162 => MTLPixelFormatPVRTC_RGB_4BPP,
        163 => MTLPixelFormatPVRTC_RGB_4BPP_sRGB,
        164 => MTLPixelFormatPVRTC_RGBA_2BPP,
        165 => MTLPixelFormatPVRTC_RGBA_2BPP_sRGB,
        166 => MTLPixelFormatPVRTC_RGBA_4BPP,
        167 => MTLPixelFormatPVRTC_RGBA_4BPP_sRGB,
        170 => MTLPixelFormatEAC_R11Unorm,
        172 => MTLPixelFormatEAC_R11Snorm,
        174 => MTLPixelFormatEAC_RG11Unorm,
        176 => MTLPixelFormatEAC_RG11Snorm,
        178 => MTLPixelFormatEAC_RGBA8,
        179 => MTLPixelFormatEAC_RGBA8_sRGB,
        180 => MTLPixelFormatETC2_RGB8,
        181 => MTLPixelFormatETC2_RGB8_sRGB,
        182 => MTLPixelFormatETC2_RGB8A1,
        183 => MTLPixelFormatETC2_RGB8A1_sRGB,
        186 => MTLPixelFormatASTC_4x4_sRGB,
        187 => MTLPixelFormatASTC_5x4_sRGB,
        188 => MTLPixelFormatASTC_5x5_sRGB,
        189 => MTLPixelFormatASTC_6x5_sRGB,
        190 => MTLPixelFormatASTC_6x6_sRGB,
        192 => MTLPixelFormatASTC_8x5_sRGB,
        193 => MTLPixelFormatASTC_8x6_sRGB,
        194 => MTLPixelFormatASTC_8x8_sRGB,
        195 => MTLPixelFormatASTC_10x5_sRGB,
        196 => MTLPixelFormatASTC_10x6_sRGB,
        197 => MTLPixelFormatASTC_10x8_sRGB,
        198 => MTLPixelFormatASTC_10x10_sRGB,
        199 => MTLPixelFormatASTC_12x10_sRGB,
        200 => MTLPixelFormatASTC_12x12_sRGB,
        204 => MTLPixelFormatASTC_4x4_LDR,
        205 => MTLPixelFormatASTC_5x4_LDR,
        206 => MTLPixelFormatASTC_5x5_LDR,
        207 => MTLPixelFormatASTC_6x5_LDR,
        208 => MTLPixelFormatASTC_6x6_LDR,
        210 => MTLPixelFormatASTC_8x5_LDR,
        211 => MTLPixelFormatASTC_8x6_LDR,
        212 => MTLPixelFormatASTC_8x8_LDR,
        213 => MTLPixelFormatASTC_10x5_LDR,
        214 => MTLPixelFormatASTC_10x6_LDR,
        215 => MTLPixelFormatASTC_10x8_LDR,
        216 => MTLPixelFormatASTC_10x10_LDR,
        217 => MTLPixelFormatASTC_12x10_LDR,
        218 => MTLPixelFormatASTC_12x12_LDR,
        222 => MTLPixelFormatASTC_4x4_HDR,
        223 => MTLPixelFormatASTC_5x4_HDR,
        224 => MTLPixelFormatASTC_5x5_HDR,
        225 => MTLPixelFormatASTC_6x5_HDR,
        226 => MTLPixelFormatASTC_6x6_HDR,
        228 => MTLPixelFormatASTC_8x5_HDR,
        229 => MTLPixelFormatASTC_8x6_HDR,
        230 => MTLPixelFormatASTC_8x8_HDR,
        231 => MTLPixelFormatASTC_10x5_HDR,
        232 => MTLPixelFormatASTC_10x6_HDR,
        233 => MTLPixelFormatASTC_10x8_HDR,
        234 => MTLPixelFormatASTC_10x10_HDR,
        235 => MTLPixelFormatASTC_12x10_HDR,
        236 => MTLPixelFormatASTC_12x12_HDR,
        240 => MTLPixelFormatGBGR422,
        241 => MTLPixelFormatBGRG422,
        250 => MTLPixelFormatDepth16Unorm,
        252 => MTLPixelFormatDepth32Float,
        253 => MTLPixelFormatStencil8,
        255 => MTLPixelFormatDepth24Unorm_Stencil8,
        260 => MTLPixelFormatDepth32Float_Stencil8,
        261 => MTLPixelFormatX32_Stencil8,
        262 => MTLPixelFormatX24_Stencil8,
        _ => throw ArgumentError('Unknown value for MTLPixelFormat: $value'),
      };
}

late final _class_CIImage = objc.getClass("CIImage");
late final _sel_autoAdjustmentFilters =
    objc.registerName("autoAdjustmentFilters");
late final _sel_autoAdjustmentFiltersWithOptions_ =
    objc.registerName("autoAdjustmentFiltersWithOptions:");

/// AutoAdjustment
extension AutoAdjustment on CIImage {
  /// autoAdjustmentFilters
  objc.NSArray autoAdjustmentFilters() {
    objc.checkOsVersionInternal('CIImage.autoAdjustmentFilters',
        macOS: (false, (10, 8, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_autoAdjustmentFilters);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// autoAdjustmentFiltersWithOptions:
  objc.NSArray autoAdjustmentFiltersWithOptions_(objc.NSDictionary? options) {
    objc.checkOsVersionInternal('CIImage.autoAdjustmentFiltersWithOptions:',
        macOS: (false, (10, 8, 0)));
    final _ret = _objc_msgSend_1sotr3r(
        this.ref.pointer,
        _sel_autoAdjustmentFiltersWithOptions_,
        options?.ref.pointer ?? ffi.nullptr);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }
}

late final _sel_imageByConvertingWorkingSpaceToLab =
    objc.registerName("imageByConvertingWorkingSpaceToLab");
late final _sel_imageByConvertingLabToWorkingSpace =
    objc.registerName("imageByConvertingLabToWorkingSpace");

/// LabConversion
extension LabConversion on CIImage {
  /// imageByConvertingWorkingSpaceToLab
  CIImage imageByConvertingWorkingSpaceToLab() {
    objc.checkOsVersionInternal('CIImage.imageByConvertingWorkingSpaceToLab',
        macOS: (false, (13, 0, 0)));
    final _ret = _objc_msgSend_151sglz(
        this.ref.pointer, _sel_imageByConvertingWorkingSpaceToLab);
    return CIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// imageByConvertingLabToWorkingSpace
  CIImage imageByConvertingLabToWorkingSpace() {
    objc.checkOsVersionInternal('CIImage.imageByConvertingLabToWorkingSpace',
        macOS: (false, (13, 0, 0)));
    final _ret = _objc_msgSend_151sglz(
        this.ref.pointer, _sel_imageByConvertingLabToWorkingSpace);
    return CIImage.castFromPointer(_ret, retain: true, release: true);
  }
}

late final _class_AVDepthData = objc.getClass("AVDepthData");

/// AVDepthData
class AVDepthData extends objc.ObjCObjectBase {
  AVDepthData._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [AVDepthData] that points to the same underlying object as [other].
  AVDepthData.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [AVDepthData] that wraps the given raw object pointer.
  AVDepthData.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [AVDepthData].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_AVDepthData);
  }
}

late final _sel_depthData = objc.registerName("depthData");

/// AVDepthData
extension AVDepthData$1 on CIImage {
  /// depthData
  AVDepthData? get depthData {
    objc.checkOsVersionInternal('CIImage.depthData',
        macOS: (false, (10, 13, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_depthData);
    return _ret.address == 0
        ? null
        : AVDepthData.castFromPointer(_ret, retain: true, release: true);
  }
}

late final _class_AVPortraitEffectsMatte =
    objc.getClass("AVPortraitEffectsMatte");

/// AVPortraitEffectsMatte
class AVPortraitEffectsMatte extends objc.ObjCObjectBase {
  AVPortraitEffectsMatte._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [AVPortraitEffectsMatte] that points to the same underlying object as [other].
  AVPortraitEffectsMatte.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [AVPortraitEffectsMatte] that wraps the given raw object pointer.
  AVPortraitEffectsMatte.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [AVPortraitEffectsMatte].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_AVPortraitEffectsMatte);
  }
}

late final _sel_portraitEffectsMatte =
    objc.registerName("portraitEffectsMatte");

/// AVPortraitEffectsMatte
extension AVPortraitEffectsMatte$1 on CIImage {
  /// portraitEffectsMatte
  AVPortraitEffectsMatte? get portraitEffectsMatte {
    objc.checkOsVersionInternal('CIImage.portraitEffectsMatte',
        macOS: (false, (10, 14, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_portraitEffectsMatte);
    return _ret.address == 0
        ? null
        : AVPortraitEffectsMatte.castFromPointer(_ret,
            retain: true, release: true);
  }
}

late final _class_AVSemanticSegmentationMatte =
    objc.getClass("AVSemanticSegmentationMatte");

/// AVSemanticSegmentationMatte
class AVSemanticSegmentationMatte extends objc.ObjCObjectBase {
  AVSemanticSegmentationMatte._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [AVSemanticSegmentationMatte] that points to the same underlying object as [other].
  AVSemanticSegmentationMatte.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [AVSemanticSegmentationMatte] that wraps the given raw object pointer.
  AVSemanticSegmentationMatte.castFromPointer(
      ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false,
      bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [AVSemanticSegmentationMatte].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_,
        _class_AVSemanticSegmentationMatte);
  }
}

late final _sel_semanticSegmentationMatte =
    objc.registerName("semanticSegmentationMatte");

/// AVSemanticSegmentationMatte
extension AVSemanticSegmentationMatte$1 on CIImage {
  /// semanticSegmentationMatte
  AVSemanticSegmentationMatte? get semanticSegmentationMatte {
    objc.checkOsVersionInternal('CIImage.semanticSegmentationMatte',
        macOS: (false, (10, 15, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_semanticSegmentationMatte);
    return _ret.address == 0
        ? null
        : AVSemanticSegmentationMatte.castFromPointer(_ret,
            retain: true, release: true);
  }
}

late final _sel_imageWithImageProvider_size__format_colorSpace_options_ = objc
    .registerName("imageWithImageProvider:size::format:colorSpace:options:");
final _objc_msgSend_ieoh10 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Size,
                ffi.Size,
                ffi.Int,
                ffi.Pointer<CGColorSpace>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            int,
            int,
            int,
            ffi.Pointer<CGColorSpace>,
            ffi.Pointer<objc.ObjCObject>)>();

/// CIImageProvider
extension CIImageProvider on CIImage {
  /// imageWithImageProvider:size::format:colorSpace:options:
  static CIImage imageWithImageProvider_size__format_colorSpace_options_(
      objc.ObjCObjectBase p,
      int width,
      int height,
      int f,
      ffi.Pointer<CGColorSpace> cs,
      objc.NSDictionary? options) {
    objc.checkOsVersionInternal(
        'CIImage.imageWithImageProvider:size::format:colorSpace:options:',
        macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_ieoh10(
        _class_CIImage,
        _sel_imageWithImageProvider_size__format_colorSpace_options_,
        p.ref.pointer,
        width,
        height,
        f,
        cs,
        options?.ref.pointer ?? ffi.nullptr);
    return CIImage.castFromPointer(_ret, retain: true, release: true);
  }
}

late final _sel_imageWithCGImage_ = objc.registerName("imageWithCGImage:");
final _objc_msgSend_2tjjtl = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<CGImage>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<CGImage>)>();
late final _sel_imageWithCGImage_options_ =
    objc.registerName("imageWithCGImage:options:");
final _objc_msgSend_vew1en = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<CGImage>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<CGImage>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_imageWithCGImageSource_index_options_ =
    objc.registerName("imageWithCGImageSource:index:options:");
final _objc_msgSend_jgi41m = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<CGImageSource>,
                ffi.Size,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<CGImageSource>,
            int,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_imageWithCGLayer_ = objc.registerName("imageWithCGLayer:");
final _objc_msgSend_1a79d95 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<CGLayer>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<CGLayer>)>();
late final _sel_imageWithCGLayer_options_ =
    objc.registerName("imageWithCGLayer:options:");
final _objc_msgSend_16r4c0v = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<CGLayer>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<CGLayer>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_imageWithBitmapData_bytesPerRow_size_format_colorSpace_ = objc
    .registerName("imageWithBitmapData:bytesPerRow:size:format:colorSpace:");
final _objc_msgSend_c5liti = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Size,
                CGSize,
                ffi.Int,
                ffi.Pointer<CGColorSpace>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            int,
            CGSize,
            int,
            ffi.Pointer<CGColorSpace>)>();
late final _sel_imageWithTexture_size_flipped_colorSpace_ =
    objc.registerName("imageWithTexture:size:flipped:colorSpace:");
final _objc_msgSend_e34apk = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.UnsignedInt,
                CGSize,
                ffi.Bool,
                ffi.Pointer<CGColorSpace>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            int,
            CGSize,
            bool,
            ffi.Pointer<CGColorSpace>)>();
late final _sel_imageWithTexture_size_flipped_options_ =
    objc.registerName("imageWithTexture:size:flipped:options:");
final _objc_msgSend_phj3ma = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.UnsignedInt,
                CGSize,
                ffi.Bool,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            int,
            CGSize,
            bool,
            ffi.Pointer<objc.ObjCObject>)>();
late final _protocol_MTLTexture = objc.getProtocol("MTLTexture");
late final _sel_conformsToProtocol_ = objc.registerName("conformsToProtocol:");
final _objc_msgSend_e3qsqz = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCProtocol>)>>()
    .asFunction<
        bool Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCProtocol>)>();

/// MTLTexture
interface class MTLTexture extends objc.ObjCProtocolBase {
  MTLTexture._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [MTLTexture] that points to the same underlying object as [other].
  MTLTexture.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MTLTexture] that wraps the given raw object pointer.
  MTLTexture.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MTLTexture].
  static bool conformsTo(objc.ObjCObjectBase obj) {
    return _objc_msgSend_e3qsqz(
        obj.ref.pointer, _sel_conformsToProtocol_, _protocol_MTLTexture);
  }

  /// Returns the [objc.Protocol] object for this protocol.
  static objc.Protocol get $protocol =>
      objc.Protocol.castFromPointer(_protocol_MTLTexture.cast());

  /// Builds an object that implements the MTLTexture protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static MTLTexture implement({bool $keepIsolateAlive = true}) {
    final builder = objc.ObjCProtocolBuilder(debugName: 'MTLTexture');

    builder.addProtocol($protocol);
    return MTLTexture.castFrom(
        builder.build(keepIsolateAlive: $keepIsolateAlive));
  }

  /// Adds the implementation of the MTLTexture protocol to an existing
  /// [objc.ObjCProtocolBuilder].
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilder(objc.ObjCProtocolBuilder builder,
      {bool $keepIsolateAlive = true}) {
    builder.addProtocol($protocol);
  }
}

late final _sel_imageWithMTLTexture_options_ =
    objc.registerName("imageWithMTLTexture:options:");
final _objc_msgSend_15qeuct = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_imageWithContentsOfURL_ =
    objc.registerName("imageWithContentsOfURL:");
late final _sel_imageWithContentsOfURL_options_ =
    objc.registerName("imageWithContentsOfURL:options:");
late final _sel_imageWithData_ = objc.registerName("imageWithData:");
late final _sel_imageWithData_options_ =
    objc.registerName("imageWithData:options:");
late final _sel_imageWithCVImageBuffer_ =
    objc.registerName("imageWithCVImageBuffer:");
final _objc_msgSend_1e00d1f = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<__CVBuffer>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<__CVBuffer>)>();
late final _sel_imageWithCVImageBuffer_options_ =
    objc.registerName("imageWithCVImageBuffer:options:");
final _objc_msgSend_vhfhux = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<__CVBuffer>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<__CVBuffer>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_imageWithCVPixelBuffer_ =
    objc.registerName("imageWithCVPixelBuffer:");
late final _sel_imageWithCVPixelBuffer_options_ =
    objc.registerName("imageWithCVPixelBuffer:options:");
late final _sel_imageWithIOSurface_ = objc.registerName("imageWithIOSurface:");
final _objc_msgSend_13p6fbj = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<__IOSurface>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<__IOSurface>)>();
late final _sel_imageWithIOSurface_options_ =
    objc.registerName("imageWithIOSurface:options:");
final _objc_msgSend_14uoevp = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<__IOSurface>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<__IOSurface>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_imageWithColor_ = objc.registerName("imageWithColor:");
late final _sel_emptyImage = objc.registerName("emptyImage");
late final _sel_blackImage = objc.registerName("blackImage");
late final _sel_whiteImage = objc.registerName("whiteImage");
late final _sel_grayImage = objc.registerName("grayImage");
late final _sel_redImage = objc.registerName("redImage");
late final _sel_greenImage = objc.registerName("greenImage");
late final _sel_blueImage = objc.registerName("blueImage");
late final _sel_cyanImage = objc.registerName("cyanImage");
late final _sel_magentaImage = objc.registerName("magentaImage");
late final _sel_yellowImage = objc.registerName("yellowImage");
late final _sel_clearImage = objc.registerName("clearImage");
late final _sel_initWithCGImage_ = objc.registerName("initWithCGImage:");
late final _sel_initWithCGImage_options_ =
    objc.registerName("initWithCGImage:options:");
late final _sel_initWithCGImageSource_index_options_ =
    objc.registerName("initWithCGImageSource:index:options:");
late final _sel_initWithCGLayer_ = objc.registerName("initWithCGLayer:");
late final _sel_initWithCGLayer_options_ =
    objc.registerName("initWithCGLayer:options:");
late final _sel_initWithData_ = objc.registerName("initWithData:");
late final _sel_initWithData_options_ =
    objc.registerName("initWithData:options:");
late final _sel_initWithBitmapData_bytesPerRow_size_format_colorSpace_ =
    objc.registerName("initWithBitmapData:bytesPerRow:size:format:colorSpace:");
late final _sel_initWithTexture_size_flipped_colorSpace_ =
    objc.registerName("initWithTexture:size:flipped:colorSpace:");
late final _sel_initWithTexture_size_flipped_options_ =
    objc.registerName("initWithTexture:size:flipped:options:");
late final _sel_initWithMTLTexture_options_ =
    objc.registerName("initWithMTLTexture:options:");
late final _sel_initWithContentsOfURL_ =
    objc.registerName("initWithContentsOfURL:");
late final _sel_initWithContentsOfURL_options_ =
    objc.registerName("initWithContentsOfURL:options:");
late final _sel_initWithIOSurface_ = objc.registerName("initWithIOSurface:");
late final _sel_initWithIOSurface_options_ =
    objc.registerName("initWithIOSurface:options:");
late final _sel_initWithIOSurface_plane_format_options_ =
    objc.registerName("initWithIOSurface:plane:format:options:");
final _objc_msgSend_z0b586 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<__IOSurface>,
                ffi.Size,
                ffi.Int,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<__IOSurface>,
            int,
            int,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_initWithCVImageBuffer_ =
    objc.registerName("initWithCVImageBuffer:");
late final _sel_initWithCVImageBuffer_options_ =
    objc.registerName("initWithCVImageBuffer:options:");
late final _sel_initWithCVPixelBuffer_ =
    objc.registerName("initWithCVPixelBuffer:");
late final _sel_initWithCVPixelBuffer_options_ =
    objc.registerName("initWithCVPixelBuffer:options:");
late final _sel_initWithColor_ = objc.registerName("initWithColor:");
late final _sel_imageByApplyingTransform_ =
    objc.registerName("imageByApplyingTransform:");
final _objc_msgSend_1h5ri4v = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, CGAffineTransform)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, CGAffineTransform)>();
late final _sel_imageByApplyingTransform_highQualityDownsample_ =
    objc.registerName("imageByApplyingTransform:highQualityDownsample:");
final _objc_msgSend_a19wh7 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, CGAffineTransform, ffi.Bool)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, CGAffineTransform, bool)>();
late final _sel_imageByApplyingOrientation_ =
    objc.registerName("imageByApplyingOrientation:");
final _objc_msgSend_14hvw5k = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Int)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_imageTransformForOrientation_ =
    objc.registerName("imageTransformForOrientation:");
final _objc_msgSend_18mng1s = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            CGAffineTransform Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Int)>>()
    .asFunction<
        CGAffineTransform Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
final _objc_msgSend_18mng1sStret = objc.msgSendStretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<CGAffineTransform>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Int)>>()
    .asFunction<
        void Function(
            ffi.Pointer<CGAffineTransform>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            int)>();
late final _sel_imageByApplyingCGOrientation_ =
    objc.registerName("imageByApplyingCGOrientation:");
final _objc_msgSend_1e589dh = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Uint32)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_imageTransformForCGOrientation_ =
    objc.registerName("imageTransformForCGOrientation:");
final _objc_msgSend_1w1yiot = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            CGAffineTransform Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Uint32)>>()
    .asFunction<
        CGAffineTransform Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
final _objc_msgSend_1w1yiotStret = objc.msgSendStretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<CGAffineTransform>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Uint32)>>()
    .asFunction<
        void Function(
            ffi.Pointer<CGAffineTransform>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            int)>();
late final _sel_imageByCompositingOverImage_ =
    objc.registerName("imageByCompositingOverImage:");
late final _sel_imageByCroppingToRect_ =
    objc.registerName("imageByCroppingToRect:");
final _objc_msgSend_15yz4e6 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, CGRect)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, CGRect)>();
late final _sel_imageByClampingToExtent =
    objc.registerName("imageByClampingToExtent");
late final _sel_imageByClampingToRect_ =
    objc.registerName("imageByClampingToRect:");
late final _sel_imageByApplyingFilter_withInputParameters_ =
    objc.registerName("imageByApplyingFilter:withInputParameters:");
late final _sel_imageByApplyingFilter_ =
    objc.registerName("imageByApplyingFilter:");
late final _sel_imageByColorMatchingColorSpaceToWorkingSpace_ =
    objc.registerName("imageByColorMatchingColorSpaceToWorkingSpace:");
final _objc_msgSend_2vhe27 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<CGColorSpace>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<CGColorSpace>)>();
late final _sel_imageByColorMatchingWorkingSpaceToColorSpace_ =
    objc.registerName("imageByColorMatchingWorkingSpaceToColorSpace:");
late final _sel_imageByPremultiplyingAlpha =
    objc.registerName("imageByPremultiplyingAlpha");
late final _sel_imageByUnpremultiplyingAlpha =
    objc.registerName("imageByUnpremultiplyingAlpha");
late final _sel_imageBySettingAlphaOneInExtent_ =
    objc.registerName("imageBySettingAlphaOneInExtent:");
late final _sel_imageByApplyingGaussianBlurWithSigma_ =
    objc.registerName("imageByApplyingGaussianBlurWithSigma:");
final _objc_msgSend_oa8mke = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Double)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, double)>();
late final _sel_imageBySettingProperties_ =
    objc.registerName("imageBySettingProperties:");
late final _sel_imageBySamplingLinear =
    objc.registerName("imageBySamplingLinear");
late final _sel_imageBySamplingNearest =
    objc.registerName("imageBySamplingNearest");
late final _sel_imageByInsertingIntermediate =
    objc.registerName("imageByInsertingIntermediate");
late final _sel_imageByInsertingIntermediate_ =
    objc.registerName("imageByInsertingIntermediate:");
final _objc_msgSend_1t6aok9 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Bool)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, bool)>();
late final _sel_imageByApplyingGainMap_ =
    objc.registerName("imageByApplyingGainMap:");
late final _sel_imageByApplyingGainMap_headroom_ =
    objc.registerName("imageByApplyingGainMap:headroom:");
final _objc_msgSend_1qw4wvv = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Float)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            double)>();
late final _sel_extent = objc.registerName("extent");
final _objc_msgSend_bu1hbw = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            CGRect Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        CGRect Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
final _objc_msgSend_bu1hbwStret = objc.msgSendStretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<CGRect>, ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        void Function(ffi.Pointer<CGRect>, ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_isOpaque = objc.registerName("isOpaque");
late final _sel_properties = objc.registerName("properties");
late final _class_CIFilterShape = objc.getClass("CIFilterShape");
late final _sel_shapeWithRect_ = objc.registerName("shapeWithRect:");
late final _sel_initWithRect_ = objc.registerName("initWithRect:");
late final _sel_transformBy_interior_ =
    objc.registerName("transformBy:interior:");
late final _sel_insetByX_Y_ = objc.registerName("insetByX:Y:");
final _objc_msgSend_1v4bsi7 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Int, ffi.Int)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int, int)>();
late final _sel_unionWith_ = objc.registerName("unionWith:");
late final _sel_unionWithRect_ = objc.registerName("unionWithRect:");
late final _sel_intersectWith_ = objc.registerName("intersectWith:");
late final _sel_intersectWithRect_ = objc.registerName("intersectWithRect:");

/// CIFilterShape
class CIFilterShape extends objc.NSObject implements objc.NSCopying {
  CIFilterShape._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('CIFilterShape', macOS: (false, (10, 4, 0)));
  }

  /// Constructs a [CIFilterShape] that points to the same underlying object as [other].
  CIFilterShape.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [CIFilterShape] that wraps the given raw object pointer.
  CIFilterShape.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [CIFilterShape].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_CIFilterShape);
  }

  /// shapeWithRect:
  static CIFilterShape shapeWithRect_(CGRect r) {
    objc.checkOsVersionInternal('CIFilterShape.shapeWithRect:',
        macOS: (false, (10, 4, 0)));
    final _ret =
        _objc_msgSend_15yz4e6(_class_CIFilterShape, _sel_shapeWithRect_, r);
    return CIFilterShape.castFromPointer(_ret, retain: true, release: true);
  }

  /// initWithRect:
  CIFilterShape initWithRect_(CGRect r) {
    objc.checkOsVersionInternal('CIFilterShape.initWithRect:',
        macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_15yz4e6(
        this.ref.retainAndReturnPointer(), _sel_initWithRect_, r);
    return CIFilterShape.castFromPointer(_ret, retain: false, release: true);
  }

  /// transformBy:interior:
  CIFilterShape transformBy_interior_(CGAffineTransform m, bool flag) {
    objc.checkOsVersionInternal('CIFilterShape.transformBy:interior:',
        macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_a19wh7(
        this.ref.pointer, _sel_transformBy_interior_, m, flag);
    return CIFilterShape.castFromPointer(_ret, retain: true, release: true);
  }

  /// insetByX:Y:
  CIFilterShape insetByX_Y_(int dx, int dy) {
    objc.checkOsVersionInternal('CIFilterShape.insetByX:Y:',
        macOS: (false, (10, 4, 0)));
    final _ret =
        _objc_msgSend_1v4bsi7(this.ref.pointer, _sel_insetByX_Y_, dx, dy);
    return CIFilterShape.castFromPointer(_ret, retain: true, release: true);
  }

  /// unionWith:
  CIFilterShape unionWith_(CIFilterShape s2) {
    objc.checkOsVersionInternal('CIFilterShape.unionWith:',
        macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_1sotr3r(
        this.ref.pointer, _sel_unionWith_, s2.ref.pointer);
    return CIFilterShape.castFromPointer(_ret, retain: true, release: true);
  }

  /// unionWithRect:
  CIFilterShape unionWithRect_(CGRect r) {
    objc.checkOsVersionInternal('CIFilterShape.unionWithRect:',
        macOS: (false, (10, 4, 0)));
    final _ret =
        _objc_msgSend_15yz4e6(this.ref.pointer, _sel_unionWithRect_, r);
    return CIFilterShape.castFromPointer(_ret, retain: true, release: true);
  }

  /// intersectWith:
  CIFilterShape intersectWith_(CIFilterShape s2) {
    objc.checkOsVersionInternal('CIFilterShape.intersectWith:',
        macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_1sotr3r(
        this.ref.pointer, _sel_intersectWith_, s2.ref.pointer);
    return CIFilterShape.castFromPointer(_ret, retain: true, release: true);
  }

  /// intersectWithRect:
  CIFilterShape intersectWithRect_(CGRect r) {
    objc.checkOsVersionInternal('CIFilterShape.intersectWithRect:',
        macOS: (false, (10, 4, 0)));
    final _ret =
        _objc_msgSend_15yz4e6(this.ref.pointer, _sel_intersectWithRect_, r);
    return CIFilterShape.castFromPointer(_ret, retain: true, release: true);
  }

  /// extent
  CGRect get extent {
    objc.checkOsVersionInternal('CIFilterShape.extent',
        macOS: (false, (10, 4, 0)));
    final _ptr = pkg_ffi.calloc<CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_bu1hbwStret(_ptr, this.ref.pointer, _sel_extent)
        : _ptr.ref = _objc_msgSend_bu1hbw(this.ref.pointer, _sel_extent);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<CGRect>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<CGRect>(_finalizable);
  }

  /// init
  CIFilterShape init() {
    objc.checkOsVersionInternal('CIFilterShape.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return CIFilterShape.castFromPointer(_ret, retain: false, release: true);
  }

  /// new
  static CIFilterShape new$() {
    final _ret = _objc_msgSend_151sglz(_class_CIFilterShape, _sel_new);
    return CIFilterShape.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static CIFilterShape allocWithZone_(ffi.Pointer<objc.NSZone> zone) {
    final _ret =
        _objc_msgSend_1cwp428(_class_CIFilterShape, _sel_allocWithZone_, zone);
    return CIFilterShape.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static CIFilterShape alloc() {
    final _ret = _objc_msgSend_151sglz(_class_CIFilterShape, _sel_alloc);
    return CIFilterShape.castFromPointer(_ret, retain: false, release: true);
  }

  /// self
  CIFilterShape self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return CIFilterShape.castFromPointer(_ret, retain: true, release: true);
  }

  /// retain
  CIFilterShape retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return CIFilterShape.castFromPointer(_ret, retain: true, release: true);
  }

  /// autorelease
  CIFilterShape autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return CIFilterShape.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a new instance of CIFilterShape constructed with the default `new` method.
  factory CIFilterShape() => new$();
}

late final _sel_definition = objc.registerName("definition");
late final _sel_url = objc.registerName("url");
late final _sel_contentHeadroom = objc.registerName("contentHeadroom");
final _objc_msgSend_2cgrxl = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Float Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        double Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
final _objc_msgSend_2cgrxlFpret = objc.msgSendFpretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Float Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        double Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_pixelBuffer = objc.registerName("pixelBuffer");
final _objc_msgSend_19zp75z = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<__CVBuffer> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<__CVBuffer> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_CGImage = objc.registerName("CGImage");
final _objc_msgSend_y1izi1 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<CGImage> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<CGImage> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_metalTexture = objc.registerName("metalTexture");
late final _sel_regionOfInterestForImage_inRect_ =
    objc.registerName("regionOfInterestForImage:inRect:");
final _objc_msgSend_1yifw1j = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            CGRect Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                CGRect)>>()
    .asFunction<
        CGRect Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            CGRect)>();
final _objc_msgSend_1yifw1jStret = objc.msgSendStretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<CGRect>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                CGRect)>>()
    .asFunction<
        void Function(
            ffi.Pointer<CGRect>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            CGRect)>();
late final _sel_initWithDepthData_options_ =
    objc.registerName("initWithDepthData:options:");
late final _sel_initWithDepthData_ = objc.registerName("initWithDepthData:");
late final _sel_imageWithDepthData_options_ =
    objc.registerName("imageWithDepthData:options:");
late final _sel_imageWithDepthData_ = objc.registerName("imageWithDepthData:");
late final _sel_initWithPortaitEffectsMatte_options_ =
    objc.registerName("initWithPortaitEffectsMatte:options:");
late final _sel_initWithPortaitEffectsMatte_ =
    objc.registerName("initWithPortaitEffectsMatte:");
late final _sel_imageWithPortaitEffectsMatte_options_ =
    objc.registerName("imageWithPortaitEffectsMatte:options:");
late final _sel_imageWithPortaitEffectsMatte_ =
    objc.registerName("imageWithPortaitEffectsMatte:");
late final _sel_initWithSemanticSegmentationMatte_options_ =
    objc.registerName("initWithSemanticSegmentationMatte:options:");
late final _sel_initWithSemanticSegmentationMatte_ =
    objc.registerName("initWithSemanticSegmentationMatte:");
late final _sel_imageWithSemanticSegmentationMatte_options_ =
    objc.registerName("imageWithSemanticSegmentationMatte:options:");
late final _sel_imageWithSemanticSegmentationMatte_ =
    objc.registerName("imageWithSemanticSegmentationMatte:");
late final _sel_initWithImageProvider_size__format_colorSpace_options_ =
    objc.registerName("initWithImageProvider:size::format:colorSpace:options:");

/// CIImage
class CIImage extends objc.NSObject
    implements objc.NSSecureCoding, objc.NSCopying {
  CIImage._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('CIImage', macOS: (false, (10, 4, 0)));
  }

  /// Constructs a [CIImage] that points to the same underlying object as [other].
  CIImage.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [CIImage] that wraps the given raw object pointer.
  CIImage.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [CIImage].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_CIImage);
  }

  /// imageWithCGImage:
  static CIImage imageWithCGImage_(ffi.Pointer<CGImage> image) {
    objc.checkOsVersionInternal('CIImage.imageWithCGImage:',
        macOS: (false, (10, 4, 0)));
    final _ret =
        _objc_msgSend_2tjjtl(_class_CIImage, _sel_imageWithCGImage_, image);
    return CIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// imageWithCGImage:options:
  static CIImage imageWithCGImage_options_(
      ffi.Pointer<CGImage> image, objc.NSDictionary? options) {
    objc.checkOsVersionInternal('CIImage.imageWithCGImage:options:',
        macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_vew1en(
        _class_CIImage,
        _sel_imageWithCGImage_options_,
        image,
        options?.ref.pointer ?? ffi.nullptr);
    return CIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// imageWithCGImageSource:index:options:
  static CIImage imageWithCGImageSource_index_options_(
      ffi.Pointer<CGImageSource> source, int index, objc.NSDictionary? dict) {
    objc.checkOsVersionInternal('CIImage.imageWithCGImageSource:index:options:',
        macOS: (false, (10, 15, 0)));
    final _ret = _objc_msgSend_jgi41m(
        _class_CIImage,
        _sel_imageWithCGImageSource_index_options_,
        source,
        index,
        dict?.ref.pointer ?? ffi.nullptr);
    return CIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// imageWithCGLayer:
  static CIImage imageWithCGLayer_(ffi.Pointer<CGLayer> layer) {
    objc.checkOsVersionInternal('CIImage.imageWithCGLayer:',
        macOS: (false, (10, 4, 0)));
    final _ret =
        _objc_msgSend_1a79d95(_class_CIImage, _sel_imageWithCGLayer_, layer);
    return CIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// imageWithCGLayer:options:
  static CIImage imageWithCGLayer_options_(
      ffi.Pointer<CGLayer> layer, objc.NSDictionary? options) {
    objc.checkOsVersionInternal('CIImage.imageWithCGLayer:options:',
        macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_16r4c0v(
        _class_CIImage,
        _sel_imageWithCGLayer_options_,
        layer,
        options?.ref.pointer ?? ffi.nullptr);
    return CIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// imageWithBitmapData:bytesPerRow:size:format:colorSpace:
  static CIImage imageWithBitmapData_bytesPerRow_size_format_colorSpace_(
      objc.NSData data,
      int bytesPerRow,
      CGSize size,
      int format,
      ffi.Pointer<CGColorSpace> colorSpace) {
    objc.checkOsVersionInternal(
        'CIImage.imageWithBitmapData:bytesPerRow:size:format:colorSpace:',
        macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_c5liti(
        _class_CIImage,
        _sel_imageWithBitmapData_bytesPerRow_size_format_colorSpace_,
        data.ref.pointer,
        bytesPerRow,
        size,
        format,
        colorSpace);
    return CIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// imageWithTexture:size:flipped:colorSpace:
  static CIImage imageWithTexture_size_flipped_colorSpace_(int name,
      CGSize size, bool flipped, ffi.Pointer<CGColorSpace> colorSpace) {
    objc.checkOsVersionInternal(
        'CIImage.imageWithTexture:size:flipped:colorSpace:',
        macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_e34apk(
        _class_CIImage,
        _sel_imageWithTexture_size_flipped_colorSpace_,
        name,
        size,
        flipped,
        colorSpace);
    return CIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// imageWithTexture:size:flipped:options:
  static CIImage imageWithTexture_size_flipped_options_(
      int name, CGSize size, bool flipped, objc.NSDictionary? options) {
    objc.checkOsVersionInternal(
        'CIImage.imageWithTexture:size:flipped:options:',
        macOS: (false, (10, 9, 0)));
    final _ret = _objc_msgSend_phj3ma(
        _class_CIImage,
        _sel_imageWithTexture_size_flipped_options_,
        name,
        size,
        flipped,
        options?.ref.pointer ?? ffi.nullptr);
    return CIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// imageWithMTLTexture:options:
  static CIImage? imageWithMTLTexture_options_(
      MTLTexture texture, objc.NSDictionary? options) {
    objc.checkOsVersionInternal('CIImage.imageWithMTLTexture:options:',
        macOS: (false, (10, 11, 0)));
    final _ret = _objc_msgSend_15qeuct(
        _class_CIImage,
        _sel_imageWithMTLTexture_options_,
        texture.ref.pointer,
        options?.ref.pointer ?? ffi.nullptr);
    return _ret.address == 0
        ? null
        : CIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// imageWithContentsOfURL:
  static CIImage? imageWithContentsOfURL_(objc.NSURL url) {
    objc.checkOsVersionInternal('CIImage.imageWithContentsOfURL:',
        macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_1sotr3r(
        _class_CIImage, _sel_imageWithContentsOfURL_, url.ref.pointer);
    return _ret.address == 0
        ? null
        : CIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// imageWithContentsOfURL:options:
  static CIImage? imageWithContentsOfURL_options_(
      objc.NSURL url, objc.NSDictionary? options) {
    objc.checkOsVersionInternal('CIImage.imageWithContentsOfURL:options:',
        macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_15qeuct(
        _class_CIImage,
        _sel_imageWithContentsOfURL_options_,
        url.ref.pointer,
        options?.ref.pointer ?? ffi.nullptr);
    return _ret.address == 0
        ? null
        : CIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// imageWithData:
  static CIImage? imageWithData_(objc.NSData data) {
    objc.checkOsVersionInternal('CIImage.imageWithData:',
        macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_1sotr3r(
        _class_CIImage, _sel_imageWithData_, data.ref.pointer);
    return _ret.address == 0
        ? null
        : CIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// imageWithData:options:
  static CIImage? imageWithData_options_(
      objc.NSData data, objc.NSDictionary? options) {
    objc.checkOsVersionInternal('CIImage.imageWithData:options:',
        macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_15qeuct(
        _class_CIImage,
        _sel_imageWithData_options_,
        data.ref.pointer,
        options?.ref.pointer ?? ffi.nullptr);
    return _ret.address == 0
        ? null
        : CIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// imageWithCVImageBuffer:
  static CIImage imageWithCVImageBuffer_(ffi.Pointer<__CVBuffer> imageBuffer) {
    objc.checkOsVersionInternal('CIImage.imageWithCVImageBuffer:',
        macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_1e00d1f(
        _class_CIImage, _sel_imageWithCVImageBuffer_, imageBuffer);
    return CIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// imageWithCVImageBuffer:options:
  static CIImage imageWithCVImageBuffer_options_(
      ffi.Pointer<__CVBuffer> imageBuffer, objc.NSDictionary? options) {
    objc.checkOsVersionInternal('CIImage.imageWithCVImageBuffer:options:',
        macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_vhfhux(
        _class_CIImage,
        _sel_imageWithCVImageBuffer_options_,
        imageBuffer,
        options?.ref.pointer ?? ffi.nullptr);
    return CIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// imageWithCVPixelBuffer:
  static CIImage imageWithCVPixelBuffer_(ffi.Pointer<__CVBuffer> pixelBuffer) {
    objc.checkOsVersionInternal('CIImage.imageWithCVPixelBuffer:',
        macOS: (false, (10, 11, 0)));
    final _ret = _objc_msgSend_1e00d1f(
        _class_CIImage, _sel_imageWithCVPixelBuffer_, pixelBuffer);
    return CIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// imageWithCVPixelBuffer:options:
  static CIImage imageWithCVPixelBuffer_options_(
      ffi.Pointer<__CVBuffer> pixelBuffer, objc.NSDictionary? options) {
    objc.checkOsVersionInternal('CIImage.imageWithCVPixelBuffer:options:',
        macOS: (false, (10, 11, 0)));
    final _ret = _objc_msgSend_vhfhux(
        _class_CIImage,
        _sel_imageWithCVPixelBuffer_options_,
        pixelBuffer,
        options?.ref.pointer ?? ffi.nullptr);
    return CIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// imageWithIOSurface:
  static CIImage imageWithIOSurface_(ffi.Pointer<__IOSurface> surface) {
    objc.checkOsVersionInternal('CIImage.imageWithIOSurface:',
        macOS: (false, (10, 6, 0)));
    final _ret = _objc_msgSend_13p6fbj(
        _class_CIImage, _sel_imageWithIOSurface_, surface);
    return CIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// imageWithIOSurface:options:
  static CIImage imageWithIOSurface_options_(
      ffi.Pointer<__IOSurface> surface, objc.NSDictionary? options) {
    objc.checkOsVersionInternal('CIImage.imageWithIOSurface:options:',
        macOS: (false, (10, 6, 0)));
    final _ret = _objc_msgSend_14uoevp(
        _class_CIImage,
        _sel_imageWithIOSurface_options_,
        surface,
        options?.ref.pointer ?? ffi.nullptr);
    return CIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// imageWithColor:
  static CIImage imageWithColor_(CIColor color) {
    objc.checkOsVersionInternal('CIImage.imageWithColor:',
        macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_1sotr3r(
        _class_CIImage, _sel_imageWithColor_, color.ref.pointer);
    return CIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// emptyImage
  static CIImage emptyImage() {
    objc.checkOsVersionInternal('CIImage.emptyImage',
        macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_151sglz(_class_CIImage, _sel_emptyImage);
    return CIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// blackImage
  static CIImage getBlackImage() {
    objc.checkOsVersionInternal('CIImage.blackImage',
        macOS: (false, (10, 15, 0)));
    final _ret = _objc_msgSend_151sglz(_class_CIImage, _sel_blackImage);
    return CIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// whiteImage
  static CIImage getWhiteImage() {
    objc.checkOsVersionInternal('CIImage.whiteImage',
        macOS: (false, (10, 15, 0)));
    final _ret = _objc_msgSend_151sglz(_class_CIImage, _sel_whiteImage);
    return CIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// grayImage
  static CIImage getGrayImage() {
    objc.checkOsVersionInternal('CIImage.grayImage',
        macOS: (false, (10, 15, 0)));
    final _ret = _objc_msgSend_151sglz(_class_CIImage, _sel_grayImage);
    return CIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// redImage
  static CIImage getRedImage() {
    objc.checkOsVersionInternal('CIImage.redImage',
        macOS: (false, (10, 15, 0)));
    final _ret = _objc_msgSend_151sglz(_class_CIImage, _sel_redImage);
    return CIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// greenImage
  static CIImage getGreenImage() {
    objc.checkOsVersionInternal('CIImage.greenImage',
        macOS: (false, (10, 15, 0)));
    final _ret = _objc_msgSend_151sglz(_class_CIImage, _sel_greenImage);
    return CIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// blueImage
  static CIImage getBlueImage() {
    objc.checkOsVersionInternal('CIImage.blueImage',
        macOS: (false, (10, 15, 0)));
    final _ret = _objc_msgSend_151sglz(_class_CIImage, _sel_blueImage);
    return CIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// cyanImage
  static CIImage getCyanImage() {
    objc.checkOsVersionInternal('CIImage.cyanImage',
        macOS: (false, (10, 15, 0)));
    final _ret = _objc_msgSend_151sglz(_class_CIImage, _sel_cyanImage);
    return CIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// magentaImage
  static CIImage getMagentaImage() {
    objc.checkOsVersionInternal('CIImage.magentaImage',
        macOS: (false, (10, 15, 0)));
    final _ret = _objc_msgSend_151sglz(_class_CIImage, _sel_magentaImage);
    return CIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// yellowImage
  static CIImage getYellowImage() {
    objc.checkOsVersionInternal('CIImage.yellowImage',
        macOS: (false, (10, 15, 0)));
    final _ret = _objc_msgSend_151sglz(_class_CIImage, _sel_yellowImage);
    return CIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// clearImage
  static CIImage getClearImage() {
    objc.checkOsVersionInternal('CIImage.clearImage',
        macOS: (false, (10, 15, 0)));
    final _ret = _objc_msgSend_151sglz(_class_CIImage, _sel_clearImage);
    return CIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// initWithCGImage:
  CIImage initWithCGImage_(ffi.Pointer<CGImage> image) {
    objc.checkOsVersionInternal('CIImage.initWithCGImage:',
        macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_2tjjtl(
        this.ref.retainAndReturnPointer(), _sel_initWithCGImage_, image);
    return CIImage.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithCGImage:options:
  CIImage initWithCGImage_options_(
      ffi.Pointer<CGImage> image, objc.NSDictionary? options) {
    objc.checkOsVersionInternal('CIImage.initWithCGImage:options:',
        macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_vew1en(
        this.ref.retainAndReturnPointer(),
        _sel_initWithCGImage_options_,
        image,
        options?.ref.pointer ?? ffi.nullptr);
    return CIImage.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithCGImageSource:index:options:
  CIImage initWithCGImageSource_index_options_(
      ffi.Pointer<CGImageSource> source, int index, objc.NSDictionary? dict) {
    objc.checkOsVersionInternal('CIImage.initWithCGImageSource:index:options:',
        macOS: (false, (10, 15, 0)));
    final _ret = _objc_msgSend_jgi41m(
        this.ref.retainAndReturnPointer(),
        _sel_initWithCGImageSource_index_options_,
        source,
        index,
        dict?.ref.pointer ?? ffi.nullptr);
    return CIImage.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithCGLayer:
  CIImage initWithCGLayer_(ffi.Pointer<CGLayer> layer) {
    objc.checkOsVersionInternal('CIImage.initWithCGLayer:',
        macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_1a79d95(
        this.ref.retainAndReturnPointer(), _sel_initWithCGLayer_, layer);
    return CIImage.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithCGLayer:options:
  CIImage initWithCGLayer_options_(
      ffi.Pointer<CGLayer> layer, objc.NSDictionary? options) {
    objc.checkOsVersionInternal('CIImage.initWithCGLayer:options:',
        macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_16r4c0v(
        this.ref.retainAndReturnPointer(),
        _sel_initWithCGLayer_options_,
        layer,
        options?.ref.pointer ?? ffi.nullptr);
    return CIImage.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithData:
  CIImage? initWithData_(objc.NSData data) {
    objc.checkOsVersionInternal('CIImage.initWithData:',
        macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithData_, data.ref.pointer);
    return _ret.address == 0
        ? null
        : CIImage.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithData:options:
  CIImage? initWithData_options_(objc.NSData data, objc.NSDictionary? options) {
    objc.checkOsVersionInternal('CIImage.initWithData:options:',
        macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_15qeuct(
        this.ref.retainAndReturnPointer(),
        _sel_initWithData_options_,
        data.ref.pointer,
        options?.ref.pointer ?? ffi.nullptr);
    return _ret.address == 0
        ? null
        : CIImage.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithBitmapData:bytesPerRow:size:format:colorSpace:
  CIImage initWithBitmapData_bytesPerRow_size_format_colorSpace_(
      objc.NSData data,
      int bytesPerRow,
      CGSize size,
      int format,
      ffi.Pointer<CGColorSpace> colorSpace) {
    objc.checkOsVersionInternal(
        'CIImage.initWithBitmapData:bytesPerRow:size:format:colorSpace:',
        macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_c5liti(
        this.ref.retainAndReturnPointer(),
        _sel_initWithBitmapData_bytesPerRow_size_format_colorSpace_,
        data.ref.pointer,
        bytesPerRow,
        size,
        format,
        colorSpace);
    return CIImage.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithTexture:size:flipped:colorSpace:
  CIImage initWithTexture_size_flipped_colorSpace_(int name, CGSize size,
      bool flipped, ffi.Pointer<CGColorSpace> colorSpace) {
    objc.checkOsVersionInternal(
        'CIImage.initWithTexture:size:flipped:colorSpace:',
        macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_e34apk(
        this.ref.retainAndReturnPointer(),
        _sel_initWithTexture_size_flipped_colorSpace_,
        name,
        size,
        flipped,
        colorSpace);
    return CIImage.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithTexture:size:flipped:options:
  CIImage initWithTexture_size_flipped_options_(
      int name, CGSize size, bool flipped, objc.NSDictionary? options) {
    objc.checkOsVersionInternal('CIImage.initWithTexture:size:flipped:options:',
        macOS: (false, (10, 9, 0)));
    final _ret = _objc_msgSend_phj3ma(
        this.ref.retainAndReturnPointer(),
        _sel_initWithTexture_size_flipped_options_,
        name,
        size,
        flipped,
        options?.ref.pointer ?? ffi.nullptr);
    return CIImage.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithMTLTexture:options:
  CIImage? initWithMTLTexture_options_(
      MTLTexture texture, objc.NSDictionary? options) {
    objc.checkOsVersionInternal('CIImage.initWithMTLTexture:options:',
        macOS: (false, (10, 11, 0)));
    final _ret = _objc_msgSend_15qeuct(
        this.ref.retainAndReturnPointer(),
        _sel_initWithMTLTexture_options_,
        texture.ref.pointer,
        options?.ref.pointer ?? ffi.nullptr);
    return _ret.address == 0
        ? null
        : CIImage.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithContentsOfURL:
  CIImage? initWithContentsOfURL_(objc.NSURL url) {
    objc.checkOsVersionInternal('CIImage.initWithContentsOfURL:',
        macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithContentsOfURL_, url.ref.pointer);
    return _ret.address == 0
        ? null
        : CIImage.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithContentsOfURL:options:
  CIImage? initWithContentsOfURL_options_(
      objc.NSURL url, objc.NSDictionary? options) {
    objc.checkOsVersionInternal('CIImage.initWithContentsOfURL:options:',
        macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_15qeuct(
        this.ref.retainAndReturnPointer(),
        _sel_initWithContentsOfURL_options_,
        url.ref.pointer,
        options?.ref.pointer ?? ffi.nullptr);
    return _ret.address == 0
        ? null
        : CIImage.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithIOSurface:
  CIImage initWithIOSurface_(ffi.Pointer<__IOSurface> surface) {
    objc.checkOsVersionInternal('CIImage.initWithIOSurface:',
        macOS: (false, (10, 6, 0)));
    final _ret = _objc_msgSend_13p6fbj(
        this.ref.retainAndReturnPointer(), _sel_initWithIOSurface_, surface);
    return CIImage.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithIOSurface:options:
  CIImage initWithIOSurface_options_(
      ffi.Pointer<__IOSurface> surface, objc.NSDictionary? options) {
    objc.checkOsVersionInternal('CIImage.initWithIOSurface:options:',
        macOS: (false, (10, 6, 0)));
    final _ret = _objc_msgSend_14uoevp(
        this.ref.retainAndReturnPointer(),
        _sel_initWithIOSurface_options_,
        surface,
        options?.ref.pointer ?? ffi.nullptr);
    return CIImage.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithIOSurface:plane:format:options:
  CIImage initWithIOSurface_plane_format_options_(
      ffi.Pointer<__IOSurface> surface,
      int plane,
      int format,
      objc.NSDictionary? options) {
    objc.checkOsVersionInternal(
        'CIImage.initWithIOSurface:plane:format:options:',
        macOS: (false, (10, 9, 0)));
    final _ret = _objc_msgSend_z0b586(
        this.ref.retainAndReturnPointer(),
        _sel_initWithIOSurface_plane_format_options_,
        surface,
        plane,
        format,
        options?.ref.pointer ?? ffi.nullptr);
    return CIImage.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithCVImageBuffer:
  CIImage initWithCVImageBuffer_(ffi.Pointer<__CVBuffer> imageBuffer) {
    objc.checkOsVersionInternal('CIImage.initWithCVImageBuffer:',
        macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_1e00d1f(this.ref.retainAndReturnPointer(),
        _sel_initWithCVImageBuffer_, imageBuffer);
    return CIImage.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithCVImageBuffer:options:
  CIImage initWithCVImageBuffer_options_(
      ffi.Pointer<__CVBuffer> imageBuffer, objc.NSDictionary? options) {
    objc.checkOsVersionInternal('CIImage.initWithCVImageBuffer:options:',
        macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_vhfhux(
        this.ref.retainAndReturnPointer(),
        _sel_initWithCVImageBuffer_options_,
        imageBuffer,
        options?.ref.pointer ?? ffi.nullptr);
    return CIImage.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithCVPixelBuffer:
  CIImage initWithCVPixelBuffer_(ffi.Pointer<__CVBuffer> pixelBuffer) {
    objc.checkOsVersionInternal('CIImage.initWithCVPixelBuffer:',
        macOS: (false, (10, 11, 0)));
    final _ret = _objc_msgSend_1e00d1f(this.ref.retainAndReturnPointer(),
        _sel_initWithCVPixelBuffer_, pixelBuffer);
    return CIImage.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithCVPixelBuffer:options:
  CIImage initWithCVPixelBuffer_options_(
      ffi.Pointer<__CVBuffer> pixelBuffer, objc.NSDictionary? options) {
    objc.checkOsVersionInternal('CIImage.initWithCVPixelBuffer:options:',
        macOS: (false, (10, 11, 0)));
    final _ret = _objc_msgSend_vhfhux(
        this.ref.retainAndReturnPointer(),
        _sel_initWithCVPixelBuffer_options_,
        pixelBuffer,
        options?.ref.pointer ?? ffi.nullptr);
    return CIImage.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithColor:
  CIImage initWithColor_(CIColor color) {
    objc.checkOsVersionInternal('CIImage.initWithColor:',
        macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithColor_, color.ref.pointer);
    return CIImage.castFromPointer(_ret, retain: false, release: true);
  }

  /// imageByApplyingTransform:
  CIImage imageByApplyingTransform_(CGAffineTransform matrix) {
    objc.checkOsVersionInternal('CIImage.imageByApplyingTransform:',
        macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_1h5ri4v(
        this.ref.pointer, _sel_imageByApplyingTransform_, matrix);
    return CIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// imageByApplyingTransform:highQualityDownsample:
  CIImage imageByApplyingTransform_highQualityDownsample_(
      CGAffineTransform matrix, bool highQualityDownsample) {
    objc.checkOsVersionInternal(
        'CIImage.imageByApplyingTransform:highQualityDownsample:',
        macOS: (false, (10, 12, 0)));
    final _ret = _objc_msgSend_a19wh7(
        this.ref.pointer,
        _sel_imageByApplyingTransform_highQualityDownsample_,
        matrix,
        highQualityDownsample);
    return CIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// imageByApplyingOrientation:
  CIImage imageByApplyingOrientation_(int orientation) {
    objc.checkOsVersionInternal('CIImage.imageByApplyingOrientation:',
        macOS: (false, (10, 10, 0)));
    final _ret = _objc_msgSend_14hvw5k(
        this.ref.pointer, _sel_imageByApplyingOrientation_, orientation);
    return CIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// imageTransformForOrientation:
  CGAffineTransform imageTransformForOrientation_(int orientation) {
    objc.checkOsVersionInternal('CIImage.imageTransformForOrientation:',
        macOS: (false, (10, 10, 0)));
    final _ptr = pkg_ffi.calloc<CGAffineTransform>();
    objc.useMsgSendVariants
        ? _objc_msgSend_18mng1sStret(_ptr, this.ref.pointer,
            _sel_imageTransformForOrientation_, orientation)
        : _ptr.ref = _objc_msgSend_18mng1s(
            this.ref.pointer, _sel_imageTransformForOrientation_, orientation);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<CGAffineTransform>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<CGAffineTransform>(_finalizable);
  }

  /// imageByApplyingCGOrientation:
  CIImage imageByApplyingCGOrientation_(
      CGImagePropertyOrientation orientation) {
    objc.checkOsVersionInternal('CIImage.imageByApplyingCGOrientation:',
        macOS: (false, (10, 13, 0)));
    final _ret = _objc_msgSend_1e589dh(this.ref.pointer,
        _sel_imageByApplyingCGOrientation_, orientation.value);
    return CIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// imageTransformForCGOrientation:
  CGAffineTransform imageTransformForCGOrientation_(
      CGImagePropertyOrientation orientation) {
    objc.checkOsVersionInternal('CIImage.imageTransformForCGOrientation:',
        macOS: (false, (10, 13, 0)));
    final _ptr = pkg_ffi.calloc<CGAffineTransform>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1w1yiotStret(_ptr, this.ref.pointer,
            _sel_imageTransformForCGOrientation_, orientation.value)
        : _ptr.ref = _objc_msgSend_1w1yiot(this.ref.pointer,
            _sel_imageTransformForCGOrientation_, orientation.value);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<CGAffineTransform>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<CGAffineTransform>(_finalizable);
  }

  /// imageByCompositingOverImage:
  CIImage imageByCompositingOverImage_(CIImage dest) {
    objc.checkOsVersionInternal('CIImage.imageByCompositingOverImage:',
        macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_1sotr3r(
        this.ref.pointer, _sel_imageByCompositingOverImage_, dest.ref.pointer);
    return CIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// imageByCroppingToRect:
  CIImage imageByCroppingToRect_(CGRect rect) {
    objc.checkOsVersionInternal('CIImage.imageByCroppingToRect:',
        macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_15yz4e6(
        this.ref.pointer, _sel_imageByCroppingToRect_, rect);
    return CIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// imageByClampingToExtent
  CIImage imageByClampingToExtent() {
    objc.checkOsVersionInternal('CIImage.imageByClampingToExtent',
        macOS: (false, (10, 10, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_imageByClampingToExtent);
    return CIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// imageByClampingToRect:
  CIImage imageByClampingToRect_(CGRect rect) {
    objc.checkOsVersionInternal('CIImage.imageByClampingToRect:',
        macOS: (false, (10, 12, 0)));
    final _ret = _objc_msgSend_15yz4e6(
        this.ref.pointer, _sel_imageByClampingToRect_, rect);
    return CIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// imageByApplyingFilter:withInputParameters:
  CIImage imageByApplyingFilter_withInputParameters_(
      objc.NSString filterName, objc.NSDictionary? params) {
    objc.checkOsVersionInternal(
        'CIImage.imageByApplyingFilter:withInputParameters:',
        macOS: (false, (10, 10, 0)));
    final _ret = _objc_msgSend_15qeuct(
        this.ref.pointer,
        _sel_imageByApplyingFilter_withInputParameters_,
        filterName.ref.pointer,
        params?.ref.pointer ?? ffi.nullptr);
    return CIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// imageByApplyingFilter:
  CIImage imageByApplyingFilter_(objc.NSString filterName) {
    objc.checkOsVersionInternal('CIImage.imageByApplyingFilter:',
        macOS: (false, (10, 13, 0)));
    final _ret = _objc_msgSend_1sotr3r(
        this.ref.pointer, _sel_imageByApplyingFilter_, filterName.ref.pointer);
    return CIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// imageByColorMatchingColorSpaceToWorkingSpace:
  CIImage? imageByColorMatchingColorSpaceToWorkingSpace_(
      ffi.Pointer<CGColorSpace> colorSpace) {
    objc.checkOsVersionInternal(
        'CIImage.imageByColorMatchingColorSpaceToWorkingSpace:',
        macOS: (false, (10, 12, 0)));
    final _ret = _objc_msgSend_2vhe27(this.ref.pointer,
        _sel_imageByColorMatchingColorSpaceToWorkingSpace_, colorSpace);
    return _ret.address == 0
        ? null
        : CIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// imageByColorMatchingWorkingSpaceToColorSpace:
  CIImage? imageByColorMatchingWorkingSpaceToColorSpace_(
      ffi.Pointer<CGColorSpace> colorSpace) {
    objc.checkOsVersionInternal(
        'CIImage.imageByColorMatchingWorkingSpaceToColorSpace:',
        macOS: (false, (10, 12, 0)));
    final _ret = _objc_msgSend_2vhe27(this.ref.pointer,
        _sel_imageByColorMatchingWorkingSpaceToColorSpace_, colorSpace);
    return _ret.address == 0
        ? null
        : CIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// imageByPremultiplyingAlpha
  CIImage imageByPremultiplyingAlpha() {
    objc.checkOsVersionInternal('CIImage.imageByPremultiplyingAlpha',
        macOS: (false, (10, 12, 0)));
    final _ret = _objc_msgSend_151sglz(
        this.ref.pointer, _sel_imageByPremultiplyingAlpha);
    return CIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// imageByUnpremultiplyingAlpha
  CIImage imageByUnpremultiplyingAlpha() {
    objc.checkOsVersionInternal('CIImage.imageByUnpremultiplyingAlpha',
        macOS: (false, (10, 12, 0)));
    final _ret = _objc_msgSend_151sglz(
        this.ref.pointer, _sel_imageByUnpremultiplyingAlpha);
    return CIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// imageBySettingAlphaOneInExtent:
  CIImage imageBySettingAlphaOneInExtent_(CGRect extent) {
    objc.checkOsVersionInternal('CIImage.imageBySettingAlphaOneInExtent:',
        macOS: (false, (10, 12, 0)));
    final _ret = _objc_msgSend_15yz4e6(
        this.ref.pointer, _sel_imageBySettingAlphaOneInExtent_, extent);
    return CIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// imageByApplyingGaussianBlurWithSigma:
  CIImage imageByApplyingGaussianBlurWithSigma_(double sigma) {
    objc.checkOsVersionInternal('CIImage.imageByApplyingGaussianBlurWithSigma:',
        macOS: (false, (10, 12, 0)));
    final _ret = _objc_msgSend_oa8mke(
        this.ref.pointer, _sel_imageByApplyingGaussianBlurWithSigma_, sigma);
    return CIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// imageBySettingProperties:
  CIImage imageBySettingProperties_(objc.NSDictionary properties) {
    objc.checkOsVersionInternal('CIImage.imageBySettingProperties:',
        macOS: (false, (10, 12, 0)));
    final _ret = _objc_msgSend_1sotr3r(this.ref.pointer,
        _sel_imageBySettingProperties_, properties.ref.pointer);
    return CIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// imageBySamplingLinear
  CIImage imageBySamplingLinear() {
    objc.checkOsVersionInternal('CIImage.imageBySamplingLinear',
        macOS: (false, (10, 13, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_imageBySamplingLinear);
    return CIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// imageBySamplingNearest
  CIImage imageBySamplingNearest() {
    objc.checkOsVersionInternal('CIImage.imageBySamplingNearest',
        macOS: (false, (10, 13, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.pointer, _sel_imageBySamplingNearest);
    return CIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// imageByInsertingIntermediate
  CIImage imageByInsertingIntermediate() {
    objc.checkOsVersionInternal('CIImage.imageByInsertingIntermediate',
        macOS: (false, (10, 14, 0)));
    final _ret = _objc_msgSend_151sglz(
        this.ref.pointer, _sel_imageByInsertingIntermediate);
    return CIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// imageByInsertingIntermediate:
  CIImage imageByInsertingIntermediate_(bool cache) {
    objc.checkOsVersionInternal('CIImage.imageByInsertingIntermediate:',
        macOS: (false, (10, 14, 0)));
    final _ret = _objc_msgSend_1t6aok9(
        this.ref.pointer, _sel_imageByInsertingIntermediate_, cache);
    return CIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// imageByApplyingGainMap:
  CIImage imageByApplyingGainMap_(CIImage gainmap) {
    objc.checkOsVersionInternal('CIImage.imageByApplyingGainMap:',
        macOS: (false, (15, 0, 0)));
    final _ret = _objc_msgSend_1sotr3r(
        this.ref.pointer, _sel_imageByApplyingGainMap_, gainmap.ref.pointer);
    return CIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// imageByApplyingGainMap:headroom:
  CIImage imageByApplyingGainMap_headroom_(CIImage gainmap, double headroom) {
    objc.checkOsVersionInternal('CIImage.imageByApplyingGainMap:headroom:',
        macOS: (false, (15, 0, 0)));
    final _ret = _objc_msgSend_1qw4wvv(this.ref.pointer,
        _sel_imageByApplyingGainMap_headroom_, gainmap.ref.pointer, headroom);
    return CIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// extent
  CGRect get extent {
    objc.checkOsVersionInternal('CIImage.extent', macOS: (false, (10, 4, 0)));
    final _ptr = pkg_ffi.calloc<CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_bu1hbwStret(_ptr, this.ref.pointer, _sel_extent)
        : _ptr.ref = _objc_msgSend_bu1hbw(this.ref.pointer, _sel_extent);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<CGRect>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<CGRect>(_finalizable);
  }

  /// isOpaque
  bool get opaque {
    objc.checkOsVersionInternal('CIImage.isOpaque', macOS: (false, (10, 4, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isOpaque);
  }

  /// properties
  objc.NSDictionary get properties {
    objc.checkOsVersionInternal('CIImage.properties',
        macOS: (false, (10, 8, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_properties);
    return objc.NSDictionary.castFromPointer(_ret, retain: true, release: true);
  }

  /// definition
  CIFilterShape get definition {
    objc.checkOsVersionInternal('CIImage.definition',
        macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_definition);
    return CIFilterShape.castFromPointer(_ret, retain: true, release: true);
  }

  /// url
  objc.NSURL? get url {
    objc.checkOsVersionInternal('CIImage.url', macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_url);
    return _ret.address == 0
        ? null
        : objc.NSURL.castFromPointer(_ret, retain: true, release: true);
  }

  /// colorSpace
  ffi.Pointer<CGColorSpace> get colorSpace {
    objc.checkOsVersionInternal('CIImage.colorSpace',
        macOS: (false, (10, 4, 0)));
    return _objc_msgSend_19mkw1n(this.ref.pointer, _sel_colorSpace);
  }

  /// contentHeadroom
  double get contentHeadroom {
    objc.checkOsVersionInternal('CIImage.contentHeadroom',
        macOS: (false, (15, 0, 0)));
    return objc.useMsgSendVariants
        ? _objc_msgSend_2cgrxlFpret(this.ref.pointer, _sel_contentHeadroom)
        : _objc_msgSend_2cgrxl(this.ref.pointer, _sel_contentHeadroom);
  }

  /// pixelBuffer
  ffi.Pointer<__CVBuffer> get pixelBuffer {
    objc.checkOsVersionInternal('CIImage.pixelBuffer',
        macOS: (false, (10, 12, 0)));
    return _objc_msgSend_19zp75z(this.ref.pointer, _sel_pixelBuffer);
  }

  /// CGImage
  ffi.Pointer<CGImage> get CGImage$1 {
    objc.checkOsVersionInternal('CIImage.CGImage', macOS: (false, (10, 12, 0)));
    return _objc_msgSend_y1izi1(this.ref.pointer, _sel_CGImage);
  }

  /// metalTexture
  MTLTexture? get metalTexture {
    objc.checkOsVersionInternal('CIImage.metalTexture',
        macOS: (false, (15, 0, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_metalTexture);
    return _ret.address == 0
        ? null
        : MTLTexture.castFromPointer(_ret, retain: true, release: true);
  }

  /// regionOfInterestForImage:inRect:
  CGRect regionOfInterestForImage_inRect_(CIImage image, CGRect rect) {
    objc.checkOsVersionInternal('CIImage.regionOfInterestForImage:inRect:',
        macOS: (false, (10, 11, 0)));
    final _ptr = pkg_ffi.calloc<CGRect>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1yifw1jStret(_ptr, this.ref.pointer,
            _sel_regionOfInterestForImage_inRect_, image.ref.pointer, rect)
        : _ptr.ref = _objc_msgSend_1yifw1j(this.ref.pointer,
            _sel_regionOfInterestForImage_inRect_, image.ref.pointer, rect);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<CGRect>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<CGRect>(_finalizable);
  }

  /// init
  CIImage init() {
    objc.checkOsVersionInternal('CIImage.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return CIImage.castFromPointer(_ret, retain: false, release: true);
  }

  /// new
  static CIImage new$() {
    final _ret = _objc_msgSend_151sglz(_class_CIImage, _sel_new);
    return CIImage.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static CIImage allocWithZone_(ffi.Pointer<objc.NSZone> zone) {
    final _ret =
        _objc_msgSend_1cwp428(_class_CIImage, _sel_allocWithZone_, zone);
    return CIImage.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static CIImage alloc() {
    final _ret = _objc_msgSend_151sglz(_class_CIImage, _sel_alloc);
    return CIImage.castFromPointer(_ret, retain: false, release: true);
  }

  /// self
  CIImage self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return CIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// retain
  CIImage retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return CIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// autorelease
  CIImage autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return CIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(_class_CIImage, _sel_supportsSecureCoding);
  }

  /// encodeWithCoder:
  void encodeWithCoder_(objc.NSCoder coder) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_encodeWithCoder_, coder.ref.pointer);
  }

  /// initWithCoder:
  CIImage? initWithCoder_(objc.NSCoder coder) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithCoder_, coder.ref.pointer);
    return _ret.address == 0
        ? null
        : CIImage.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithDepthData:options:
  CIImage? initWithDepthData_options_(
      AVDepthData data, objc.NSDictionary? options) {
    objc.checkOsVersionInternal('CIImage.initWithDepthData:options:',
        macOS: (false, (10, 13, 0)));
    final _ret = _objc_msgSend_15qeuct(
        this.ref.retainAndReturnPointer(),
        _sel_initWithDepthData_options_,
        data.ref.pointer,
        options?.ref.pointer ?? ffi.nullptr);
    return _ret.address == 0
        ? null
        : CIImage.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithDepthData:
  CIImage? initWithDepthData_(AVDepthData data) {
    objc.checkOsVersionInternal('CIImage.initWithDepthData:',
        macOS: (false, (10, 13, 0)));
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithDepthData_, data.ref.pointer);
    return _ret.address == 0
        ? null
        : CIImage.castFromPointer(_ret, retain: false, release: true);
  }

  /// imageWithDepthData:options:
  static CIImage? imageWithDepthData_options_(
      AVDepthData data, objc.NSDictionary? options) {
    objc.checkOsVersionInternal('CIImage.imageWithDepthData:options:',
        macOS: (false, (10, 13, 0)));
    final _ret = _objc_msgSend_15qeuct(
        _class_CIImage,
        _sel_imageWithDepthData_options_,
        data.ref.pointer,
        options?.ref.pointer ?? ffi.nullptr);
    return _ret.address == 0
        ? null
        : CIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// imageWithDepthData:
  static CIImage? imageWithDepthData_(AVDepthData data) {
    objc.checkOsVersionInternal('CIImage.imageWithDepthData:',
        macOS: (false, (10, 13, 0)));
    final _ret = _objc_msgSend_1sotr3r(
        _class_CIImage, _sel_imageWithDepthData_, data.ref.pointer);
    return _ret.address == 0
        ? null
        : CIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// initWithPortaitEffectsMatte:options:
  CIImage? initWithPortaitEffectsMatte_options_(
      AVPortraitEffectsMatte matte, objc.NSDictionary? options) {
    objc.checkOsVersionInternal('CIImage.initWithPortaitEffectsMatte:options:',
        macOS: (false, (10, 14, 0)));
    final _ret = _objc_msgSend_15qeuct(
        this.ref.retainAndReturnPointer(),
        _sel_initWithPortaitEffectsMatte_options_,
        matte.ref.pointer,
        options?.ref.pointer ?? ffi.nullptr);
    return _ret.address == 0
        ? null
        : CIImage.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithPortaitEffectsMatte:
  CIImage? initWithPortaitEffectsMatte_(AVPortraitEffectsMatte matte) {
    objc.checkOsVersionInternal('CIImage.initWithPortaitEffectsMatte:',
        macOS: (false, (10, 13, 0)));
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithPortaitEffectsMatte_, matte.ref.pointer);
    return _ret.address == 0
        ? null
        : CIImage.castFromPointer(_ret, retain: false, release: true);
  }

  /// imageWithPortaitEffectsMatte:options:
  static CIImage? imageWithPortaitEffectsMatte_options_(
      AVPortraitEffectsMatte matte, objc.NSDictionary? options) {
    objc.checkOsVersionInternal('CIImage.imageWithPortaitEffectsMatte:options:',
        macOS: (false, (10, 14, 0)));
    final _ret = _objc_msgSend_15qeuct(
        _class_CIImage,
        _sel_imageWithPortaitEffectsMatte_options_,
        matte.ref.pointer,
        options?.ref.pointer ?? ffi.nullptr);
    return _ret.address == 0
        ? null
        : CIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// imageWithPortaitEffectsMatte:
  static CIImage? imageWithPortaitEffectsMatte_(AVPortraitEffectsMatte matte) {
    objc.checkOsVersionInternal('CIImage.imageWithPortaitEffectsMatte:',
        macOS: (false, (10, 14, 0)));
    final _ret = _objc_msgSend_1sotr3r(
        _class_CIImage, _sel_imageWithPortaitEffectsMatte_, matte.ref.pointer);
    return _ret.address == 0
        ? null
        : CIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// initWithSemanticSegmentationMatte:options:
  CIImage? initWithSemanticSegmentationMatte_options_(
      AVSemanticSegmentationMatte matte, objc.NSDictionary? options) {
    objc.checkOsVersionInternal(
        'CIImage.initWithSemanticSegmentationMatte:options:',
        macOS: (false, (10, 15, 0)));
    final _ret = _objc_msgSend_15qeuct(
        this.ref.retainAndReturnPointer(),
        _sel_initWithSemanticSegmentationMatte_options_,
        matte.ref.pointer,
        options?.ref.pointer ?? ffi.nullptr);
    return _ret.address == 0
        ? null
        : CIImage.castFromPointer(_ret, retain: false, release: true);
  }

  /// initWithSemanticSegmentationMatte:
  CIImage? initWithSemanticSegmentationMatte_(
      AVSemanticSegmentationMatte matte) {
    objc.checkOsVersionInternal('CIImage.initWithSemanticSegmentationMatte:',
        macOS: (false, (10, 15, 0)));
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithSemanticSegmentationMatte_, matte.ref.pointer);
    return _ret.address == 0
        ? null
        : CIImage.castFromPointer(_ret, retain: false, release: true);
  }

  /// imageWithSemanticSegmentationMatte:options:
  static CIImage? imageWithSemanticSegmentationMatte_options_(
      AVSemanticSegmentationMatte matte, objc.NSDictionary? options) {
    objc.checkOsVersionInternal(
        'CIImage.imageWithSemanticSegmentationMatte:options:',
        macOS: (false, (10, 15, 0)));
    final _ret = _objc_msgSend_15qeuct(
        _class_CIImage,
        _sel_imageWithSemanticSegmentationMatte_options_,
        matte.ref.pointer,
        options?.ref.pointer ?? ffi.nullptr);
    return _ret.address == 0
        ? null
        : CIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// imageWithSemanticSegmentationMatte:
  static CIImage? imageWithSemanticSegmentationMatte_(
      AVSemanticSegmentationMatte matte) {
    objc.checkOsVersionInternal('CIImage.imageWithSemanticSegmentationMatte:',
        macOS: (false, (10, 15, 0)));
    final _ret = _objc_msgSend_1sotr3r(_class_CIImage,
        _sel_imageWithSemanticSegmentationMatte_, matte.ref.pointer);
    return _ret.address == 0
        ? null
        : CIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// initWithImageProvider:size::format:colorSpace:options:
  CIImage initWithImageProvider_size__format_colorSpace_options_(
      objc.ObjCObjectBase p,
      int width,
      int height,
      int f,
      ffi.Pointer<CGColorSpace> cs,
      objc.NSDictionary? options) {
    objc.checkOsVersionInternal(
        'CIImage.initWithImageProvider:size::format:colorSpace:options:',
        macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_ieoh10(
        this.ref.retainAndReturnPointer(),
        _sel_initWithImageProvider_size__format_colorSpace_options_,
        p.ref.pointer,
        width,
        height,
        f,
        cs,
        options?.ref.pointer ?? ffi.nullptr);
    return CIImage.castFromPointer(_ret, retain: false, release: true);
  }

  /// Returns a new instance of CIImage constructed with the default `new` method.
  factory CIImage() => new$();
}

late final _class_CIContext = objc.getClass("CIContext");
late final _sel_createCGImage_fromRect_ =
    objc.registerName("createCGImage:fromRect:");
final _objc_msgSend_m37ggi = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<CGImage> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                CGRect)>>()
    .asFunction<
        ffi.Pointer<CGImage> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            CGRect)>();
late final _sel_createCGImage_fromRect_format_colorSpace_ =
    objc.registerName("createCGImage:fromRect:format:colorSpace:");
final _objc_msgSend_4uoj6v = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<CGImage> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                CGRect,
                ffi.Int,
                ffi.Pointer<CGColorSpace>)>>()
    .asFunction<
        ffi.Pointer<CGImage> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            CGRect,
            int,
            ffi.Pointer<CGColorSpace>)>();
late final _sel_createCGImage_fromRect_format_colorSpace_deferred_ =
    objc.registerName("createCGImage:fromRect:format:colorSpace:deferred:");
final _objc_msgSend_hgjbib = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<CGImage> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                CGRect,
                ffi.Int,
                ffi.Pointer<CGColorSpace>,
                ffi.Bool)>>()
    .asFunction<
        ffi.Pointer<CGImage> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            CGRect,
            int,
            ffi.Pointer<CGColorSpace>,
            bool)>();

/// createCGImage
extension createCGImage on CIContext {
  /// createCGImage:fromRect:
  ffi.Pointer<CGImage> createCGImage_fromRect_(CIImage image, CGRect fromRect) {
    objc.checkOsVersionInternal('CIContext.createCGImage:fromRect:',
        macOS: (false, (10, 4, 0)));
    return _objc_msgSend_m37ggi(this.ref.pointer, _sel_createCGImage_fromRect_,
        image.ref.pointer, fromRect);
  }

  /// createCGImage:fromRect:format:colorSpace:
  ffi.Pointer<CGImage> createCGImage_fromRect_format_colorSpace_(CIImage image,
      CGRect fromRect, int format, ffi.Pointer<CGColorSpace> colorSpace) {
    objc.checkOsVersionInternal(
        'CIContext.createCGImage:fromRect:format:colorSpace:',
        macOS: (false, (10, 4, 0)));
    return _objc_msgSend_4uoj6v(
        this.ref.pointer,
        _sel_createCGImage_fromRect_format_colorSpace_,
        image.ref.pointer,
        fromRect,
        format,
        colorSpace);
  }

  /// createCGImage:fromRect:format:colorSpace:deferred:
  ffi.Pointer<CGImage> createCGImage_fromRect_format_colorSpace_deferred_(
      CIImage image,
      CGRect fromRect,
      int format,
      ffi.Pointer<CGColorSpace> colorSpace,
      bool deferred) {
    objc.checkOsVersionInternal(
        'CIContext.createCGImage:fromRect:format:colorSpace:deferred:',
        macOS: (false, (10, 12, 0)));
    return _objc_msgSend_hgjbib(
        this.ref.pointer,
        _sel_createCGImage_fromRect_format_colorSpace_deferred_,
        image.ref.pointer,
        fromRect,
        format,
        colorSpace,
        deferred);
  }
}

late final _sel_offlineGPUCount = objc.registerName("offlineGPUCount");
final _objc_msgSend_3pyzne = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.UnsignedInt Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_contextForOfflineGPUAtIndex_ =
    objc.registerName("contextForOfflineGPUAtIndex:");
final _objc_msgSend_degb40 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedInt)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_contextForOfflineGPUAtIndex_colorSpace_options_sharedContext_ =
    objc.registerName(
        "contextForOfflineGPUAtIndex:colorSpace:options:sharedContext:");
final _objc_msgSend_1t2vn5a = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.UnsignedInt,
                ffi.Pointer<CGColorSpace>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<_CGLContextObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            int,
            ffi.Pointer<CGColorSpace>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<_CGLContextObject>)>();

/// OfflineGPUSupport
extension OfflineGPUSupport on CIContext {
  /// offlineGPUCount
  static int offlineGPUCount() {
    objc.checkOsVersionInternal('CIContext.offlineGPUCount',
        macOS: (false, (10, 10, 0)));
    return _objc_msgSend_3pyzne(_class_CIContext, _sel_offlineGPUCount);
  }

  /// contextForOfflineGPUAtIndex:
  static CIContext? contextForOfflineGPUAtIndex_(int index) {
    objc.checkOsVersionInternal('CIContext.contextForOfflineGPUAtIndex:',
        macOS: (false, (10, 10, 0)));
    final _ret = _objc_msgSend_degb40(
        _class_CIContext, _sel_contextForOfflineGPUAtIndex_, index);
    return _ret.address == 0
        ? null
        : CIContext.castFromPointer(_ret, retain: true, release: true);
  }

  /// contextForOfflineGPUAtIndex:colorSpace:options:sharedContext:
  static CIContext?
      contextForOfflineGPUAtIndex_colorSpace_options_sharedContext_(
          int index,
          ffi.Pointer<CGColorSpace> colorSpace,
          objc.NSDictionary? options,
          ffi.Pointer<_CGLContextObject> sharedContext) {
    objc.checkOsVersionInternal(
        'CIContext.contextForOfflineGPUAtIndex:colorSpace:options:sharedContext:',
        macOS: (false, (10, 10, 0)));
    final _ret = _objc_msgSend_1t2vn5a(
        _class_CIContext,
        _sel_contextForOfflineGPUAtIndex_colorSpace_options_sharedContext_,
        index,
        colorSpace,
        options?.ref.pointer ?? ffi.nullptr,
        sharedContext);
    return _ret.address == 0
        ? null
        : CIContext.castFromPointer(_ret, retain: true, release: true);
  }
}

late final _sel_TIFFRepresentationOfImage_format_colorSpace_options_ =
    objc.registerName("TIFFRepresentationOfImage:format:colorSpace:options:");
final _objc_msgSend_49p598 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Int,
                ffi.Pointer<CGColorSpace>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            int,
            ffi.Pointer<CGColorSpace>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_JPEGRepresentationOfImage_colorSpace_options_ =
    objc.registerName("JPEGRepresentationOfImage:colorSpace:options:");
final _objc_msgSend_1r5wy13 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<CGColorSpace>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<CGColorSpace>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_HEIFRepresentationOfImage_format_colorSpace_options_ =
    objc.registerName("HEIFRepresentationOfImage:format:colorSpace:options:");
late final _sel_HEIF10RepresentationOfImage_colorSpace_options_error_ =
    objc.registerName("HEIF10RepresentationOfImage:colorSpace:options:error:");
final _objc_msgSend_8xr26u = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<CGColorSpace>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<CGColorSpace>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>();
late final _sel_PNGRepresentationOfImage_format_colorSpace_options_ =
    objc.registerName("PNGRepresentationOfImage:format:colorSpace:options:");
late final _sel_OpenEXRRepresentationOfImage_options_error_ =
    objc.registerName("OpenEXRRepresentationOfImage:options:error:");
final _objc_msgSend_1pnyuds = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>();
late final _sel_writeTIFFRepresentationOfImage_toURL_format_colorSpace_options_error_ =
    objc.registerName(
        "writeTIFFRepresentationOfImage:toURL:format:colorSpace:options:error:");
final _objc_msgSend_fnvfr5 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Int,
                ffi.Pointer<CGColorSpace>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>>()
    .asFunction<
        bool Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            int,
            ffi.Pointer<CGColorSpace>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>();
late final _sel_writePNGRepresentationOfImage_toURL_format_colorSpace_options_error_ =
    objc.registerName(
        "writePNGRepresentationOfImage:toURL:format:colorSpace:options:error:");
late final _sel_writeJPEGRepresentationOfImage_toURL_colorSpace_options_error_ =
    objc.registerName(
        "writeJPEGRepresentationOfImage:toURL:colorSpace:options:error:");
final _objc_msgSend_mmzaia = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<CGColorSpace>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>>()
    .asFunction<
        bool Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<CGColorSpace>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>();
late final _sel_writeHEIFRepresentationOfImage_toURL_format_colorSpace_options_error_ =
    objc.registerName(
        "writeHEIFRepresentationOfImage:toURL:format:colorSpace:options:error:");
late final _sel_writeHEIF10RepresentationOfImage_toURL_colorSpace_options_error_ =
    objc.registerName(
        "writeHEIF10RepresentationOfImage:toURL:colorSpace:options:error:");
late final _sel_writeOpenEXRRepresentationOfImage_toURL_options_error_ =
    objc.registerName("writeOpenEXRRepresentationOfImage:toURL:options:error:");
final _objc_msgSend_1oeotrw = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>>()
    .asFunction<
        bool Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>();

/// ImageRepresentation
extension ImageRepresentation on CIContext {
  /// TIFFRepresentationOfImage:format:colorSpace:options:
  objc.NSData? TIFFRepresentationOfImage_format_colorSpace_options_(
      CIImage image,
      int format,
      ffi.Pointer<CGColorSpace> colorSpace,
      objc.NSDictionary options) {
    objc.checkOsVersionInternal(
        'CIContext.TIFFRepresentationOfImage:format:colorSpace:options:',
        macOS: (false, (10, 12, 0)));
    final _ret = _objc_msgSend_49p598(
        this.ref.pointer,
        _sel_TIFFRepresentationOfImage_format_colorSpace_options_,
        image.ref.pointer,
        format,
        colorSpace,
        options.ref.pointer);
    return _ret.address == 0
        ? null
        : objc.NSData.castFromPointer(_ret, retain: true, release: true);
  }

  /// JPEGRepresentationOfImage:colorSpace:options:
  objc.NSData? JPEGRepresentationOfImage_colorSpace_options_(CIImage image,
      ffi.Pointer<CGColorSpace> colorSpace, objc.NSDictionary options) {
    objc.checkOsVersionInternal(
        'CIContext.JPEGRepresentationOfImage:colorSpace:options:',
        macOS: (false, (10, 12, 0)));
    final _ret = _objc_msgSend_1r5wy13(
        this.ref.pointer,
        _sel_JPEGRepresentationOfImage_colorSpace_options_,
        image.ref.pointer,
        colorSpace,
        options.ref.pointer);
    return _ret.address == 0
        ? null
        : objc.NSData.castFromPointer(_ret, retain: true, release: true);
  }

  /// HEIFRepresentationOfImage:format:colorSpace:options:
  objc.NSData? HEIFRepresentationOfImage_format_colorSpace_options_(
      CIImage image,
      int format,
      ffi.Pointer<CGColorSpace> colorSpace,
      objc.NSDictionary options) {
    objc.checkOsVersionInternal(
        'CIContext.HEIFRepresentationOfImage:format:colorSpace:options:',
        macOS: (false, (10, 13, 4)));
    final _ret = _objc_msgSend_49p598(
        this.ref.pointer,
        _sel_HEIFRepresentationOfImage_format_colorSpace_options_,
        image.ref.pointer,
        format,
        colorSpace,
        options.ref.pointer);
    return _ret.address == 0
        ? null
        : objc.NSData.castFromPointer(_ret, retain: true, release: true);
  }

  /// HEIF10RepresentationOfImage:colorSpace:options:error:
  objc.NSData? HEIF10RepresentationOfImage_colorSpace_options_error_(
      CIImage image,
      ffi.Pointer<CGColorSpace> colorSpace,
      objc.NSDictionary options,
      ffi.Pointer<ffi.Pointer<objc.ObjCObject>> errorPtr) {
    objc.checkOsVersionInternal(
        'CIContext.HEIF10RepresentationOfImage:colorSpace:options:error:',
        macOS: (false, (12, 0, 0)));
    final _ret = _objc_msgSend_8xr26u(
        this.ref.pointer,
        _sel_HEIF10RepresentationOfImage_colorSpace_options_error_,
        image.ref.pointer,
        colorSpace,
        options.ref.pointer,
        errorPtr);
    return _ret.address == 0
        ? null
        : objc.NSData.castFromPointer(_ret, retain: true, release: true);
  }

  /// PNGRepresentationOfImage:format:colorSpace:options:
  objc.NSData? PNGRepresentationOfImage_format_colorSpace_options_(
      CIImage image,
      int format,
      ffi.Pointer<CGColorSpace> colorSpace,
      objc.NSDictionary options) {
    objc.checkOsVersionInternal(
        'CIContext.PNGRepresentationOfImage:format:colorSpace:options:',
        macOS: (false, (10, 13, 0)));
    final _ret = _objc_msgSend_49p598(
        this.ref.pointer,
        _sel_PNGRepresentationOfImage_format_colorSpace_options_,
        image.ref.pointer,
        format,
        colorSpace,
        options.ref.pointer);
    return _ret.address == 0
        ? null
        : objc.NSData.castFromPointer(_ret, retain: true, release: true);
  }

  /// OpenEXRRepresentationOfImage:options:error:
  objc.NSData? OpenEXRRepresentationOfImage_options_error_(
      CIImage image,
      objc.NSDictionary options,
      ffi.Pointer<ffi.Pointer<objc.ObjCObject>> errorPtr) {
    objc.checkOsVersionInternal(
        'CIContext.OpenEXRRepresentationOfImage:options:error:',
        macOS: (false, (14, 0, 0)));
    final _ret = _objc_msgSend_1pnyuds(
        this.ref.pointer,
        _sel_OpenEXRRepresentationOfImage_options_error_,
        image.ref.pointer,
        options.ref.pointer,
        errorPtr);
    return _ret.address == 0
        ? null
        : objc.NSData.castFromPointer(_ret, retain: true, release: true);
  }

  /// writeTIFFRepresentationOfImage:toURL:format:colorSpace:options:error:
  bool writeTIFFRepresentationOfImage_toURL_format_colorSpace_options_error_(
      CIImage image,
      objc.NSURL url,
      int format,
      ffi.Pointer<CGColorSpace> colorSpace,
      objc.NSDictionary options,
      ffi.Pointer<ffi.Pointer<objc.ObjCObject>> errorPtr) {
    objc.checkOsVersionInternal(
        'CIContext.writeTIFFRepresentationOfImage:toURL:format:colorSpace:options:error:',
        macOS: (false, (10, 12, 0)));
    return _objc_msgSend_fnvfr5(
        this.ref.pointer,
        _sel_writeTIFFRepresentationOfImage_toURL_format_colorSpace_options_error_,
        image.ref.pointer,
        url.ref.pointer,
        format,
        colorSpace,
        options.ref.pointer,
        errorPtr);
  }

  /// writePNGRepresentationOfImage:toURL:format:colorSpace:options:error:
  bool writePNGRepresentationOfImage_toURL_format_colorSpace_options_error_(
      CIImage image,
      objc.NSURL url,
      int format,
      ffi.Pointer<CGColorSpace> colorSpace,
      objc.NSDictionary options,
      ffi.Pointer<ffi.Pointer<objc.ObjCObject>> errorPtr) {
    objc.checkOsVersionInternal(
        'CIContext.writePNGRepresentationOfImage:toURL:format:colorSpace:options:error:',
        macOS: (false, (10, 13, 0)));
    return _objc_msgSend_fnvfr5(
        this.ref.pointer,
        _sel_writePNGRepresentationOfImage_toURL_format_colorSpace_options_error_,
        image.ref.pointer,
        url.ref.pointer,
        format,
        colorSpace,
        options.ref.pointer,
        errorPtr);
  }

  /// writeJPEGRepresentationOfImage:toURL:colorSpace:options:error:
  bool writeJPEGRepresentationOfImage_toURL_colorSpace_options_error_(
      CIImage image,
      objc.NSURL url,
      ffi.Pointer<CGColorSpace> colorSpace,
      objc.NSDictionary options,
      ffi.Pointer<ffi.Pointer<objc.ObjCObject>> errorPtr) {
    objc.checkOsVersionInternal(
        'CIContext.writeJPEGRepresentationOfImage:toURL:colorSpace:options:error:',
        macOS: (false, (10, 12, 0)));
    return _objc_msgSend_mmzaia(
        this.ref.pointer,
        _sel_writeJPEGRepresentationOfImage_toURL_colorSpace_options_error_,
        image.ref.pointer,
        url.ref.pointer,
        colorSpace,
        options.ref.pointer,
        errorPtr);
  }

  /// writeHEIFRepresentationOfImage:toURL:format:colorSpace:options:error:
  bool writeHEIFRepresentationOfImage_toURL_format_colorSpace_options_error_(
      CIImage image,
      objc.NSURL url,
      int format,
      ffi.Pointer<CGColorSpace> colorSpace,
      objc.NSDictionary options,
      ffi.Pointer<ffi.Pointer<objc.ObjCObject>> errorPtr) {
    objc.checkOsVersionInternal(
        'CIContext.writeHEIFRepresentationOfImage:toURL:format:colorSpace:options:error:',
        macOS: (false, (10, 13, 4)));
    return _objc_msgSend_fnvfr5(
        this.ref.pointer,
        _sel_writeHEIFRepresentationOfImage_toURL_format_colorSpace_options_error_,
        image.ref.pointer,
        url.ref.pointer,
        format,
        colorSpace,
        options.ref.pointer,
        errorPtr);
  }

  /// writeHEIF10RepresentationOfImage:toURL:colorSpace:options:error:
  bool writeHEIF10RepresentationOfImage_toURL_colorSpace_options_error_(
      CIImage image,
      objc.NSURL url,
      ffi.Pointer<CGColorSpace> colorSpace,
      objc.NSDictionary options,
      ffi.Pointer<ffi.Pointer<objc.ObjCObject>> errorPtr) {
    objc.checkOsVersionInternal(
        'CIContext.writeHEIF10RepresentationOfImage:toURL:colorSpace:options:error:',
        macOS: (false, (12, 0, 0)));
    return _objc_msgSend_mmzaia(
        this.ref.pointer,
        _sel_writeHEIF10RepresentationOfImage_toURL_colorSpace_options_error_,
        image.ref.pointer,
        url.ref.pointer,
        colorSpace,
        options.ref.pointer,
        errorPtr);
  }

  /// writeOpenEXRRepresentationOfImage:toURL:options:error:
  bool writeOpenEXRRepresentationOfImage_toURL_options_error_(
      CIImage image,
      objc.NSURL url,
      objc.NSDictionary options,
      ffi.Pointer<ffi.Pointer<objc.ObjCObject>> errorPtr) {
    objc.checkOsVersionInternal(
        'CIContext.writeOpenEXRRepresentationOfImage:toURL:options:error:',
        macOS: (false, (14, 0, 0)));
    return _objc_msgSend_1oeotrw(
        this.ref.pointer,
        _sel_writeOpenEXRRepresentationOfImage_toURL_options_error_,
        image.ref.pointer,
        url.ref.pointer,
        options.ref.pointer,
        errorPtr);
  }
}

late final _class_CIFilter = objc.getClass("CIFilter");
late final _sel_filterWithName_ = objc.registerName("filterWithName:");
late final _sel_filterWithName_keysAndValues_ =
    objc.registerName("filterWithName:keysAndValues:");
late final _sel_filterWithName_withInputParameters_ =
    objc.registerName("filterWithName:withInputParameters:");
late final _sel_filterNamesInCategory_ =
    objc.registerName("filterNamesInCategory:");
late final _sel_filterNamesInCategories_ =
    objc.registerName("filterNamesInCategories:");
late final _protocol_CIFilterConstructor =
    objc.getProtocol("CIFilterConstructor");
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_CIFilter_ffiVoid_NSString_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1) =>
        block.ref.target
            .cast<
                ffi.NativeFunction<
                    ffi.Pointer<objc.ObjCObject> Function(
                        ffi.Pointer<ffi.Void> arg0,
                        ffi.Pointer<objc.ObjCObject> arg1)>>()
            .asFunction<
                ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>)>()(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_CIFilter_ffiVoid_NSString_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_CIFilter_ffiVoid_NSString_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_CIFilter_ffiVoid_NSString_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObject> arg1) =>
        (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>))(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_CIFilter_ffiVoid_NSString_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>,
                    ffi.Pointer<ffi.Void>,
                    ffi.Pointer<objc.ObjCObject>)>(
            _ObjCBlock_CIFilter_ffiVoid_NSString_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<CIFilter? Function(ffi.Pointer<ffi.Void>, objc.NSString)>`.
abstract final class ObjCBlock_CIFilter_ffiVoid_NSString {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
      CIFilter? Function(ffi.Pointer<ffi.Void>, objc.NSString)> castFromPointer(
          ffi.Pointer<objc.ObjCBlockImpl> pointer,
          {bool retain = false,
          bool release = false}) =>
      objc.ObjCBlock<CIFilter? Function(ffi.Pointer<ffi.Void>, objc.NSString)>(
          pointer,
          retain: retain,
          release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<CIFilter? Function(ffi.Pointer<ffi.Void>, objc.NSString)>
      fromFunctionPointer(
              ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.Pointer<objc.ObjCObject> Function(
                              ffi.Pointer<ffi.Void> arg0,
                              ffi.Pointer<objc.ObjCObject> arg1)>>
                  ptr) =>
          objc.ObjCBlock<CIFilter? Function(ffi.Pointer<ffi.Void>, objc.NSString)>(
              objc.newPointerBlock(_ObjCBlock_CIFilter_ffiVoid_NSString_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<CIFilter? Function(ffi.Pointer<ffi.Void>, objc.NSString)>
      fromFunction(CIFilter? Function(ffi.Pointer<ffi.Void>, objc.NSString) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<CIFilter? Function(ffi.Pointer<ffi.Void>, objc.NSString)>(
              objc.newClosureBlock(
                  _ObjCBlock_CIFilter_ffiVoid_NSString_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1) =>
                      fn(arg0, objc.NSString.castFromPointer(arg1, retain: true, release: true))
                          ?.ref
                          .retainAndAutorelease() ??
                      ffi.nullptr,
                  keepIsolateAlive),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<CIFilter? Function(ffi.Pointer<ffi.Void>, objc.NSString)>`.
extension ObjCBlock_CIFilter_ffiVoid_NSString_CallExtension on objc
    .ObjCBlock<CIFilter? Function(ffi.Pointer<ffi.Void>, objc.NSString)> {
  CIFilter? call(ffi.Pointer<ffi.Void> arg0, objc.NSString arg1) => ref
              .pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Pointer<objc.ObjCObject> Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0,
                          ffi.Pointer<objc.ObjCObject> arg1)>>()
              .asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()
              (ref.pointer, arg0, arg1.ref.pointer)
              .address ==
          0
      ? null
      : CIFilter.castFromPointer(
          ref.pointer.ref.invoke
              .cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObject> arg1)>>()
              .asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>()(ref.pointer, arg0, arg1.ref.pointer),
          retain: true,
          release: true);
}

/// CIFilterConstructor
interface class CIFilterConstructor extends objc.ObjCProtocolBase {
  CIFilterConstructor._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [CIFilterConstructor] that points to the same underlying object as [other].
  CIFilterConstructor.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [CIFilterConstructor] that wraps the given raw object pointer.
  CIFilterConstructor.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [CIFilterConstructor].
  static bool conformsTo(objc.ObjCObjectBase obj) {
    return _objc_msgSend_e3qsqz(obj.ref.pointer, _sel_conformsToProtocol_,
        _protocol_CIFilterConstructor);
  }

  /// Returns the [objc.Protocol] object for this protocol.
  static objc.Protocol get $protocol =>
      objc.Protocol.castFromPointer(_protocol_CIFilterConstructor.cast());

  /// Builds an object that implements the CIFilterConstructor protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static CIFilterConstructor implement(
      {required CIFilter? Function(objc.NSString) filterWithName_,
      bool $keepIsolateAlive = true}) {
    final builder = objc.ObjCProtocolBuilder(debugName: 'CIFilterConstructor');
    CIFilterConstructor.filterWithName_.implement(builder, filterWithName_);
    builder.addProtocol($protocol);
    return CIFilterConstructor.castFrom(
        builder.build(keepIsolateAlive: $keepIsolateAlive));
  }

  /// Adds the implementation of the CIFilterConstructor protocol to an existing
  /// [objc.ObjCProtocolBuilder].
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilder(objc.ObjCProtocolBuilder builder,
      {required CIFilter? Function(objc.NSString) filterWithName_,
      bool $keepIsolateAlive = true}) {
    CIFilterConstructor.filterWithName_.implement(builder, filterWithName_);
    builder.addProtocol($protocol);
  }

  /// filterWithName:
  static final filterWithName_ =
      objc.ObjCProtocolMethod<CIFilter? Function(objc.NSString)>(
    _protocol_CIFilterConstructor,
    _sel_filterWithName_,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    instancetype Function(ffi.Pointer<objc.ObjCObject>,
                        ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObject>)>>(
            _CoreImageBindings_protocolTrampoline_xr62hr)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_CIFilterConstructor,
      _sel_filterWithName_,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (CIFilter? Function(objc.NSString) func) =>
        ObjCBlock_CIFilter_ffiVoid_NSString.fromFunction(
            (ffi.Pointer<ffi.Void> _, objc.NSString arg1) => func(arg1)),
  );
}

late final _sel_registerFilterName_constructor_classAttributes_ =
    objc.registerName("registerFilterName:constructor:classAttributes:");
final _objc_msgSend_r8gdi7 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_localizedNameForFilterName_ =
    objc.registerName("localizedNameForFilterName:");
late final _sel_localizedNameForCategory_ =
    objc.registerName("localizedNameForCategory:");
late final _sel_localizedDescriptionForFilterName_ =
    objc.registerName("localizedDescriptionForFilterName:");
late final _sel_localizedReferenceDocumentationForFilterName_ =
    objc.registerName("localizedReferenceDocumentationForFilterName:");

/// CIFilterRegistry
extension CIFilterRegistry on CIFilter {
  /// filterWithName:
  static CIFilter? filterWithName_(objc.NSString name) {
    objc.checkOsVersionInternal('CIFilter.filterWithName:',
        macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_1sotr3r(
        _class_CIFilter, _sel_filterWithName_, name.ref.pointer);
    return _ret.address == 0
        ? null
        : CIFilter.castFromPointer(_ret, retain: true, release: true);
  }

  /// filterWithName:keysAndValues:
  static CIFilter? filterWithName_keysAndValues_(
      objc.NSString name, objc.ObjCObjectBase key0) {
    final _ret = _objc_msgSend_15qeuct(_class_CIFilter,
        _sel_filterWithName_keysAndValues_, name.ref.pointer, key0.ref.pointer);
    return _ret.address == 0
        ? null
        : CIFilter.castFromPointer(_ret, retain: true, release: true);
  }

  /// filterWithName:withInputParameters:
  static CIFilter? filterWithName_withInputParameters_(
      objc.NSString name, objc.NSDictionary? params) {
    objc.checkOsVersionInternal('CIFilter.filterWithName:withInputParameters:',
        macOS: (false, (10, 10, 0)));
    final _ret = _objc_msgSend_15qeuct(
        _class_CIFilter,
        _sel_filterWithName_withInputParameters_,
        name.ref.pointer,
        params?.ref.pointer ?? ffi.nullptr);
    return _ret.address == 0
        ? null
        : CIFilter.castFromPointer(_ret, retain: true, release: true);
  }

  /// filterNamesInCategory:
  static objc.NSArray filterNamesInCategory_(objc.NSString? category) {
    objc.checkOsVersionInternal('CIFilter.filterNamesInCategory:',
        macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_1sotr3r(_class_CIFilter,
        _sel_filterNamesInCategory_, category?.ref.pointer ?? ffi.nullptr);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// filterNamesInCategories:
  static objc.NSArray filterNamesInCategories_(objc.NSArray? categories) {
    objc.checkOsVersionInternal('CIFilter.filterNamesInCategories:',
        macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_1sotr3r(_class_CIFilter,
        _sel_filterNamesInCategories_, categories?.ref.pointer ?? ffi.nullptr);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// registerFilterName:constructor:classAttributes:
  static void registerFilterName_constructor_classAttributes_(
      objc.NSString name,
      CIFilterConstructor anObject,
      objc.NSDictionary attributes) {
    objc.checkOsVersionInternal(
        'CIFilter.registerFilterName:constructor:classAttributes:',
        macOS: (false, (10, 4, 0)));
    _objc_msgSend_r8gdi7(
        _class_CIFilter,
        _sel_registerFilterName_constructor_classAttributes_,
        name.ref.pointer,
        anObject.ref.pointer,
        attributes.ref.pointer);
  }

  /// localizedNameForFilterName:
  static objc.NSString? localizedNameForFilterName_(objc.NSString filterName) {
    objc.checkOsVersionInternal('CIFilter.localizedNameForFilterName:',
        macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_1sotr3r(_class_CIFilter,
        _sel_localizedNameForFilterName_, filterName.ref.pointer);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// localizedNameForCategory:
  static objc.NSString localizedNameForCategory_(objc.NSString category) {
    objc.checkOsVersionInternal('CIFilter.localizedNameForCategory:',
        macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_1sotr3r(
        _class_CIFilter, _sel_localizedNameForCategory_, category.ref.pointer);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// localizedDescriptionForFilterName:
  static objc.NSString? localizedDescriptionForFilterName_(
      objc.NSString filterName) {
    objc.checkOsVersionInternal('CIFilter.localizedDescriptionForFilterName:',
        macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_1sotr3r(_class_CIFilter,
        _sel_localizedDescriptionForFilterName_, filterName.ref.pointer);
    return _ret.address == 0
        ? null
        : objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// localizedReferenceDocumentationForFilterName:
  static objc.NSURL? localizedReferenceDocumentationForFilterName_(
      objc.NSString filterName) {
    objc.checkOsVersionInternal(
        'CIFilter.localizedReferenceDocumentationForFilterName:',
        macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_1sotr3r(
        _class_CIFilter,
        _sel_localizedReferenceDocumentationForFilterName_,
        filterName.ref.pointer);
    return _ret.address == 0
        ? null
        : objc.NSURL.castFromPointer(_ret, retain: true, release: true);
  }
}

late final _sel_serializedXMPFromFilters_inputImageExtent_ =
    objc.registerName("serializedXMPFromFilters:inputImageExtent:");
final _objc_msgSend_fx4id0 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                CGRect)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            CGRect)>();
late final _sel_filterArrayFromSerializedXMP_inputImageExtent_error_ =
    objc.registerName("filterArrayFromSerializedXMP:inputImageExtent:error:");
final _objc_msgSend_yfgi31 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                CGRect,
                ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            CGRect,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>();

/// CIFilterXMPSerialization
extension CIFilterXMPSerialization on CIFilter {
  /// serializedXMPFromFilters:inputImageExtent:
  static objc.NSData? serializedXMPFromFilters_inputImageExtent_(
      objc.NSArray filters, CGRect extent) {
    objc.checkOsVersionInternal(
        'CIFilter.serializedXMPFromFilters:inputImageExtent:',
        macOS: (false, (10, 9, 0)));
    final _ret = _objc_msgSend_fx4id0(
        _class_CIFilter,
        _sel_serializedXMPFromFilters_inputImageExtent_,
        filters.ref.pointer,
        extent);
    return _ret.address == 0
        ? null
        : objc.NSData.castFromPointer(_ret, retain: true, release: true);
  }

  /// filterArrayFromSerializedXMP:inputImageExtent:error:
  static objc.NSArray filterArrayFromSerializedXMP_inputImageExtent_error_(
      objc.NSData xmpData,
      CGRect extent,
      ffi.Pointer<ffi.Pointer<objc.ObjCObject>> outError) {
    objc.checkOsVersionInternal(
        'CIFilter.filterArrayFromSerializedXMP:inputImageExtent:error:',
        macOS: (false, (10, 9, 0)));
    final _ret = _objc_msgSend_yfgi31(
        _class_CIFilter,
        _sel_filterArrayFromSerializedXMP_inputImageExtent_error_,
        xmpData.ref.pointer,
        extent,
        outError);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }
}

late final _sel_filterWithImageURL_options_ =
    objc.registerName("filterWithImageURL:options:");
late final _sel_filterWithImageData_options_ =
    objc.registerName("filterWithImageData:options:");
late final _sel_filterWithCVPixelBuffer_properties_options_ =
    objc.registerName("filterWithCVPixelBuffer:properties:options:");
final _objc_msgSend_4irga7 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<__CVBuffer>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<__CVBuffer>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_supportedRawCameraModels =
    objc.registerName("supportedRawCameraModels");

/// CIRAWFilter
extension CIRAWFilter on CIFilter {
  /// filterWithImageURL:options:
  static CIFilter filterWithImageURL_options_(
      objc.NSURL url, objc.NSDictionary options) {
    objc.checkOsVersionInternal('CIFilter.filterWithImageURL:options:',
        iOS: (false, (10, 0, 0)), macOS: (false, (10, 5, 0)));
    final _ret = _objc_msgSend_15qeuct(_class_CIFilter,
        _sel_filterWithImageURL_options_, url.ref.pointer, options.ref.pointer);
    return CIFilter.castFromPointer(_ret, retain: true, release: true);
  }

  /// filterWithImageData:options:
  static CIFilter filterWithImageData_options_(
      objc.NSData data, objc.NSDictionary options) {
    objc.checkOsVersionInternal('CIFilter.filterWithImageData:options:',
        iOS: (false, (10, 0, 0)), macOS: (false, (10, 5, 0)));
    final _ret = _objc_msgSend_15qeuct(
        _class_CIFilter,
        _sel_filterWithImageData_options_,
        data.ref.pointer,
        options.ref.pointer);
    return CIFilter.castFromPointer(_ret, retain: true, release: true);
  }

  /// filterWithCVPixelBuffer:properties:options:
  static CIFilter filterWithCVPixelBuffer_properties_options_(
      ffi.Pointer<__CVBuffer> pixelBuffer,
      objc.NSDictionary properties,
      objc.NSDictionary options) {
    objc.checkOsVersionInternal(
        'CIFilter.filterWithCVPixelBuffer:properties:options:',
        iOS: (false, (10, 0, 0)),
        macOS: (false, (10, 12, 0)));
    final _ret = _objc_msgSend_4irga7(
        _class_CIFilter,
        _sel_filterWithCVPixelBuffer_properties_options_,
        pixelBuffer,
        properties.ref.pointer,
        options.ref.pointer);
    return CIFilter.castFromPointer(_ret, retain: true, release: true);
  }

  /// supportedRawCameraModels
  static objc.NSArray supportedRawCameraModels() {
    objc.checkOsVersionInternal('CIFilter.supportedRawCameraModels',
        iOS: (false, (13, 0, 0)), macOS: (false, (10, 15, 0)));
    final _ret =
        _objc_msgSend_151sglz(_class_CIFilter, _sel_supportedRawCameraModels);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }
}

late final _sel_outputImage = objc.registerName("outputImage");
late final _sel_name = objc.registerName("name");
late final _sel_setName_ = objc.registerName("setName:");
late final _sel_isEnabled = objc.registerName("isEnabled");
late final _sel_setEnabled_ = objc.registerName("setEnabled:");
final _objc_msgSend_1s56lr9 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Bool)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, bool)>();
late final _sel_inputKeys = objc.registerName("inputKeys");
late final _sel_outputKeys = objc.registerName("outputKeys");
late final _sel_setDefaults = objc.registerName("setDefaults");
final _objc_msgSend_1pl9qdv = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_attributes = objc.registerName("attributes");
late final _class_CIKernel = objc.getClass("CIKernel");
late final _sel_kernelsWithString_ = objc.registerName("kernelsWithString:");
late final _sel_kernelsWithMetalString_error_ =
    objc.registerName("kernelsWithMetalString:error:");
final _objc_msgSend_1lhpu4m = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>();
late final _sel_kernelWithString_ = objc.registerName("kernelWithString:");
late final _sel_kernelWithFunctionName_fromMetalLibraryData_error_ =
    objc.registerName("kernelWithFunctionName:fromMetalLibraryData:error:");
late final _sel_kernelWithFunctionName_fromMetalLibraryData_outputPixelFormat_error_ =
    objc.registerName(
        "kernelWithFunctionName:fromMetalLibraryData:outputPixelFormat:error:");
final _objc_msgSend_1ja6awd = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Int,
                ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            int,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>();
late final _sel_kernelNamesFromMetalLibraryData_ =
    objc.registerName("kernelNamesFromMetalLibraryData:");
late final _sel_setROISelector_ = objc.registerName("setROISelector:");
final _objc_msgSend_1d9e4oe = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCSelector>)>();
CGRect _ObjCBlock_CGRect_ffiInt_CGRect_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, int arg0, CGRect arg1) =>
    block.ref.target
        .cast<ffi.NativeFunction<CGRect Function(ffi.Int arg0, CGRect arg1)>>()
        .asFunction<CGRect Function(int, CGRect)>()(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_CGRect_ffiInt_CGRect_fnPtrCallable =
    ffi.Pointer.fromFunction<
            CGRect Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Int,
                CGRect)>(_ObjCBlock_CGRect_ffiInt_CGRect_fnPtrTrampoline)
        .cast();
CGRect _ObjCBlock_CGRect_ffiInt_CGRect_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, int arg0, CGRect arg1) =>
    (objc.getBlockClosure(block) as CGRect Function(int, CGRect))(arg0, arg1);
ffi.Pointer<ffi.Void> _ObjCBlock_CGRect_ffiInt_CGRect_closureCallable =
    ffi.Pointer.fromFunction<
            CGRect Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Int,
                CGRect)>(_ObjCBlock_CGRect_ffiInt_CGRect_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<CGRect Function(ffi.Int, CGRect)>`.
abstract final class ObjCBlock_CGRect_ffiInt_CGRect {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<CGRect Function(ffi.Int, CGRect)> castFromPointer(
          ffi.Pointer<objc.ObjCBlockImpl> pointer,
          {bool retain = false,
          bool release = false}) =>
      objc.ObjCBlock<CGRect Function(ffi.Int, CGRect)>(pointer,
          retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<CGRect Function(ffi.Int, CGRect)> fromFunctionPointer(
          ffi.Pointer<
                  ffi
                  .NativeFunction<CGRect Function(ffi.Int arg0, CGRect arg1)>>
              ptr) =>
      objc.ObjCBlock<CGRect Function(ffi.Int, CGRect)>(
          objc.newPointerBlock(
              _ObjCBlock_CGRect_ffiInt_CGRect_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<CGRect Function(ffi.Int, CGRect)> fromFunction(
          CGRect Function(int, CGRect) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<CGRect Function(ffi.Int, CGRect)>(
          objc.newClosureBlock(_ObjCBlock_CGRect_ffiInt_CGRect_closureCallable,
              (int arg0, CGRect arg1) => fn(arg0, arg1), keepIsolateAlive),
          retain: false,
          release: true);
}

/// Call operator for `objc.ObjCBlock<CGRect Function(ffi.Int, CGRect)>`.
extension ObjCBlock_CGRect_ffiInt_CGRect_CallExtension
    on objc.ObjCBlock<CGRect Function(ffi.Int, CGRect)> {
  CGRect call(int arg0, CGRect arg1) => ref.pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  CGRect Function(ffi.Pointer<objc.ObjCBlockImpl> block,
                      ffi.Int arg0, CGRect arg1)>>()
          .asFunction<
              CGRect Function(ffi.Pointer<objc.ObjCBlockImpl>, int, CGRect)>()(
      ref.pointer, arg0, arg1);
}

late final _sel_applyWithExtent_roiCallback_arguments_ =
    objc.registerName("applyWithExtent:roiCallback:arguments:");
final _objc_msgSend_1sptzeb = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                CGRect,
                ffi.Pointer<objc.ObjCBlockImpl>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            CGRect,
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObject>)>();

/// CIKernel
class CIKernel extends objc.NSObject {
  CIKernel._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('CIKernel', macOS: (false, (10, 4, 0)));
  }

  /// Constructs a [CIKernel] that points to the same underlying object as [other].
  CIKernel.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [CIKernel] that wraps the given raw object pointer.
  CIKernel.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [CIKernel].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_CIKernel);
  }

  /// kernelsWithString:
  static objc.NSArray? kernelsWithString_(objc.NSString string) {
    objc.checkOsVersionInternal('CIKernel.kernelsWithString:',
        macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_1sotr3r(
        _class_CIKernel, _sel_kernelsWithString_, string.ref.pointer);
    return _ret.address == 0
        ? null
        : objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// kernelsWithMetalString:error:
  static objc.NSArray? kernelsWithMetalString_error_(
      objc.NSString source, ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error) {
    objc.checkOsVersionInternal('CIKernel.kernelsWithMetalString:error:',
        macOS: (false, (12, 0, 0)));
    final _ret = _objc_msgSend_1lhpu4m(_class_CIKernel,
        _sel_kernelsWithMetalString_error_, source.ref.pointer, error);
    return _ret.address == 0
        ? null
        : objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// kernelWithString:
  static CIKernel? kernelWithString_(objc.NSString string) {
    objc.checkOsVersionInternal('CIKernel.kernelWithString:',
        macOS: (false, (10, 10, 0)));
    final _ret = _objc_msgSend_1sotr3r(
        _class_CIKernel, _sel_kernelWithString_, string.ref.pointer);
    return _ret.address == 0
        ? null
        : CIKernel.castFromPointer(_ret, retain: true, release: true);
  }

  /// kernelWithFunctionName:fromMetalLibraryData:error:
  static CIKernel? kernelWithFunctionName_fromMetalLibraryData_error_(
      objc.NSString name,
      objc.NSData data,
      ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error) {
    objc.checkOsVersionInternal(
        'CIKernel.kernelWithFunctionName:fromMetalLibraryData:error:',
        macOS: (false, (10, 13, 0)));
    final _ret = _objc_msgSend_1pnyuds(
        _class_CIKernel,
        _sel_kernelWithFunctionName_fromMetalLibraryData_error_,
        name.ref.pointer,
        data.ref.pointer,
        error);
    return _ret.address == 0
        ? null
        : CIKernel.castFromPointer(_ret, retain: true, release: true);
  }

  /// kernelWithFunctionName:fromMetalLibraryData:outputPixelFormat:error:
  static CIKernel?
      kernelWithFunctionName_fromMetalLibraryData_outputPixelFormat_error_(
          objc.NSString name,
          objc.NSData data,
          int format,
          ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error) {
    objc.checkOsVersionInternal(
        'CIKernel.kernelWithFunctionName:fromMetalLibraryData:outputPixelFormat:error:',
        macOS: (false, (10, 13, 0)));
    final _ret = _objc_msgSend_1ja6awd(
        _class_CIKernel,
        _sel_kernelWithFunctionName_fromMetalLibraryData_outputPixelFormat_error_,
        name.ref.pointer,
        data.ref.pointer,
        format,
        error);
    return _ret.address == 0
        ? null
        : CIKernel.castFromPointer(_ret, retain: true, release: true);
  }

  /// kernelNamesFromMetalLibraryData:
  static objc.NSArray kernelNamesFromMetalLibraryData_(objc.NSData data) {
    objc.checkOsVersionInternal('CIKernel.kernelNamesFromMetalLibraryData:',
        macOS: (false, (11, 0, 0)));
    final _ret = _objc_msgSend_1sotr3r(_class_CIKernel,
        _sel_kernelNamesFromMetalLibraryData_, data.ref.pointer);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// name
  objc.NSString get name {
    objc.checkOsVersionInternal('CIKernel.name', macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_name);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// setROISelector:
  void setROISelector_(ffi.Pointer<objc.ObjCSelector> method) {
    objc.checkOsVersionInternal('CIKernel.setROISelector:',
        macOS: (false, (10, 4, 0)));
    _objc_msgSend_1d9e4oe(this.ref.pointer, _sel_setROISelector_, method);
  }

  /// applyWithExtent:roiCallback:arguments:
  CIImage? applyWithExtent_roiCallback_arguments_(
      CGRect extent,
      objc.ObjCBlock<CGRect Function(ffi.Int, CGRect)> callback,
      objc.NSArray? args) {
    objc.checkOsVersionInternal(
        'CIKernel.applyWithExtent:roiCallback:arguments:',
        macOS: (false, (10, 11, 0)));
    final _ret = _objc_msgSend_1sptzeb(
        this.ref.pointer,
        _sel_applyWithExtent_roiCallback_arguments_,
        extent,
        callback.ref.pointer,
        args?.ref.pointer ?? ffi.nullptr);
    return _ret.address == 0
        ? null
        : CIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// init
  CIKernel init() {
    objc.checkOsVersionInternal('CIKernel.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return CIKernel.castFromPointer(_ret, retain: false, release: true);
  }

  /// new
  static CIKernel new$() {
    final _ret = _objc_msgSend_151sglz(_class_CIKernel, _sel_new);
    return CIKernel.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static CIKernel allocWithZone_(ffi.Pointer<objc.NSZone> zone) {
    final _ret =
        _objc_msgSend_1cwp428(_class_CIKernel, _sel_allocWithZone_, zone);
    return CIKernel.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static CIKernel alloc() {
    final _ret = _objc_msgSend_151sglz(_class_CIKernel, _sel_alloc);
    return CIKernel.castFromPointer(_ret, retain: false, release: true);
  }

  /// self
  CIKernel self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return CIKernel.castFromPointer(_ret, retain: true, release: true);
  }

  /// retain
  CIKernel retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return CIKernel.castFromPointer(_ret, retain: true, release: true);
  }

  /// autorelease
  CIKernel autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return CIKernel.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a new instance of CIKernel constructed with the default `new` method.
  factory CIKernel() => new$();
}

late final _sel_apply_arguments_options_ =
    objc.registerName("apply:arguments:options:");
final _objc_msgSend_11spmsz = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_apply_ = objc.registerName("apply:");

/// CIFilter
class CIFilter extends objc.NSObject
    implements objc.NSSecureCoding, objc.NSCopying {
  CIFilter._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('CIFilter', macOS: (false, (10, 4, 0)));
  }

  /// Constructs a [CIFilter] that points to the same underlying object as [other].
  CIFilter.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [CIFilter] that wraps the given raw object pointer.
  CIFilter.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [CIFilter].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_CIFilter);
  }

  /// outputImage
  CIImage? get outputImage {
    objc.checkOsVersionInternal('CIFilter.outputImage',
        macOS: (false, (10, 10, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_outputImage);
    return _ret.address == 0
        ? null
        : CIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// name
  objc.NSString get name {
    objc.checkOsVersionInternal('CIFilter.name', macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_name);
    return objc.NSString.castFromPointer(_ret, retain: true, release: true);
  }

  /// setName:
  set name(objc.NSString value) {
    objc.checkOsVersionInternal('CIFilter.setName:',
        macOS: (false, (10, 4, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setName_, value.ref.pointer);
  }

  /// isEnabled
  bool get enabled {
    objc.checkOsVersionInternal('CIFilter.isEnabled',
        macOS: (false, (10, 5, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isEnabled);
  }

  /// setEnabled:
  set enabled(bool value) {
    objc.checkOsVersionInternal('CIFilter.setEnabled:',
        macOS: (false, (10, 5, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setEnabled_, value);
  }

  /// inputKeys
  objc.NSArray get inputKeys {
    objc.checkOsVersionInternal('CIFilter.inputKeys',
        macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_inputKeys);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// outputKeys
  objc.NSArray get outputKeys {
    objc.checkOsVersionInternal('CIFilter.outputKeys',
        macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_outputKeys);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// setDefaults
  void setDefaults() {
    objc.checkOsVersionInternal('CIFilter.setDefaults',
        macOS: (false, (10, 4, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_setDefaults);
  }

  /// attributes
  objc.NSDictionary get attributes {
    objc.checkOsVersionInternal('CIFilter.attributes',
        macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_attributes);
    return objc.NSDictionary.castFromPointer(_ret, retain: true, release: true);
  }

  /// apply:arguments:options:
  CIImage? apply_arguments_options_(
      CIKernel k, objc.NSArray? args, objc.NSDictionary? dict) {
    objc.checkOsVersionInternal('CIFilter.apply:arguments:options:',
        macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_11spmsz(
        this.ref.pointer,
        _sel_apply_arguments_options_,
        k.ref.pointer,
        args?.ref.pointer ?? ffi.nullptr,
        dict?.ref.pointer ?? ffi.nullptr);
    return _ret.address == 0
        ? null
        : CIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// apply:
  CIImage? apply_(CIKernel k) {
    objc.checkOsVersionInternal('CIFilter.apply:', macOS: (false, (10, 4, 0)));
    final _ret =
        _objc_msgSend_1sotr3r(this.ref.pointer, _sel_apply_, k.ref.pointer);
    return _ret.address == 0
        ? null
        : CIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// init
  CIFilter init() {
    objc.checkOsVersionInternal('CIFilter.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return CIFilter.castFromPointer(_ret, retain: false, release: true);
  }

  /// new
  static CIFilter new$() {
    final _ret = _objc_msgSend_151sglz(_class_CIFilter, _sel_new);
    return CIFilter.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static CIFilter allocWithZone_(ffi.Pointer<objc.NSZone> zone) {
    final _ret =
        _objc_msgSend_1cwp428(_class_CIFilter, _sel_allocWithZone_, zone);
    return CIFilter.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static CIFilter alloc() {
    final _ret = _objc_msgSend_151sglz(_class_CIFilter, _sel_alloc);
    return CIFilter.castFromPointer(_ret, retain: false, release: true);
  }

  /// self
  CIFilter self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return CIFilter.castFromPointer(_ret, retain: true, release: true);
  }

  /// retain
  CIFilter retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return CIFilter.castFromPointer(_ret, retain: true, release: true);
  }

  /// autorelease
  CIFilter autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return CIFilter.castFromPointer(_ret, retain: true, release: true);
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(_class_CIFilter, _sel_supportsSecureCoding);
  }

  /// encodeWithCoder:
  void encodeWithCoder_(objc.NSCoder coder) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_encodeWithCoder_, coder.ref.pointer);
  }

  /// initWithCoder:
  CIFilter? initWithCoder_(objc.NSCoder coder) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithCoder_, coder.ref.pointer);
    return _ret.address == 0
        ? null
        : CIFilter.castFromPointer(_ret, retain: false, release: true);
  }

  /// Returns a new instance of CIFilter constructed with the default `new` method.
  factory CIFilter() => new$();
}

late final _sel_depthBlurEffectFilterForImageURL_options_ =
    objc.registerName("depthBlurEffectFilterForImageURL:options:");
late final _sel_depthBlurEffectFilterForImageData_options_ =
    objc.registerName("depthBlurEffectFilterForImageData:options:");
late final _sel_depthBlurEffectFilterForImage_disparityImage_portraitEffectsMatte_orientation_options_ =
    objc.registerName(
        "depthBlurEffectFilterForImage:disparityImage:portraitEffectsMatte:orientation:options:");
final _objc_msgSend_1vm1ts1 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Uint32,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            int,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_depthBlurEffectFilterForImage_disparityImage_portraitEffectsMatte_hairSemanticSegmentation_orientation_options_ =
    objc.registerName(
        "depthBlurEffectFilterForImage:disparityImage:portraitEffectsMatte:hairSemanticSegmentation:orientation:options:");
final _objc_msgSend_1ws0uoz = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Uint32,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            int,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_depthBlurEffectFilterForImage_disparityImage_portraitEffectsMatte_hairSemanticSegmentation_glassesMatte_gainMap_orientation_options_ =
    objc.registerName(
        "depthBlurEffectFilterForImage:disparityImage:portraitEffectsMatte:hairSemanticSegmentation:glassesMatte:gainMap:orientation:options:");
final _objc_msgSend_jp2mbb = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Uint32,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            int,
            ffi.Pointer<objc.ObjCObject>)>();

/// CIDepthBlurEffect
extension CIDepthBlurEffect on CIContext {
  /// depthBlurEffectFilterForImageURL:options:
  CIFilter? depthBlurEffectFilterForImageURL_options_(
      objc.NSURL url, objc.NSDictionary? options) {
    objc.checkOsVersionInternal(
        'CIContext.depthBlurEffectFilterForImageURL:options:',
        macOS: (false, (10, 14, 0)));
    final _ret = _objc_msgSend_15qeuct(
        this.ref.pointer,
        _sel_depthBlurEffectFilterForImageURL_options_,
        url.ref.pointer,
        options?.ref.pointer ?? ffi.nullptr);
    return _ret.address == 0
        ? null
        : CIFilter.castFromPointer(_ret, retain: true, release: true);
  }

  /// depthBlurEffectFilterForImageData:options:
  CIFilter? depthBlurEffectFilterForImageData_options_(
      objc.NSData data, objc.NSDictionary? options) {
    objc.checkOsVersionInternal(
        'CIContext.depthBlurEffectFilterForImageData:options:',
        macOS: (false, (10, 14, 0)));
    final _ret = _objc_msgSend_15qeuct(
        this.ref.pointer,
        _sel_depthBlurEffectFilterForImageData_options_,
        data.ref.pointer,
        options?.ref.pointer ?? ffi.nullptr);
    return _ret.address == 0
        ? null
        : CIFilter.castFromPointer(_ret, retain: true, release: true);
  }

  /// depthBlurEffectFilterForImage:disparityImage:portraitEffectsMatte:orientation:options:
  CIFilter?
      depthBlurEffectFilterForImage_disparityImage_portraitEffectsMatte_orientation_options_(
          CIImage image,
          CIImage disparityImage,
          CIImage? portraitEffectsMatte,
          CGImagePropertyOrientation orientation,
          objc.NSDictionary? options) {
    objc.checkOsVersionInternal(
        'CIContext.depthBlurEffectFilterForImage:disparityImage:portraitEffectsMatte:orientation:options:',
        macOS: (false, (10, 14, 0)));
    final _ret = _objc_msgSend_1vm1ts1(
        this.ref.pointer,
        _sel_depthBlurEffectFilterForImage_disparityImage_portraitEffectsMatte_orientation_options_,
        image.ref.pointer,
        disparityImage.ref.pointer,
        portraitEffectsMatte?.ref.pointer ?? ffi.nullptr,
        orientation.value,
        options?.ref.pointer ?? ffi.nullptr);
    return _ret.address == 0
        ? null
        : CIFilter.castFromPointer(_ret, retain: true, release: true);
  }

  /// depthBlurEffectFilterForImage:disparityImage:portraitEffectsMatte:hairSemanticSegmentation:orientation:options:
  CIFilter?
      depthBlurEffectFilterForImage_disparityImage_portraitEffectsMatte_hairSemanticSegmentation_orientation_options_(
          CIImage image,
          CIImage disparityImage,
          CIImage? portraitEffectsMatte,
          CIImage? hairSemanticSegmentation,
          CGImagePropertyOrientation orientation,
          objc.NSDictionary? options) {
    objc.checkOsVersionInternal(
        'CIContext.depthBlurEffectFilterForImage:disparityImage:portraitEffectsMatte:hairSemanticSegmentation:orientation:options:',
        macOS: (false, (10, 15, 0)));
    final _ret = _objc_msgSend_1ws0uoz(
        this.ref.pointer,
        _sel_depthBlurEffectFilterForImage_disparityImage_portraitEffectsMatte_hairSemanticSegmentation_orientation_options_,
        image.ref.pointer,
        disparityImage.ref.pointer,
        portraitEffectsMatte?.ref.pointer ?? ffi.nullptr,
        hairSemanticSegmentation?.ref.pointer ?? ffi.nullptr,
        orientation.value,
        options?.ref.pointer ?? ffi.nullptr);
    return _ret.address == 0
        ? null
        : CIFilter.castFromPointer(_ret, retain: true, release: true);
  }

  /// depthBlurEffectFilterForImage:disparityImage:portraitEffectsMatte:hairSemanticSegmentation:glassesMatte:gainMap:orientation:options:
  CIFilter?
      depthBlurEffectFilterForImage_disparityImage_portraitEffectsMatte_hairSemanticSegmentation_glassesMatte_gainMap_orientation_options_(
          CIImage image,
          CIImage disparityImage,
          CIImage? portraitEffectsMatte,
          CIImage? hairSemanticSegmentation,
          CIImage? glassesMatte,
          CIImage? gainMap,
          CGImagePropertyOrientation orientation,
          objc.NSDictionary? options) {
    objc.checkOsVersionInternal(
        'CIContext.depthBlurEffectFilterForImage:disparityImage:portraitEffectsMatte:hairSemanticSegmentation:glassesMatte:gainMap:orientation:options:',
        macOS: (false, (11, 0, 0)));
    final _ret = _objc_msgSend_jp2mbb(
        this.ref.pointer,
        _sel_depthBlurEffectFilterForImage_disparityImage_portraitEffectsMatte_hairSemanticSegmentation_glassesMatte_gainMap_orientation_options_,
        image.ref.pointer,
        disparityImage.ref.pointer,
        portraitEffectsMatte?.ref.pointer ?? ffi.nullptr,
        hairSemanticSegmentation?.ref.pointer ?? ffi.nullptr,
        glassesMatte?.ref.pointer ?? ffi.nullptr,
        gainMap?.ref.pointer ?? ffi.nullptr,
        orientation.value,
        options?.ref.pointer ?? ffi.nullptr);
    return _ret.address == 0
        ? null
        : CIFilter.castFromPointer(_ret, retain: true, release: true);
  }
}

late final _class_CIRenderTask = objc.getClass("CIRenderTask");
late final _class_CIRenderInfo = objc.getClass("CIRenderInfo");
late final _sel_kernelExecutionTime = objc.registerName("kernelExecutionTime");
late final _sel_kernelCompileTime = objc.registerName("kernelCompileTime");
late final _sel_passCount = objc.registerName("passCount");
final _objc_msgSend_1hz7y9r = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Long Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_pixelsProcessed = objc.registerName("pixelsProcessed");

/// CIRenderInfo
class CIRenderInfo extends objc.NSObject {
  CIRenderInfo._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('CIRenderInfo', macOS: (false, (10, 13, 0)));
  }

  /// Constructs a [CIRenderInfo] that points to the same underlying object as [other].
  CIRenderInfo.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [CIRenderInfo] that wraps the given raw object pointer.
  CIRenderInfo.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [CIRenderInfo].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_CIRenderInfo);
  }

  /// kernelExecutionTime
  double get kernelExecutionTime {
    objc.checkOsVersionInternal('CIRenderInfo.kernelExecutionTime',
        macOS: (false, (10, 13, 0)));
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_kernelExecutionTime)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_kernelExecutionTime);
  }

  /// kernelCompileTime
  double get kernelCompileTime {
    objc.checkOsVersionInternal('CIRenderInfo.kernelCompileTime',
        macOS: (false, (14, 0, 0)));
    return objc.useMsgSendVariants
        ? _objc_msgSend_1ukqyt8Fpret(this.ref.pointer, _sel_kernelCompileTime)
        : _objc_msgSend_1ukqyt8(this.ref.pointer, _sel_kernelCompileTime);
  }

  /// passCount
  int get passCount {
    objc.checkOsVersionInternal('CIRenderInfo.passCount',
        macOS: (false, (10, 13, 0)));
    return _objc_msgSend_1hz7y9r(this.ref.pointer, _sel_passCount);
  }

  /// pixelsProcessed
  int get pixelsProcessed {
    objc.checkOsVersionInternal('CIRenderInfo.pixelsProcessed',
        macOS: (false, (10, 13, 0)));
    return _objc_msgSend_1hz7y9r(this.ref.pointer, _sel_pixelsProcessed);
  }

  /// init
  CIRenderInfo init() {
    objc.checkOsVersionInternal('CIRenderInfo.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return CIRenderInfo.castFromPointer(_ret, retain: false, release: true);
  }

  /// new
  static CIRenderInfo new$() {
    final _ret = _objc_msgSend_151sglz(_class_CIRenderInfo, _sel_new);
    return CIRenderInfo.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static CIRenderInfo allocWithZone_(ffi.Pointer<objc.NSZone> zone) {
    final _ret =
        _objc_msgSend_1cwp428(_class_CIRenderInfo, _sel_allocWithZone_, zone);
    return CIRenderInfo.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static CIRenderInfo alloc() {
    final _ret = _objc_msgSend_151sglz(_class_CIRenderInfo, _sel_alloc);
    return CIRenderInfo.castFromPointer(_ret, retain: false, release: true);
  }

  /// self
  CIRenderInfo self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return CIRenderInfo.castFromPointer(_ret, retain: true, release: true);
  }

  /// retain
  CIRenderInfo retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return CIRenderInfo.castFromPointer(_ret, retain: true, release: true);
  }

  /// autorelease
  CIRenderInfo autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return CIRenderInfo.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a new instance of CIRenderInfo constructed with the default `new` method.
  factory CIRenderInfo() => new$();
}

late final _sel_waitUntilCompletedAndReturnError_ =
    objc.registerName("waitUntilCompletedAndReturnError:");
final _objc_msgSend_1w05pgk = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>();

/// CIRenderTask
class CIRenderTask extends objc.NSObject {
  CIRenderTask._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('CIRenderTask', macOS: (false, (10, 13, 0)));
  }

  /// Constructs a [CIRenderTask] that points to the same underlying object as [other].
  CIRenderTask.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [CIRenderTask] that wraps the given raw object pointer.
  CIRenderTask.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [CIRenderTask].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_CIRenderTask);
  }

  /// waitUntilCompletedAndReturnError:
  CIRenderInfo? waitUntilCompletedAndReturnError_(
      ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error) {
    objc.checkOsVersionInternal(
        'CIRenderTask.waitUntilCompletedAndReturnError:',
        macOS: (false, (10, 13, 0)));
    final _ret = _objc_msgSend_1w05pgk(
        this.ref.pointer, _sel_waitUntilCompletedAndReturnError_, error);
    return _ret.address == 0
        ? null
        : CIRenderInfo.castFromPointer(_ret, retain: true, release: true);
  }

  /// init
  CIRenderTask init() {
    objc.checkOsVersionInternal('CIRenderTask.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return CIRenderTask.castFromPointer(_ret, retain: false, release: true);
  }

  /// new
  static CIRenderTask new$() {
    final _ret = _objc_msgSend_151sglz(_class_CIRenderTask, _sel_new);
    return CIRenderTask.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static CIRenderTask allocWithZone_(ffi.Pointer<objc.NSZone> zone) {
    final _ret =
        _objc_msgSend_1cwp428(_class_CIRenderTask, _sel_allocWithZone_, zone);
    return CIRenderTask.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static CIRenderTask alloc() {
    final _ret = _objc_msgSend_151sglz(_class_CIRenderTask, _sel_alloc);
    return CIRenderTask.castFromPointer(_ret, retain: false, release: true);
  }

  /// self
  CIRenderTask self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return CIRenderTask.castFromPointer(_ret, retain: true, release: true);
  }

  /// retain
  CIRenderTask retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return CIRenderTask.castFromPointer(_ret, retain: true, release: true);
  }

  /// autorelease
  CIRenderTask autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return CIRenderTask.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a new instance of CIRenderTask constructed with the default `new` method.
  factory CIRenderTask() => new$();
}

late final _class_CIRenderDestination = objc.getClass("CIRenderDestination");
late final _sel_initWithPixelBuffer_ =
    objc.registerName("initWithPixelBuffer:");
late final _class_IOSurface = objc.getClass("IOSurface");
late final _sel_initWithProperties_ = objc.registerName("initWithProperties:");
late final _sel_lockWithOptions_seed_ =
    objc.registerName("lockWithOptions:seed:");
final _objc_msgSend_wbkehc = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Int Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Uint32,
                ffi.Pointer<ffi.Uint32>)>>()
    .asFunction<
        int Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int, ffi.Pointer<ffi.Uint32>)>();
late final _sel_unlockWithOptions_seed_ =
    objc.registerName("unlockWithOptions:seed:");
late final _sel_allocationSize = objc.registerName("allocationSize");
late final _sel_width = objc.registerName("width");
late final _sel_height = objc.registerName("height");
late final _sel_baseAddress = objc.registerName("baseAddress");
final _objc_msgSend_6ex6p5 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<ffi.Void> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        ffi.Pointer<ffi.Void> Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_pixelFormat = objc.registerName("pixelFormat");
late final _sel_bytesPerRow = objc.registerName("bytesPerRow");
late final _sel_bytesPerElement = objc.registerName("bytesPerElement");
late final _sel_elementWidth = objc.registerName("elementWidth");
late final _sel_elementHeight = objc.registerName("elementHeight");
late final _sel_surfaceID = objc.registerName("surfaceID");
final _objc_msgSend_usggvf = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Uint32 Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_seed = objc.registerName("seed");
late final _sel_planeCount = objc.registerName("planeCount");
final _objc_msgSend_xw2lbc = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_widthOfPlaneAtIndex_ =
    objc.registerName("widthOfPlaneAtIndex:");
final _objc_msgSend_3zmfvm = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Long Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLong)>>()
    .asFunction<
        int Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_heightOfPlaneAtIndex_ =
    objc.registerName("heightOfPlaneAtIndex:");
late final _sel_bytesPerRowOfPlaneAtIndex_ =
    objc.registerName("bytesPerRowOfPlaneAtIndex:");
late final _sel_bytesPerElementOfPlaneAtIndex_ =
    objc.registerName("bytesPerElementOfPlaneAtIndex:");
late final _sel_elementWidthOfPlaneAtIndex_ =
    objc.registerName("elementWidthOfPlaneAtIndex:");
late final _sel_elementHeightOfPlaneAtIndex_ =
    objc.registerName("elementHeightOfPlaneAtIndex:");
late final _sel_baseAddressOfPlaneAtIndex_ =
    objc.registerName("baseAddressOfPlaneAtIndex:");
final _objc_msgSend_16bn854 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<ffi.Void> Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLong)>>()
    .asFunction<
        ffi.Pointer<ffi.Void> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_setAttachment_forKey_ =
    objc.registerName("setAttachment:forKey:");
final _objc_msgSend_pfv6jd = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_attachmentForKey_ = objc.registerName("attachmentForKey:");
late final _sel_removeAttachmentForKey_ =
    objc.registerName("removeAttachmentForKey:");
late final _sel_setAllAttachments_ = objc.registerName("setAllAttachments:");
late final _sel_allAttachments = objc.registerName("allAttachments");
late final _sel_removeAllAttachments =
    objc.registerName("removeAllAttachments");
late final _sel_isInUse = objc.registerName("isInUse");
late final _sel_incrementUseCount = objc.registerName("incrementUseCount");
late final _sel_decrementUseCount = objc.registerName("decrementUseCount");
late final _sel_localUseCount = objc.registerName("localUseCount");
final _objc_msgSend_1gcq84o = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Int32 Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_allowsPixelSizeCasting =
    objc.registerName("allowsPixelSizeCasting");
late final _sel_setPurgeable_oldState_ =
    objc.registerName("setPurgeable:oldState:");
final _objc_msgSend_1niqy4 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Int Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Uint32,
                ffi.Pointer<ffi.Uint32>)>>()
    .asFunction<
        int Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int, ffi.Pointer<ffi.Uint32>)>();

/// IOSurface
class IOSurface extends objc.NSObject implements objc.NSSecureCoding {
  IOSurface._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('IOSurface',
        iOS: (false, (11, 0, 0)), macOS: (false, (10, 12, 0)));
  }

  /// Constructs a [IOSurface] that points to the same underlying object as [other].
  IOSurface.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [IOSurface] that wraps the given raw object pointer.
  IOSurface.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [IOSurface].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_IOSurface);
  }

  /// initWithProperties:
  IOSurface? initWithProperties_(objc.NSDictionary properties) {
    objc.checkOsVersionInternal('IOSurface.initWithProperties:',
        iOS: (false, (11, 0, 0)), macOS: (false, (10, 12, 0)));
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithProperties_, properties.ref.pointer);
    return _ret.address == 0
        ? null
        : IOSurface.castFromPointer(_ret, retain: false, release: true);
  }

  /// lockWithOptions:seed:
  int lockWithOptions_seed_(
      IOSurfaceLockOptions options, ffi.Pointer<ffi.Uint32> seed) {
    objc.checkOsVersionInternal('IOSurface.lockWithOptions:seed:',
        iOS: (false, (11, 0, 0)), macOS: (false, (10, 12, 0)));
    return _objc_msgSend_wbkehc(
        this.ref.pointer, _sel_lockWithOptions_seed_, options.value, seed);
  }

  /// unlockWithOptions:seed:
  int unlockWithOptions_seed_(
      IOSurfaceLockOptions options, ffi.Pointer<ffi.Uint32> seed) {
    objc.checkOsVersionInternal('IOSurface.unlockWithOptions:seed:',
        iOS: (false, (11, 0, 0)), macOS: (false, (10, 12, 0)));
    return _objc_msgSend_wbkehc(
        this.ref.pointer, _sel_unlockWithOptions_seed_, options.value, seed);
  }

  /// allocationSize
  int get allocationSize {
    objc.checkOsVersionInternal('IOSurface.allocationSize',
        iOS: (false, (11, 0, 0)), macOS: (false, (10, 12, 0)));
    return _objc_msgSend_1hz7y9r(this.ref.pointer, _sel_allocationSize);
  }

  /// width
  int get width {
    objc.checkOsVersionInternal('IOSurface.width',
        iOS: (false, (11, 0, 0)), macOS: (false, (10, 12, 0)));
    return _objc_msgSend_1hz7y9r(this.ref.pointer, _sel_width);
  }

  /// height
  int get height {
    objc.checkOsVersionInternal('IOSurface.height',
        iOS: (false, (11, 0, 0)), macOS: (false, (10, 12, 0)));
    return _objc_msgSend_1hz7y9r(this.ref.pointer, _sel_height);
  }

  /// baseAddress
  ffi.Pointer<ffi.Void> get baseAddress {
    objc.checkOsVersionInternal('IOSurface.baseAddress',
        iOS: (false, (11, 0, 0)), macOS: (false, (10, 12, 0)));
    return _objc_msgSend_6ex6p5(this.ref.pointer, _sel_baseAddress);
  }

  /// pixelFormat
  int get pixelFormat {
    objc.checkOsVersionInternal('IOSurface.pixelFormat',
        iOS: (false, (11, 0, 0)), macOS: (false, (10, 12, 0)));
    return _objc_msgSend_3pyzne(this.ref.pointer, _sel_pixelFormat);
  }

  /// bytesPerRow
  int get bytesPerRow {
    objc.checkOsVersionInternal('IOSurface.bytesPerRow',
        iOS: (false, (11, 0, 0)), macOS: (false, (10, 12, 0)));
    return _objc_msgSend_1hz7y9r(this.ref.pointer, _sel_bytesPerRow);
  }

  /// bytesPerElement
  int get bytesPerElement {
    objc.checkOsVersionInternal('IOSurface.bytesPerElement',
        iOS: (false, (11, 0, 0)), macOS: (false, (10, 12, 0)));
    return _objc_msgSend_1hz7y9r(this.ref.pointer, _sel_bytesPerElement);
  }

  /// elementWidth
  int get elementWidth {
    objc.checkOsVersionInternal('IOSurface.elementWidth',
        iOS: (false, (11, 0, 0)), macOS: (false, (10, 12, 0)));
    return _objc_msgSend_1hz7y9r(this.ref.pointer, _sel_elementWidth);
  }

  /// elementHeight
  int get elementHeight {
    objc.checkOsVersionInternal('IOSurface.elementHeight',
        iOS: (false, (11, 0, 0)), macOS: (false, (10, 12, 0)));
    return _objc_msgSend_1hz7y9r(this.ref.pointer, _sel_elementHeight);
  }

  /// surfaceID
  int get surfaceID {
    objc.checkOsVersionInternal('IOSurface.surfaceID',
        iOS: (false, (18, 0, 0)), macOS: (false, (15, 0, 0)));
    return _objc_msgSend_usggvf(this.ref.pointer, _sel_surfaceID);
  }

  /// seed
  int get seed {
    objc.checkOsVersionInternal('IOSurface.seed',
        iOS: (false, (11, 0, 0)), macOS: (false, (10, 12, 0)));
    return _objc_msgSend_usggvf(this.ref.pointer, _sel_seed);
  }

  /// planeCount
  int get planeCount {
    objc.checkOsVersionInternal('IOSurface.planeCount',
        iOS: (false, (11, 0, 0)), macOS: (false, (10, 12, 0)));
    return _objc_msgSend_xw2lbc(this.ref.pointer, _sel_planeCount);
  }

  /// widthOfPlaneAtIndex:
  int widthOfPlaneAtIndex_(int planeIndex) {
    objc.checkOsVersionInternal('IOSurface.widthOfPlaneAtIndex:',
        iOS: (false, (11, 0, 0)), macOS: (false, (10, 12, 0)));
    return _objc_msgSend_3zmfvm(
        this.ref.pointer, _sel_widthOfPlaneAtIndex_, planeIndex);
  }

  /// heightOfPlaneAtIndex:
  int heightOfPlaneAtIndex_(int planeIndex) {
    objc.checkOsVersionInternal('IOSurface.heightOfPlaneAtIndex:',
        iOS: (false, (11, 0, 0)), macOS: (false, (10, 12, 0)));
    return _objc_msgSend_3zmfvm(
        this.ref.pointer, _sel_heightOfPlaneAtIndex_, planeIndex);
  }

  /// bytesPerRowOfPlaneAtIndex:
  int bytesPerRowOfPlaneAtIndex_(int planeIndex) {
    objc.checkOsVersionInternal('IOSurface.bytesPerRowOfPlaneAtIndex:',
        iOS: (false, (11, 0, 0)), macOS: (false, (10, 12, 0)));
    return _objc_msgSend_3zmfvm(
        this.ref.pointer, _sel_bytesPerRowOfPlaneAtIndex_, planeIndex);
  }

  /// bytesPerElementOfPlaneAtIndex:
  int bytesPerElementOfPlaneAtIndex_(int planeIndex) {
    objc.checkOsVersionInternal('IOSurface.bytesPerElementOfPlaneAtIndex:',
        iOS: (false, (11, 0, 0)), macOS: (false, (10, 12, 0)));
    return _objc_msgSend_3zmfvm(
        this.ref.pointer, _sel_bytesPerElementOfPlaneAtIndex_, planeIndex);
  }

  /// elementWidthOfPlaneAtIndex:
  int elementWidthOfPlaneAtIndex_(int planeIndex) {
    objc.checkOsVersionInternal('IOSurface.elementWidthOfPlaneAtIndex:',
        iOS: (false, (11, 0, 0)), macOS: (false, (10, 12, 0)));
    return _objc_msgSend_3zmfvm(
        this.ref.pointer, _sel_elementWidthOfPlaneAtIndex_, planeIndex);
  }

  /// elementHeightOfPlaneAtIndex:
  int elementHeightOfPlaneAtIndex_(int planeIndex) {
    objc.checkOsVersionInternal('IOSurface.elementHeightOfPlaneAtIndex:',
        iOS: (false, (11, 0, 0)), macOS: (false, (10, 12, 0)));
    return _objc_msgSend_3zmfvm(
        this.ref.pointer, _sel_elementHeightOfPlaneAtIndex_, planeIndex);
  }

  /// baseAddressOfPlaneAtIndex:
  ffi.Pointer<ffi.Void> baseAddressOfPlaneAtIndex_(int planeIndex) {
    objc.checkOsVersionInternal('IOSurface.baseAddressOfPlaneAtIndex:',
        iOS: (false, (11, 0, 0)), macOS: (false, (10, 12, 0)));
    return _objc_msgSend_16bn854(
        this.ref.pointer, _sel_baseAddressOfPlaneAtIndex_, planeIndex);
  }

  /// setAttachment:forKey:
  void setAttachment_forKey_(objc.ObjCObjectBase anObject, objc.NSString key) {
    objc.checkOsVersionInternal('IOSurface.setAttachment:forKey:',
        iOS: (false, (11, 0, 0)), macOS: (false, (10, 12, 0)));
    _objc_msgSend_pfv6jd(this.ref.pointer, _sel_setAttachment_forKey_,
        anObject.ref.pointer, key.ref.pointer);
  }

  /// attachmentForKey:
  objc.ObjCObjectBase? attachmentForKey_(objc.NSString key) {
    objc.checkOsVersionInternal('IOSurface.attachmentForKey:',
        iOS: (false, (11, 0, 0)), macOS: (false, (10, 12, 0)));
    final _ret = _objc_msgSend_1sotr3r(
        this.ref.pointer, _sel_attachmentForKey_, key.ref.pointer);
    return _ret.address == 0
        ? null
        : objc.ObjCObjectBase(_ret, retain: true, release: true);
  }

  /// removeAttachmentForKey:
  void removeAttachmentForKey_(objc.NSString key) {
    objc.checkOsVersionInternal('IOSurface.removeAttachmentForKey:',
        iOS: (false, (11, 0, 0)), macOS: (false, (10, 12, 0)));
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_removeAttachmentForKey_, key.ref.pointer);
  }

  /// setAllAttachments:
  void setAllAttachments_(objc.NSDictionary dict) {
    objc.checkOsVersionInternal('IOSurface.setAllAttachments:',
        iOS: (false, (11, 0, 0)), macOS: (false, (10, 12, 0)));
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_setAllAttachments_, dict.ref.pointer);
  }

  /// allAttachments
  objc.NSDictionary? allAttachments() {
    objc.checkOsVersionInternal('IOSurface.allAttachments',
        iOS: (false, (11, 0, 0)), macOS: (false, (10, 12, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_allAttachments);
    return _ret.address == 0
        ? null
        : objc.NSDictionary.castFromPointer(_ret, retain: true, release: true);
  }

  /// removeAllAttachments
  void removeAllAttachments() {
    objc.checkOsVersionInternal('IOSurface.removeAllAttachments',
        iOS: (false, (11, 0, 0)), macOS: (false, (10, 12, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_removeAllAttachments);
  }

  /// isInUse
  bool get inUse {
    objc.checkOsVersionInternal('IOSurface.isInUse',
        iOS: (false, (11, 0, 0)), macOS: (false, (10, 12, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isInUse);
  }

  /// incrementUseCount
  void incrementUseCount() {
    objc.checkOsVersionInternal('IOSurface.incrementUseCount',
        iOS: (false, (11, 0, 0)), macOS: (false, (10, 12, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_incrementUseCount);
  }

  /// decrementUseCount
  void decrementUseCount() {
    objc.checkOsVersionInternal('IOSurface.decrementUseCount',
        iOS: (false, (11, 0, 0)), macOS: (false, (10, 12, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_decrementUseCount);
  }

  /// localUseCount
  int get localUseCount {
    objc.checkOsVersionInternal('IOSurface.localUseCount',
        iOS: (false, (11, 0, 0)), macOS: (false, (10, 12, 0)));
    return _objc_msgSend_1gcq84o(this.ref.pointer, _sel_localUseCount);
  }

  /// allowsPixelSizeCasting
  bool get allowsPixelSizeCasting {
    objc.checkOsVersionInternal('IOSurface.allowsPixelSizeCasting',
        iOS: (false, (11, 0, 0)), macOS: (false, (10, 12, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_allowsPixelSizeCasting);
  }

  /// setPurgeable:oldState:
  int setPurgeable_oldState_(
      IOSurfacePurgeabilityState newState, ffi.Pointer<ffi.Uint32> oldState) {
    objc.checkOsVersionInternal('IOSurface.setPurgeable:oldState:',
        iOS: (false, (11, 0, 0)), macOS: (false, (10, 13, 0)));
    return _objc_msgSend_1niqy4(this.ref.pointer, _sel_setPurgeable_oldState_,
        newState.value, oldState);
  }

  /// init
  IOSurface init() {
    objc.checkOsVersionInternal('IOSurface.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return IOSurface.castFromPointer(_ret, retain: false, release: true);
  }

  /// new
  static IOSurface new$() {
    final _ret = _objc_msgSend_151sglz(_class_IOSurface, _sel_new);
    return IOSurface.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static IOSurface allocWithZone_(ffi.Pointer<objc.NSZone> zone) {
    final _ret =
        _objc_msgSend_1cwp428(_class_IOSurface, _sel_allocWithZone_, zone);
    return IOSurface.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static IOSurface alloc() {
    final _ret = _objc_msgSend_151sglz(_class_IOSurface, _sel_alloc);
    return IOSurface.castFromPointer(_ret, retain: false, release: true);
  }

  /// self
  IOSurface self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return IOSurface.castFromPointer(_ret, retain: true, release: true);
  }

  /// retain
  IOSurface retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return IOSurface.castFromPointer(_ret, retain: true, release: true);
  }

  /// autorelease
  IOSurface autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return IOSurface.castFromPointer(_ret, retain: true, release: true);
  }

  /// supportsSecureCoding
  static bool getSupportsSecureCoding() {
    return _objc_msgSend_91o635(_class_IOSurface, _sel_supportsSecureCoding);
  }

  /// encodeWithCoder:
  void encodeWithCoder_(objc.NSCoder coder) {
    _objc_msgSend_xtuoz7(
        this.ref.pointer, _sel_encodeWithCoder_, coder.ref.pointer);
  }

  /// initWithCoder:
  IOSurface? initWithCoder_(objc.NSCoder coder) {
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithCoder_, coder.ref.pointer);
    return _ret.address == 0
        ? null
        : IOSurface.castFromPointer(_ret, retain: false, release: true);
  }

  /// Returns a new instance of IOSurface constructed with the default `new` method.
  factory IOSurface() => new$();
}

late final _protocol_MTLCommandBuffer = objc.getProtocol("MTLCommandBuffer");

/// MTLCommandBuffer
interface class MTLCommandBuffer extends objc.ObjCProtocolBase {
  MTLCommandBuffer._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [MTLCommandBuffer] that points to the same underlying object as [other].
  MTLCommandBuffer.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MTLCommandBuffer] that wraps the given raw object pointer.
  MTLCommandBuffer.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MTLCommandBuffer].
  static bool conformsTo(objc.ObjCObjectBase obj) {
    return _objc_msgSend_e3qsqz(
        obj.ref.pointer, _sel_conformsToProtocol_, _protocol_MTLCommandBuffer);
  }

  /// Returns the [objc.Protocol] object for this protocol.
  static objc.Protocol get $protocol =>
      objc.Protocol.castFromPointer(_protocol_MTLCommandBuffer.cast());

  /// Builds an object that implements the MTLCommandBuffer protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static MTLCommandBuffer implement({bool $keepIsolateAlive = true}) {
    final builder = objc.ObjCProtocolBuilder(debugName: 'MTLCommandBuffer');

    builder.addProtocol($protocol);
    return MTLCommandBuffer.castFrom(
        builder.build(keepIsolateAlive: $keepIsolateAlive));
  }

  /// Adds the implementation of the MTLCommandBuffer protocol to an existing
  /// [objc.ObjCProtocolBuilder].
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilder(objc.ObjCProtocolBuilder builder,
      {bool $keepIsolateAlive = true}) {
    builder.addProtocol($protocol);
  }
}

late final _sel_initWithMTLTexture_commandBuffer_ =
    objc.registerName("initWithMTLTexture:commandBuffer:");
ffi.Pointer<objc.ObjCObject> _ObjCBlock_idMTLTexture_fnPtrTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
) =>
    block.ref.target
        .cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function()>>()
        .asFunction<ffi.Pointer<objc.ObjCObject> Function()>()();
ffi.Pointer<ffi.Void> _ObjCBlock_idMTLTexture_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>)>(
            _ObjCBlock_idMTLTexture_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject> _ObjCBlock_idMTLTexture_closureTrampoline(
  ffi.Pointer<objc.ObjCBlockImpl> block,
) =>
    (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function())();
ffi.Pointer<ffi.Void> _ObjCBlock_idMTLTexture_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>)>(
            _ObjCBlock_idMTLTexture_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function()>`.
abstract final class ObjCBlock_idMTLTexture {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function()>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function()>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function()>
      fromFunctionPointer(
              ffi.Pointer<
                      ffi
                      .NativeFunction<ffi.Pointer<objc.ObjCObject> Function()>>
                  ptr) =>
          objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function()>(
              objc.newPointerBlock(
                  _ObjCBlock_idMTLTexture_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function()> fromFunction(
          MTLTexture Function() fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function()>(
          objc.newClosureBlock(_ObjCBlock_idMTLTexture_closureCallable,
              () => fn().ref.retainAndAutorelease(), keepIsolateAlive),
          retain: false,
          release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function()>`.
extension ObjCBlock_idMTLTexture_CallExtension
    on objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function()> {
  MTLTexture call() => MTLTexture.castFromPointer(
      ref.pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                      ffi.Pointer<objc.ObjCBlockImpl> block)>>()
          .asFunction<
              ffi.Pointer<objc.ObjCObject> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>)>()(
        ref.pointer,
      ),
      retain: true,
      release: true);
}

late final _sel_initWithWidth_height_pixelFormat_commandBuffer_mtlTextureProvider_ =
    objc.registerName(
        "initWithWidth:height:pixelFormat:commandBuffer:mtlTextureProvider:");
final _objc_msgSend_8fw814 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.UnsignedLong,
                ffi.UnsignedLong,
                ffi.UnsignedLong,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCBlockImpl>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            int,
            int,
            int,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCBlockImpl>)>();
late final _sel_initWithGLTexture_target_width_height_ =
    objc.registerName("initWithGLTexture:target:width:height:");
final _objc_msgSend_1ebo5y7 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.UnsignedInt,
                ffi.UnsignedInt,
                ffi.UnsignedLong,
                ffi.UnsignedLong)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int, int, int, int)>();
late final _sel_initWithBitmapData_width_height_bytesPerRow_format_ =
    objc.registerName("initWithBitmapData:width:height:bytesPerRow:format:");
final _objc_msgSend_1e79x6n = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<ffi.Void>,
                ffi.UnsignedLong,
                ffi.UnsignedLong,
                ffi.UnsignedLong,
                ffi.Int)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<ffi.Void>,
            int,
            int,
            int,
            int)>();

enum CIRenderDestinationAlphaMode {
  CIRenderDestinationAlphaNone(0),
  CIRenderDestinationAlphaPremultiplied(1),
  CIRenderDestinationAlphaUnpremultiplied(2);

  final int value;
  const CIRenderDestinationAlphaMode(this.value);

  static CIRenderDestinationAlphaMode fromValue(int value) => switch (value) {
        0 => CIRenderDestinationAlphaNone,
        1 => CIRenderDestinationAlphaPremultiplied,
        2 => CIRenderDestinationAlphaUnpremultiplied,
        _ => throw ArgumentError(
            'Unknown value for CIRenderDestinationAlphaMode: $value'),
      };
}

late final _sel_alphaMode = objc.registerName("alphaMode");
final _objc_msgSend_x4izku = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setAlphaMode_ = objc.registerName("setAlphaMode:");
final _objc_msgSend_1kijgxo = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.UnsignedLong)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_isFlipped = objc.registerName("isFlipped");
late final _sel_setFlipped_ = objc.registerName("setFlipped:");
late final _sel_isDithered = objc.registerName("isDithered");
late final _sel_setDithered_ = objc.registerName("setDithered:");
late final _sel_isClamped = objc.registerName("isClamped");
late final _sel_setClamped_ = objc.registerName("setClamped:");
late final _sel_setColorSpace_ = objc.registerName("setColorSpace:");
final _objc_msgSend_uqbnbf = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<CGColorSpace>)>>()
    .asFunction<
        void Function(ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<CGColorSpace>)>();
late final _class_CIColorKernel = objc.getClass("CIColorKernel");
late final _sel_applyWithExtent_arguments_ =
    objc.registerName("applyWithExtent:arguments:");
final _objc_msgSend_gxusyk = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                CGRect,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            CGRect,
            ffi.Pointer<objc.ObjCObject>)>();

/// CIColorKernel
class CIColorKernel extends CIKernel {
  CIColorKernel._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('CIColorKernel', macOS: (false, (10, 11, 0)));
  }

  /// Constructs a [CIColorKernel] that points to the same underlying object as [other].
  CIColorKernel.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [CIColorKernel] that wraps the given raw object pointer.
  CIColorKernel.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [CIColorKernel].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_CIColorKernel);
  }

  /// kernelWithString:
  static CIColorKernel? kernelWithString_(objc.NSString string) {
    objc.checkOsVersionInternal('CIColorKernel.kernelWithString:',
        macOS: (false, (10, 10, 0)));
    final _ret = _objc_msgSend_1sotr3r(
        _class_CIColorKernel, _sel_kernelWithString_, string.ref.pointer);
    return _ret.address == 0
        ? null
        : CIColorKernel.castFromPointer(_ret, retain: true, release: true);
  }

  /// applyWithExtent:arguments:
  CIImage? applyWithExtent_arguments_(CGRect extent, objc.NSArray? args) {
    objc.checkOsVersionInternal('CIColorKernel.applyWithExtent:arguments:',
        macOS: (false, (10, 11, 0)));
    final _ret = _objc_msgSend_gxusyk(
        this.ref.pointer,
        _sel_applyWithExtent_arguments_,
        extent,
        args?.ref.pointer ?? ffi.nullptr);
    return _ret.address == 0
        ? null
        : CIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// kernelsWithString:
  static objc.NSArray? kernelsWithString_(objc.NSString string) {
    objc.checkOsVersionInternal('CIColorKernel.kernelsWithString:',
        macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_1sotr3r(
        _class_CIColorKernel, _sel_kernelsWithString_, string.ref.pointer);
    return _ret.address == 0
        ? null
        : objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// kernelsWithMetalString:error:
  static objc.NSArray? kernelsWithMetalString_error_(
      objc.NSString source, ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error) {
    objc.checkOsVersionInternal('CIColorKernel.kernelsWithMetalString:error:',
        macOS: (false, (12, 0, 0)));
    final _ret = _objc_msgSend_1lhpu4m(_class_CIColorKernel,
        _sel_kernelsWithMetalString_error_, source.ref.pointer, error);
    return _ret.address == 0
        ? null
        : objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// kernelWithFunctionName:fromMetalLibraryData:error:
  static CIColorKernel? kernelWithFunctionName_fromMetalLibraryData_error_(
      objc.NSString name,
      objc.NSData data,
      ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error) {
    objc.checkOsVersionInternal(
        'CIColorKernel.kernelWithFunctionName:fromMetalLibraryData:error:',
        macOS: (false, (10, 13, 0)));
    final _ret = _objc_msgSend_1pnyuds(
        _class_CIColorKernel,
        _sel_kernelWithFunctionName_fromMetalLibraryData_error_,
        name.ref.pointer,
        data.ref.pointer,
        error);
    return _ret.address == 0
        ? null
        : CIColorKernel.castFromPointer(_ret, retain: true, release: true);
  }

  /// kernelWithFunctionName:fromMetalLibraryData:outputPixelFormat:error:
  static CIColorKernel?
      kernelWithFunctionName_fromMetalLibraryData_outputPixelFormat_error_(
          objc.NSString name,
          objc.NSData data,
          int format,
          ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error) {
    objc.checkOsVersionInternal(
        'CIColorKernel.kernelWithFunctionName:fromMetalLibraryData:outputPixelFormat:error:',
        macOS: (false, (10, 13, 0)));
    final _ret = _objc_msgSend_1ja6awd(
        _class_CIColorKernel,
        _sel_kernelWithFunctionName_fromMetalLibraryData_outputPixelFormat_error_,
        name.ref.pointer,
        data.ref.pointer,
        format,
        error);
    return _ret.address == 0
        ? null
        : CIColorKernel.castFromPointer(_ret, retain: true, release: true);
  }

  /// kernelNamesFromMetalLibraryData:
  static objc.NSArray kernelNamesFromMetalLibraryData_(objc.NSData data) {
    objc.checkOsVersionInternal(
        'CIColorKernel.kernelNamesFromMetalLibraryData:',
        macOS: (false, (11, 0, 0)));
    final _ret = _objc_msgSend_1sotr3r(_class_CIColorKernel,
        _sel_kernelNamesFromMetalLibraryData_, data.ref.pointer);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// init
  CIColorKernel init() {
    objc.checkOsVersionInternal('CIColorKernel.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return CIColorKernel.castFromPointer(_ret, retain: false, release: true);
  }

  /// new
  static CIColorKernel new$() {
    final _ret = _objc_msgSend_151sglz(_class_CIColorKernel, _sel_new);
    return CIColorKernel.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static CIColorKernel allocWithZone_(ffi.Pointer<objc.NSZone> zone) {
    final _ret =
        _objc_msgSend_1cwp428(_class_CIColorKernel, _sel_allocWithZone_, zone);
    return CIColorKernel.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static CIColorKernel alloc() {
    final _ret = _objc_msgSend_151sglz(_class_CIColorKernel, _sel_alloc);
    return CIColorKernel.castFromPointer(_ret, retain: false, release: true);
  }

  /// self
  CIColorKernel self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return CIColorKernel.castFromPointer(_ret, retain: true, release: true);
  }

  /// retain
  CIColorKernel retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return CIColorKernel.castFromPointer(_ret, retain: true, release: true);
  }

  /// autorelease
  CIColorKernel autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return CIColorKernel.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a new instance of CIColorKernel constructed with the default `new` method.
  factory CIColorKernel() => new$();
}

late final _class_CIBlendKernel = objc.getClass("CIBlendKernel");
late final _sel_componentAdd = objc.registerName("componentAdd");
late final _sel_componentMultiply = objc.registerName("componentMultiply");
late final _sel_componentMin = objc.registerName("componentMin");
late final _sel_componentMax = objc.registerName("componentMax");
late final _sel_clear = objc.registerName("clear");
late final _sel_source = objc.registerName("source");
late final _sel_destination = objc.registerName("destination");
late final _sel_sourceOver = objc.registerName("sourceOver");
late final _sel_destinationOver = objc.registerName("destinationOver");
late final _sel_sourceIn = objc.registerName("sourceIn");
late final _sel_destinationIn = objc.registerName("destinationIn");
late final _sel_sourceOut = objc.registerName("sourceOut");
late final _sel_destinationOut = objc.registerName("destinationOut");
late final _sel_sourceAtop = objc.registerName("sourceAtop");
late final _sel_destinationAtop = objc.registerName("destinationAtop");
late final _sel_exclusiveOr = objc.registerName("exclusiveOr");
late final _sel_multiply = objc.registerName("multiply");
late final _sel_screen = objc.registerName("screen");
late final _sel_overlay = objc.registerName("overlay");
late final _sel_darken = objc.registerName("darken");
late final _sel_lighten = objc.registerName("lighten");
late final _sel_colorDodge = objc.registerName("colorDodge");
late final _sel_colorBurn = objc.registerName("colorBurn");
late final _sel_hardLight = objc.registerName("hardLight");
late final _sel_softLight = objc.registerName("softLight");
late final _sel_difference = objc.registerName("difference");
late final _sel_exclusion = objc.registerName("exclusion");
late final _sel_hue = objc.registerName("hue");
late final _sel_saturation = objc.registerName("saturation");
late final _sel_color = objc.registerName("color");
late final _sel_luminosity = objc.registerName("luminosity");
late final _sel_subtract = objc.registerName("subtract");
late final _sel_divide = objc.registerName("divide");
late final _sel_linearBurn = objc.registerName("linearBurn");
late final _sel_linearDodge = objc.registerName("linearDodge");
late final _sel_vividLight = objc.registerName("vividLight");
late final _sel_linearLight = objc.registerName("linearLight");
late final _sel_pinLight = objc.registerName("pinLight");
late final _sel_hardMix = objc.registerName("hardMix");
late final _sel_darkerColor = objc.registerName("darkerColor");
late final _sel_lighterColor = objc.registerName("lighterColor");

/// BuiltIn
extension BuiltIn on CIBlendKernel {
  /// componentAdd
  static CIBlendKernel getComponentAdd() {
    objc.checkOsVersionInternal('CIBlendKernel.componentAdd',
        macOS: (false, (10, 13, 0)));
    final _ret = _objc_msgSend_151sglz(_class_CIBlendKernel, _sel_componentAdd);
    return CIBlendKernel.castFromPointer(_ret, retain: true, release: true);
  }

  /// componentMultiply
  static CIBlendKernel getComponentMultiply() {
    objc.checkOsVersionInternal('CIBlendKernel.componentMultiply',
        macOS: (false, (10, 13, 0)));
    final _ret =
        _objc_msgSend_151sglz(_class_CIBlendKernel, _sel_componentMultiply);
    return CIBlendKernel.castFromPointer(_ret, retain: true, release: true);
  }

  /// componentMin
  static CIBlendKernel getComponentMin() {
    objc.checkOsVersionInternal('CIBlendKernel.componentMin',
        macOS: (false, (10, 13, 0)));
    final _ret = _objc_msgSend_151sglz(_class_CIBlendKernel, _sel_componentMin);
    return CIBlendKernel.castFromPointer(_ret, retain: true, release: true);
  }

  /// componentMax
  static CIBlendKernel getComponentMax() {
    objc.checkOsVersionInternal('CIBlendKernel.componentMax',
        macOS: (false, (10, 13, 0)));
    final _ret = _objc_msgSend_151sglz(_class_CIBlendKernel, _sel_componentMax);
    return CIBlendKernel.castFromPointer(_ret, retain: true, release: true);
  }

  /// clear
  static CIBlendKernel getClear() {
    objc.checkOsVersionInternal('CIBlendKernel.clear',
        macOS: (false, (10, 13, 0)));
    final _ret = _objc_msgSend_151sglz(_class_CIBlendKernel, _sel_clear);
    return CIBlendKernel.castFromPointer(_ret, retain: true, release: true);
  }

  /// source
  static CIBlendKernel getSource() {
    objc.checkOsVersionInternal('CIBlendKernel.source',
        macOS: (false, (10, 13, 0)));
    final _ret = _objc_msgSend_151sglz(_class_CIBlendKernel, _sel_source);
    return CIBlendKernel.castFromPointer(_ret, retain: true, release: true);
  }

  /// destination
  static CIBlendKernel getDestination() {
    objc.checkOsVersionInternal('CIBlendKernel.destination',
        macOS: (false, (10, 13, 0)));
    final _ret = _objc_msgSend_151sglz(_class_CIBlendKernel, _sel_destination);
    return CIBlendKernel.castFromPointer(_ret, retain: true, release: true);
  }

  /// sourceOver
  static CIBlendKernel getSourceOver() {
    objc.checkOsVersionInternal('CIBlendKernel.sourceOver',
        macOS: (false, (10, 13, 0)));
    final _ret = _objc_msgSend_151sglz(_class_CIBlendKernel, _sel_sourceOver);
    return CIBlendKernel.castFromPointer(_ret, retain: true, release: true);
  }

  /// destinationOver
  static CIBlendKernel getDestinationOver() {
    objc.checkOsVersionInternal('CIBlendKernel.destinationOver',
        macOS: (false, (10, 13, 0)));
    final _ret =
        _objc_msgSend_151sglz(_class_CIBlendKernel, _sel_destinationOver);
    return CIBlendKernel.castFromPointer(_ret, retain: true, release: true);
  }

  /// sourceIn
  static CIBlendKernel getSourceIn() {
    objc.checkOsVersionInternal('CIBlendKernel.sourceIn',
        macOS: (false, (10, 13, 0)));
    final _ret = _objc_msgSend_151sglz(_class_CIBlendKernel, _sel_sourceIn);
    return CIBlendKernel.castFromPointer(_ret, retain: true, release: true);
  }

  /// destinationIn
  static CIBlendKernel getDestinationIn() {
    objc.checkOsVersionInternal('CIBlendKernel.destinationIn',
        macOS: (false, (10, 13, 0)));
    final _ret =
        _objc_msgSend_151sglz(_class_CIBlendKernel, _sel_destinationIn);
    return CIBlendKernel.castFromPointer(_ret, retain: true, release: true);
  }

  /// sourceOut
  static CIBlendKernel getSourceOut() {
    objc.checkOsVersionInternal('CIBlendKernel.sourceOut',
        macOS: (false, (10, 13, 0)));
    final _ret = _objc_msgSend_151sglz(_class_CIBlendKernel, _sel_sourceOut);
    return CIBlendKernel.castFromPointer(_ret, retain: true, release: true);
  }

  /// destinationOut
  static CIBlendKernel getDestinationOut() {
    objc.checkOsVersionInternal('CIBlendKernel.destinationOut',
        macOS: (false, (10, 13, 0)));
    final _ret =
        _objc_msgSend_151sglz(_class_CIBlendKernel, _sel_destinationOut);
    return CIBlendKernel.castFromPointer(_ret, retain: true, release: true);
  }

  /// sourceAtop
  static CIBlendKernel getSourceAtop() {
    objc.checkOsVersionInternal('CIBlendKernel.sourceAtop',
        macOS: (false, (10, 13, 0)));
    final _ret = _objc_msgSend_151sglz(_class_CIBlendKernel, _sel_sourceAtop);
    return CIBlendKernel.castFromPointer(_ret, retain: true, release: true);
  }

  /// destinationAtop
  static CIBlendKernel getDestinationAtop() {
    objc.checkOsVersionInternal('CIBlendKernel.destinationAtop',
        macOS: (false, (10, 13, 0)));
    final _ret =
        _objc_msgSend_151sglz(_class_CIBlendKernel, _sel_destinationAtop);
    return CIBlendKernel.castFromPointer(_ret, retain: true, release: true);
  }

  /// exclusiveOr
  static CIBlendKernel getExclusiveOr() {
    objc.checkOsVersionInternal('CIBlendKernel.exclusiveOr',
        macOS: (false, (10, 13, 0)));
    final _ret = _objc_msgSend_151sglz(_class_CIBlendKernel, _sel_exclusiveOr);
    return CIBlendKernel.castFromPointer(_ret, retain: true, release: true);
  }

  /// multiply
  static CIBlendKernel getMultiply() {
    objc.checkOsVersionInternal('CIBlendKernel.multiply',
        macOS: (false, (10, 13, 0)));
    final _ret = _objc_msgSend_151sglz(_class_CIBlendKernel, _sel_multiply);
    return CIBlendKernel.castFromPointer(_ret, retain: true, release: true);
  }

  /// screen
  static CIBlendKernel getScreen() {
    objc.checkOsVersionInternal('CIBlendKernel.screen',
        macOS: (false, (10, 13, 0)));
    final _ret = _objc_msgSend_151sglz(_class_CIBlendKernel, _sel_screen);
    return CIBlendKernel.castFromPointer(_ret, retain: true, release: true);
  }

  /// overlay
  static CIBlendKernel getOverlay() {
    objc.checkOsVersionInternal('CIBlendKernel.overlay',
        macOS: (false, (10, 13, 0)));
    final _ret = _objc_msgSend_151sglz(_class_CIBlendKernel, _sel_overlay);
    return CIBlendKernel.castFromPointer(_ret, retain: true, release: true);
  }

  /// darken
  static CIBlendKernel getDarken() {
    objc.checkOsVersionInternal('CIBlendKernel.darken',
        macOS: (false, (10, 13, 0)));
    final _ret = _objc_msgSend_151sglz(_class_CIBlendKernel, _sel_darken);
    return CIBlendKernel.castFromPointer(_ret, retain: true, release: true);
  }

  /// lighten
  static CIBlendKernel getLighten() {
    objc.checkOsVersionInternal('CIBlendKernel.lighten',
        macOS: (false, (10, 13, 0)));
    final _ret = _objc_msgSend_151sglz(_class_CIBlendKernel, _sel_lighten);
    return CIBlendKernel.castFromPointer(_ret, retain: true, release: true);
  }

  /// colorDodge
  static CIBlendKernel getColorDodge() {
    objc.checkOsVersionInternal('CIBlendKernel.colorDodge',
        macOS: (false, (10, 13, 0)));
    final _ret = _objc_msgSend_151sglz(_class_CIBlendKernel, _sel_colorDodge);
    return CIBlendKernel.castFromPointer(_ret, retain: true, release: true);
  }

  /// colorBurn
  static CIBlendKernel getColorBurn() {
    objc.checkOsVersionInternal('CIBlendKernel.colorBurn',
        macOS: (false, (10, 13, 0)));
    final _ret = _objc_msgSend_151sglz(_class_CIBlendKernel, _sel_colorBurn);
    return CIBlendKernel.castFromPointer(_ret, retain: true, release: true);
  }

  /// hardLight
  static CIBlendKernel getHardLight() {
    objc.checkOsVersionInternal('CIBlendKernel.hardLight',
        macOS: (false, (10, 13, 0)));
    final _ret = _objc_msgSend_151sglz(_class_CIBlendKernel, _sel_hardLight);
    return CIBlendKernel.castFromPointer(_ret, retain: true, release: true);
  }

  /// softLight
  static CIBlendKernel getSoftLight() {
    objc.checkOsVersionInternal('CIBlendKernel.softLight',
        macOS: (false, (10, 13, 0)));
    final _ret = _objc_msgSend_151sglz(_class_CIBlendKernel, _sel_softLight);
    return CIBlendKernel.castFromPointer(_ret, retain: true, release: true);
  }

  /// difference
  static CIBlendKernel getDifference() {
    objc.checkOsVersionInternal('CIBlendKernel.difference',
        macOS: (false, (10, 13, 0)));
    final _ret = _objc_msgSend_151sglz(_class_CIBlendKernel, _sel_difference);
    return CIBlendKernel.castFromPointer(_ret, retain: true, release: true);
  }

  /// exclusion
  static CIBlendKernel getExclusion() {
    objc.checkOsVersionInternal('CIBlendKernel.exclusion',
        macOS: (false, (10, 13, 0)));
    final _ret = _objc_msgSend_151sglz(_class_CIBlendKernel, _sel_exclusion);
    return CIBlendKernel.castFromPointer(_ret, retain: true, release: true);
  }

  /// hue
  static CIBlendKernel getHue() {
    objc.checkOsVersionInternal('CIBlendKernel.hue',
        macOS: (false, (10, 13, 0)));
    final _ret = _objc_msgSend_151sglz(_class_CIBlendKernel, _sel_hue);
    return CIBlendKernel.castFromPointer(_ret, retain: true, release: true);
  }

  /// saturation
  static CIBlendKernel getSaturation() {
    objc.checkOsVersionInternal('CIBlendKernel.saturation',
        macOS: (false, (10, 13, 0)));
    final _ret = _objc_msgSend_151sglz(_class_CIBlendKernel, _sel_saturation);
    return CIBlendKernel.castFromPointer(_ret, retain: true, release: true);
  }

  /// color
  static CIBlendKernel getColor() {
    objc.checkOsVersionInternal('CIBlendKernel.color',
        macOS: (false, (10, 13, 0)));
    final _ret = _objc_msgSend_151sglz(_class_CIBlendKernel, _sel_color);
    return CIBlendKernel.castFromPointer(_ret, retain: true, release: true);
  }

  /// luminosity
  static CIBlendKernel getLuminosity() {
    objc.checkOsVersionInternal('CIBlendKernel.luminosity',
        macOS: (false, (10, 13, 0)));
    final _ret = _objc_msgSend_151sglz(_class_CIBlendKernel, _sel_luminosity);
    return CIBlendKernel.castFromPointer(_ret, retain: true, release: true);
  }

  /// subtract
  static CIBlendKernel getSubtract() {
    objc.checkOsVersionInternal('CIBlendKernel.subtract',
        macOS: (false, (10, 13, 0)));
    final _ret = _objc_msgSend_151sglz(_class_CIBlendKernel, _sel_subtract);
    return CIBlendKernel.castFromPointer(_ret, retain: true, release: true);
  }

  /// divide
  static CIBlendKernel getDivide() {
    objc.checkOsVersionInternal('CIBlendKernel.divide',
        macOS: (false, (10, 13, 0)));
    final _ret = _objc_msgSend_151sglz(_class_CIBlendKernel, _sel_divide);
    return CIBlendKernel.castFromPointer(_ret, retain: true, release: true);
  }

  /// linearBurn
  static CIBlendKernel getLinearBurn() {
    objc.checkOsVersionInternal('CIBlendKernel.linearBurn',
        macOS: (false, (10, 13, 0)));
    final _ret = _objc_msgSend_151sglz(_class_CIBlendKernel, _sel_linearBurn);
    return CIBlendKernel.castFromPointer(_ret, retain: true, release: true);
  }

  /// linearDodge
  static CIBlendKernel getLinearDodge() {
    objc.checkOsVersionInternal('CIBlendKernel.linearDodge',
        macOS: (false, (10, 13, 0)));
    final _ret = _objc_msgSend_151sglz(_class_CIBlendKernel, _sel_linearDodge);
    return CIBlendKernel.castFromPointer(_ret, retain: true, release: true);
  }

  /// vividLight
  static CIBlendKernel getVividLight() {
    objc.checkOsVersionInternal('CIBlendKernel.vividLight',
        macOS: (false, (10, 13, 0)));
    final _ret = _objc_msgSend_151sglz(_class_CIBlendKernel, _sel_vividLight);
    return CIBlendKernel.castFromPointer(_ret, retain: true, release: true);
  }

  /// linearLight
  static CIBlendKernel getLinearLight() {
    objc.checkOsVersionInternal('CIBlendKernel.linearLight',
        macOS: (false, (10, 13, 0)));
    final _ret = _objc_msgSend_151sglz(_class_CIBlendKernel, _sel_linearLight);
    return CIBlendKernel.castFromPointer(_ret, retain: true, release: true);
  }

  /// pinLight
  static CIBlendKernel getPinLight() {
    objc.checkOsVersionInternal('CIBlendKernel.pinLight',
        macOS: (false, (10, 13, 0)));
    final _ret = _objc_msgSend_151sglz(_class_CIBlendKernel, _sel_pinLight);
    return CIBlendKernel.castFromPointer(_ret, retain: true, release: true);
  }

  /// hardMix
  static CIBlendKernel getHardMix() {
    objc.checkOsVersionInternal('CIBlendKernel.hardMix',
        macOS: (false, (10, 13, 0)));
    final _ret = _objc_msgSend_151sglz(_class_CIBlendKernel, _sel_hardMix);
    return CIBlendKernel.castFromPointer(_ret, retain: true, release: true);
  }

  /// darkerColor
  static CIBlendKernel getDarkerColor() {
    objc.checkOsVersionInternal('CIBlendKernel.darkerColor',
        macOS: (false, (10, 13, 0)));
    final _ret = _objc_msgSend_151sglz(_class_CIBlendKernel, _sel_darkerColor);
    return CIBlendKernel.castFromPointer(_ret, retain: true, release: true);
  }

  /// lighterColor
  static CIBlendKernel getLighterColor() {
    objc.checkOsVersionInternal('CIBlendKernel.lighterColor',
        macOS: (false, (10, 13, 0)));
    final _ret = _objc_msgSend_151sglz(_class_CIBlendKernel, _sel_lighterColor);
    return CIBlendKernel.castFromPointer(_ret, retain: true, release: true);
  }
}

late final _sel_applyWithForeground_background_ =
    objc.registerName("applyWithForeground:background:");
late final _sel_applyWithForeground_background_colorSpace_ =
    objc.registerName("applyWithForeground:background:colorSpace:");
final _objc_msgSend_ulj43v = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<CGColorSpace>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<CGColorSpace>)>();

/// CIBlendKernel
class CIBlendKernel extends CIColorKernel {
  CIBlendKernel._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('CIBlendKernel', macOS: (false, (10, 13, 0)));
  }

  /// Constructs a [CIBlendKernel] that points to the same underlying object as [other].
  CIBlendKernel.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [CIBlendKernel] that wraps the given raw object pointer.
  CIBlendKernel.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [CIBlendKernel].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_CIBlendKernel);
  }

  /// kernelWithString:
  static CIBlendKernel? kernelWithString_(objc.NSString string) {
    objc.checkOsVersionInternal('CIBlendKernel.kernelWithString:',
        macOS: (false, (10, 10, 0)));
    final _ret = _objc_msgSend_1sotr3r(
        _class_CIBlendKernel, _sel_kernelWithString_, string.ref.pointer);
    return _ret.address == 0
        ? null
        : CIBlendKernel.castFromPointer(_ret, retain: true, release: true);
  }

  /// applyWithForeground:background:
  CIImage? applyWithForeground_background_(
      CIImage foreground, CIImage background) {
    objc.checkOsVersionInternal('CIBlendKernel.applyWithForeground:background:',
        macOS: (false, (10, 13, 0)));
    final _ret = _objc_msgSend_15qeuct(
        this.ref.pointer,
        _sel_applyWithForeground_background_,
        foreground.ref.pointer,
        background.ref.pointer);
    return _ret.address == 0
        ? null
        : CIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// applyWithForeground:background:colorSpace:
  CIImage? applyWithForeground_background_colorSpace_(CIImage foreground,
      CIImage background, ffi.Pointer<CGColorSpace> colorSpace) {
    objc.checkOsVersionInternal(
        'CIBlendKernel.applyWithForeground:background:colorSpace:',
        macOS: (false, (10, 15, 0)));
    final _ret = _objc_msgSend_ulj43v(
        this.ref.pointer,
        _sel_applyWithForeground_background_colorSpace_,
        foreground.ref.pointer,
        background.ref.pointer,
        colorSpace);
    return _ret.address == 0
        ? null
        : CIImage.castFromPointer(_ret, retain: true, release: true);
  }

  /// kernelsWithString:
  static objc.NSArray? kernelsWithString_(objc.NSString string) {
    objc.checkOsVersionInternal('CIBlendKernel.kernelsWithString:',
        macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_1sotr3r(
        _class_CIBlendKernel, _sel_kernelsWithString_, string.ref.pointer);
    return _ret.address == 0
        ? null
        : objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// kernelsWithMetalString:error:
  static objc.NSArray? kernelsWithMetalString_error_(
      objc.NSString source, ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error) {
    objc.checkOsVersionInternal('CIBlendKernel.kernelsWithMetalString:error:',
        macOS: (false, (12, 0, 0)));
    final _ret = _objc_msgSend_1lhpu4m(_class_CIBlendKernel,
        _sel_kernelsWithMetalString_error_, source.ref.pointer, error);
    return _ret.address == 0
        ? null
        : objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// kernelWithFunctionName:fromMetalLibraryData:error:
  static CIBlendKernel? kernelWithFunctionName_fromMetalLibraryData_error_(
      objc.NSString name,
      objc.NSData data,
      ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error) {
    objc.checkOsVersionInternal(
        'CIBlendKernel.kernelWithFunctionName:fromMetalLibraryData:error:',
        macOS: (false, (10, 13, 0)));
    final _ret = _objc_msgSend_1pnyuds(
        _class_CIBlendKernel,
        _sel_kernelWithFunctionName_fromMetalLibraryData_error_,
        name.ref.pointer,
        data.ref.pointer,
        error);
    return _ret.address == 0
        ? null
        : CIBlendKernel.castFromPointer(_ret, retain: true, release: true);
  }

  /// kernelWithFunctionName:fromMetalLibraryData:outputPixelFormat:error:
  static CIBlendKernel?
      kernelWithFunctionName_fromMetalLibraryData_outputPixelFormat_error_(
          objc.NSString name,
          objc.NSData data,
          int format,
          ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error) {
    objc.checkOsVersionInternal(
        'CIBlendKernel.kernelWithFunctionName:fromMetalLibraryData:outputPixelFormat:error:',
        macOS: (false, (10, 13, 0)));
    final _ret = _objc_msgSend_1ja6awd(
        _class_CIBlendKernel,
        _sel_kernelWithFunctionName_fromMetalLibraryData_outputPixelFormat_error_,
        name.ref.pointer,
        data.ref.pointer,
        format,
        error);
    return _ret.address == 0
        ? null
        : CIBlendKernel.castFromPointer(_ret, retain: true, release: true);
  }

  /// kernelNamesFromMetalLibraryData:
  static objc.NSArray kernelNamesFromMetalLibraryData_(objc.NSData data) {
    objc.checkOsVersionInternal(
        'CIBlendKernel.kernelNamesFromMetalLibraryData:',
        macOS: (false, (11, 0, 0)));
    final _ret = _objc_msgSend_1sotr3r(_class_CIBlendKernel,
        _sel_kernelNamesFromMetalLibraryData_, data.ref.pointer);
    return objc.NSArray.castFromPointer(_ret, retain: true, release: true);
  }

  /// init
  CIBlendKernel init() {
    objc.checkOsVersionInternal('CIBlendKernel.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return CIBlendKernel.castFromPointer(_ret, retain: false, release: true);
  }

  /// new
  static CIBlendKernel new$() {
    final _ret = _objc_msgSend_151sglz(_class_CIBlendKernel, _sel_new);
    return CIBlendKernel.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static CIBlendKernel allocWithZone_(ffi.Pointer<objc.NSZone> zone) {
    final _ret =
        _objc_msgSend_1cwp428(_class_CIBlendKernel, _sel_allocWithZone_, zone);
    return CIBlendKernel.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static CIBlendKernel alloc() {
    final _ret = _objc_msgSend_151sglz(_class_CIBlendKernel, _sel_alloc);
    return CIBlendKernel.castFromPointer(_ret, retain: false, release: true);
  }

  /// self
  CIBlendKernel self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return CIBlendKernel.castFromPointer(_ret, retain: true, release: true);
  }

  /// retain
  CIBlendKernel retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return CIBlendKernel.castFromPointer(_ret, retain: true, release: true);
  }

  /// autorelease
  CIBlendKernel autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return CIBlendKernel.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a new instance of CIBlendKernel constructed with the default `new` method.
  factory CIBlendKernel() => new$();
}

late final _sel_blendKernel = objc.registerName("blendKernel");
late final _sel_setBlendKernel_ = objc.registerName("setBlendKernel:");
late final _sel_blendsInDestinationColorSpace =
    objc.registerName("blendsInDestinationColorSpace");
late final _sel_setBlendsInDestinationColorSpace_ =
    objc.registerName("setBlendsInDestinationColorSpace:");

/// CIRenderDestination
class CIRenderDestination extends objc.NSObject {
  CIRenderDestination._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('CIRenderDestination',
        macOS: (false, (10, 13, 0)));
  }

  /// Constructs a [CIRenderDestination] that points to the same underlying object as [other].
  CIRenderDestination.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [CIRenderDestination] that wraps the given raw object pointer.
  CIRenderDestination.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [CIRenderDestination].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_CIRenderDestination);
  }

  /// initWithPixelBuffer:
  CIRenderDestination initWithPixelBuffer_(
      ffi.Pointer<__CVBuffer> pixelBuffer) {
    objc.checkOsVersionInternal('CIRenderDestination.initWithPixelBuffer:',
        macOS: (false, (10, 13, 0)));
    final _ret = _objc_msgSend_1e00d1f(this.ref.retainAndReturnPointer(),
        _sel_initWithPixelBuffer_, pixelBuffer);
    return CIRenderDestination.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// initWithIOSurface:
  CIRenderDestination initWithIOSurface_(IOSurface surface) {
    objc.checkOsVersionInternal('CIRenderDestination.initWithIOSurface:',
        macOS: (false, (10, 13, 0)));
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithIOSurface_, surface.ref.pointer);
    return CIRenderDestination.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// initWithMTLTexture:commandBuffer:
  CIRenderDestination initWithMTLTexture_commandBuffer_(
      MTLTexture texture, MTLCommandBuffer? commandBuffer) {
    objc.checkOsVersionInternal(
        'CIRenderDestination.initWithMTLTexture:commandBuffer:',
        macOS: (false, (10, 13, 0)));
    final _ret = _objc_msgSend_15qeuct(
        this.ref.retainAndReturnPointer(),
        _sel_initWithMTLTexture_commandBuffer_,
        texture.ref.pointer,
        commandBuffer?.ref.pointer ?? ffi.nullptr);
    return CIRenderDestination.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// initWithWidth:height:pixelFormat:commandBuffer:mtlTextureProvider:
  CIRenderDestination
      initWithWidth_height_pixelFormat_commandBuffer_mtlTextureProvider_(
          int width,
          int height,
          MTLPixelFormat pixelFormat,
          MTLCommandBuffer? commandBuffer,
          objc.ObjCBlock<ffi.Pointer<objc.ObjCObject> Function()>? block) {
    objc.checkOsVersionInternal(
        'CIRenderDestination.initWithWidth:height:pixelFormat:commandBuffer:mtlTextureProvider:',
        macOS: (false, (10, 13, 0)));
    final _ret = _objc_msgSend_8fw814(
        this.ref.retainAndReturnPointer(),
        _sel_initWithWidth_height_pixelFormat_commandBuffer_mtlTextureProvider_,
        width,
        height,
        pixelFormat.value,
        commandBuffer?.ref.pointer ?? ffi.nullptr,
        block?.ref.pointer ?? ffi.nullptr);
    return CIRenderDestination.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// initWithGLTexture:target:width:height:
  CIRenderDestination initWithGLTexture_target_width_height_(
      int texture, int target, int width, int height) {
    objc.checkOsVersionInternal(
        'CIRenderDestination.initWithGLTexture:target:width:height:',
        macOS: (false, (10, 13, 0)));
    final _ret = _objc_msgSend_1ebo5y7(
        this.ref.retainAndReturnPointer(),
        _sel_initWithGLTexture_target_width_height_,
        texture,
        target,
        width,
        height);
    return CIRenderDestination.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// initWithBitmapData:width:height:bytesPerRow:format:
  CIRenderDestination initWithBitmapData_width_height_bytesPerRow_format_(
      ffi.Pointer<ffi.Void> data,
      int width,
      int height,
      int bytesPerRow,
      int format) {
    objc.checkOsVersionInternal(
        'CIRenderDestination.initWithBitmapData:width:height:bytesPerRow:format:',
        macOS: (false, (10, 13, 0)));
    final _ret = _objc_msgSend_1e79x6n(
        this.ref.retainAndReturnPointer(),
        _sel_initWithBitmapData_width_height_bytesPerRow_format_,
        data,
        width,
        height,
        bytesPerRow,
        format);
    return CIRenderDestination.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// width
  int get width {
    objc.checkOsVersionInternal('CIRenderDestination.width',
        macOS: (false, (10, 13, 0)));
    return _objc_msgSend_xw2lbc(this.ref.pointer, _sel_width);
  }

  /// height
  int get height {
    objc.checkOsVersionInternal('CIRenderDestination.height',
        macOS: (false, (10, 13, 0)));
    return _objc_msgSend_xw2lbc(this.ref.pointer, _sel_height);
  }

  /// alphaMode
  CIRenderDestinationAlphaMode get alphaMode {
    objc.checkOsVersionInternal('CIRenderDestination.alphaMode',
        macOS: (false, (10, 13, 0)));
    final _ret = _objc_msgSend_x4izku(this.ref.pointer, _sel_alphaMode);
    return CIRenderDestinationAlphaMode.fromValue(_ret);
  }

  /// setAlphaMode:
  set alphaMode(CIRenderDestinationAlphaMode value) {
    objc.checkOsVersionInternal('CIRenderDestination.setAlphaMode:',
        macOS: (false, (10, 13, 0)));
    _objc_msgSend_1kijgxo(this.ref.pointer, _sel_setAlphaMode_, value.value);
  }

  /// isFlipped
  bool get flipped {
    objc.checkOsVersionInternal('CIRenderDestination.isFlipped',
        macOS: (false, (10, 13, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isFlipped);
  }

  /// setFlipped:
  set flipped(bool value) {
    objc.checkOsVersionInternal('CIRenderDestination.setFlipped:',
        macOS: (false, (10, 13, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setFlipped_, value);
  }

  /// isDithered
  bool get dithered {
    objc.checkOsVersionInternal('CIRenderDestination.isDithered',
        macOS: (false, (10, 13, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isDithered);
  }

  /// setDithered:
  set dithered(bool value) {
    objc.checkOsVersionInternal('CIRenderDestination.setDithered:',
        macOS: (false, (10, 13, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setDithered_, value);
  }

  /// isClamped
  bool get clamped {
    objc.checkOsVersionInternal('CIRenderDestination.isClamped',
        macOS: (false, (10, 13, 0)));
    return _objc_msgSend_91o635(this.ref.pointer, _sel_isClamped);
  }

  /// setClamped:
  set clamped(bool value) {
    objc.checkOsVersionInternal('CIRenderDestination.setClamped:',
        macOS: (false, (10, 13, 0)));
    _objc_msgSend_1s56lr9(this.ref.pointer, _sel_setClamped_, value);
  }

  /// colorSpace
  ffi.Pointer<CGColorSpace> get colorSpace {
    objc.checkOsVersionInternal('CIRenderDestination.colorSpace',
        macOS: (false, (10, 13, 0)));
    return _objc_msgSend_19mkw1n(this.ref.pointer, _sel_colorSpace);
  }

  /// setColorSpace:
  set colorSpace(ffi.Pointer<CGColorSpace> value) {
    objc.checkOsVersionInternal('CIRenderDestination.setColorSpace:',
        macOS: (false, (10, 13, 0)));
    _objc_msgSend_uqbnbf(this.ref.pointer, _sel_setColorSpace_, value);
  }

  /// blendKernel
  CIBlendKernel? get blendKernel {
    objc.checkOsVersionInternal('CIRenderDestination.blendKernel',
        macOS: (false, (10, 13, 0)));
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_blendKernel);
    return _ret.address == 0
        ? null
        : CIBlendKernel.castFromPointer(_ret, retain: true, release: true);
  }

  /// setBlendKernel:
  set blendKernel(CIBlendKernel? value) {
    objc.checkOsVersionInternal('CIRenderDestination.setBlendKernel:',
        macOS: (false, (10, 13, 0)));
    _objc_msgSend_xtuoz7(this.ref.pointer, _sel_setBlendKernel_,
        value?.ref.pointer ?? ffi.nullptr);
  }

  /// blendsInDestinationColorSpace
  bool get blendsInDestinationColorSpace {
    objc.checkOsVersionInternal(
        'CIRenderDestination.blendsInDestinationColorSpace',
        macOS: (false, (10, 13, 0)));
    return _objc_msgSend_91o635(
        this.ref.pointer, _sel_blendsInDestinationColorSpace);
  }

  /// setBlendsInDestinationColorSpace:
  set blendsInDestinationColorSpace(bool value) {
    objc.checkOsVersionInternal(
        'CIRenderDestination.setBlendsInDestinationColorSpace:',
        macOS: (false, (10, 13, 0)));
    _objc_msgSend_1s56lr9(
        this.ref.pointer, _sel_setBlendsInDestinationColorSpace_, value);
  }

  /// init
  CIRenderDestination init() {
    objc.checkOsVersionInternal('CIRenderDestination.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return CIRenderDestination.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// new
  static CIRenderDestination new$() {
    final _ret = _objc_msgSend_151sglz(_class_CIRenderDestination, _sel_new);
    return CIRenderDestination.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// allocWithZone:
  static CIRenderDestination allocWithZone_(ffi.Pointer<objc.NSZone> zone) {
    final _ret = _objc_msgSend_1cwp428(
        _class_CIRenderDestination, _sel_allocWithZone_, zone);
    return CIRenderDestination.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// alloc
  static CIRenderDestination alloc() {
    final _ret = _objc_msgSend_151sglz(_class_CIRenderDestination, _sel_alloc);
    return CIRenderDestination.castFromPointer(_ret,
        retain: false, release: true);
  }

  /// self
  CIRenderDestination self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return CIRenderDestination.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// retain
  CIRenderDestination retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return CIRenderDestination.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// autorelease
  CIRenderDestination autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return CIRenderDestination.castFromPointer(_ret,
        retain: true, release: true);
  }

  /// Returns a new instance of CIRenderDestination constructed with the default `new` method.
  factory CIRenderDestination() => new$();
}

late final _sel_startTaskToRender_fromRect_toDestination_atPoint_error_ = objc
    .registerName("startTaskToRender:fromRect:toDestination:atPoint:error:");
final _objc_msgSend_dn8r7s = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                CGRect,
                ffi.Pointer<objc.ObjCObject>,
                CGPoint,
                ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            CGRect,
            ffi.Pointer<objc.ObjCObject>,
            CGPoint,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>();
late final _sel_startTaskToRender_toDestination_error_ =
    objc.registerName("startTaskToRender:toDestination:error:");
late final _sel_prepareRender_fromRect_toDestination_atPoint_error_ =
    objc.registerName("prepareRender:fromRect:toDestination:atPoint:error:");
final _objc_msgSend_xvqduu = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Bool Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                CGRect,
                ffi.Pointer<objc.ObjCObject>,
                CGPoint,
                ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>>()
    .asFunction<
        bool Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            CGRect,
            ffi.Pointer<objc.ObjCObject>,
            CGPoint,
            ffi.Pointer<ffi.Pointer<objc.ObjCObject>>)>();
late final _sel_startTaskToClear_error_ =
    objc.registerName("startTaskToClear:error:");

/// CIRenderDestination
extension CIRenderDestination$1 on CIContext {
  /// startTaskToRender:fromRect:toDestination:atPoint:error:
  CIRenderTask? startTaskToRender_fromRect_toDestination_atPoint_error_(
      CIImage image,
      CGRect fromRect,
      CIRenderDestination destination,
      CGPoint atPoint,
      ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error) {
    objc.checkOsVersionInternal(
        'CIContext.startTaskToRender:fromRect:toDestination:atPoint:error:',
        macOS: (false, (10, 13, 0)));
    final _ret = _objc_msgSend_dn8r7s(
        this.ref.pointer,
        _sel_startTaskToRender_fromRect_toDestination_atPoint_error_,
        image.ref.pointer,
        fromRect,
        destination.ref.pointer,
        atPoint,
        error);
    return _ret.address == 0
        ? null
        : CIRenderTask.castFromPointer(_ret, retain: true, release: true);
  }

  /// startTaskToRender:toDestination:error:
  CIRenderTask? startTaskToRender_toDestination_error_(
      CIImage image,
      CIRenderDestination destination,
      ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error) {
    objc.checkOsVersionInternal(
        'CIContext.startTaskToRender:toDestination:error:',
        macOS: (false, (10, 13, 0)));
    final _ret = _objc_msgSend_1pnyuds(
        this.ref.pointer,
        _sel_startTaskToRender_toDestination_error_,
        image.ref.pointer,
        destination.ref.pointer,
        error);
    return _ret.address == 0
        ? null
        : CIRenderTask.castFromPointer(_ret, retain: true, release: true);
  }

  /// prepareRender:fromRect:toDestination:atPoint:error:
  bool prepareRender_fromRect_toDestination_atPoint_error_(
      CIImage image,
      CGRect fromRect,
      CIRenderDestination destination,
      CGPoint atPoint,
      ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error) {
    objc.checkOsVersionInternal(
        'CIContext.prepareRender:fromRect:toDestination:atPoint:error:',
        macOS: (false, (10, 13, 0)));
    return _objc_msgSend_xvqduu(
        this.ref.pointer,
        _sel_prepareRender_fromRect_toDestination_atPoint_error_,
        image.ref.pointer,
        fromRect,
        destination.ref.pointer,
        atPoint,
        error);
  }

  /// startTaskToClear:error:
  CIRenderTask? startTaskToClear_error_(CIRenderDestination destination,
      ffi.Pointer<ffi.Pointer<objc.ObjCObject>> error) {
    objc.checkOsVersionInternal('CIContext.startTaskToClear:error:',
        macOS: (false, (10, 13, 0)));
    final _ret = _objc_msgSend_1lhpu4m(this.ref.pointer,
        _sel_startTaskToClear_error_, destination.ref.pointer, error);
    return _ret.address == 0
        ? null
        : CIRenderTask.castFromPointer(_ret, retain: true, release: true);
  }
}

late final _sel_contextWithCGLContext_pixelFormat_colorSpace_options_ =
    objc.registerName("contextWithCGLContext:pixelFormat:colorSpace:options:");
final _objc_msgSend_d3q2kp = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<_CGLContextObject>,
                ffi.Pointer<_CGLPixelFormatObject>,
                ffi.Pointer<CGColorSpace>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<_CGLContextObject>,
            ffi.Pointer<_CGLPixelFormatObject>,
            ffi.Pointer<CGColorSpace>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_contextWithCGLContext_pixelFormat_options_ =
    objc.registerName("contextWithCGLContext:pixelFormat:options:");
final _objc_msgSend_1c0v1cr = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<_CGLContextObject>,
                ffi.Pointer<_CGLPixelFormatObject>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<_CGLContextObject>,
            ffi.Pointer<_CGLPixelFormatObject>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_contextWithCGContext_options_ =
    objc.registerName("contextWithCGContext:options:");
final _objc_msgSend_1tjcpid = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<CGContext>,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<CGContext>,
            ffi.Pointer<objc.ObjCObject>)>();
late final _sel_contextWithOptions_ = objc.registerName("contextWithOptions:");
late final _sel_context = objc.registerName("context");
late final _sel_initWithOptions_ = objc.registerName("initWithOptions:");
late final _protocol_MTLDevice = objc.getProtocol("MTLDevice");

/// MTLDevice
interface class MTLDevice extends objc.ObjCProtocolBase {
  MTLDevice._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [MTLDevice] that points to the same underlying object as [other].
  MTLDevice.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MTLDevice] that wraps the given raw object pointer.
  MTLDevice.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MTLDevice].
  static bool conformsTo(objc.ObjCObjectBase obj) {
    return _objc_msgSend_e3qsqz(
        obj.ref.pointer, _sel_conformsToProtocol_, _protocol_MTLDevice);
  }

  /// Returns the [objc.Protocol] object for this protocol.
  static objc.Protocol get $protocol =>
      objc.Protocol.castFromPointer(_protocol_MTLDevice.cast());

  /// Builds an object that implements the MTLDevice protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static MTLDevice implement({bool $keepIsolateAlive = true}) {
    final builder = objc.ObjCProtocolBuilder(debugName: 'MTLDevice');

    builder.addProtocol($protocol);
    return MTLDevice.castFrom(
        builder.build(keepIsolateAlive: $keepIsolateAlive));
  }

  /// Adds the implementation of the MTLDevice protocol to an existing
  /// [objc.ObjCProtocolBuilder].
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilder(objc.ObjCProtocolBuilder builder,
      {bool $keepIsolateAlive = true}) {
    builder.addProtocol($protocol);
  }
}

late final _sel_contextWithMTLDevice_ =
    objc.registerName("contextWithMTLDevice:");
late final _sel_contextWithMTLDevice_options_ =
    objc.registerName("contextWithMTLDevice:options:");
late final _protocol_MTLCommandQueue = objc.getProtocol("MTLCommandQueue");

/// MTLCommandQueue
interface class MTLCommandQueue extends objc.ObjCProtocolBase {
  MTLCommandQueue._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [MTLCommandQueue] that points to the same underlying object as [other].
  MTLCommandQueue.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [MTLCommandQueue] that wraps the given raw object pointer.
  MTLCommandQueue.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [MTLCommandQueue].
  static bool conformsTo(objc.ObjCObjectBase obj) {
    return _objc_msgSend_e3qsqz(
        obj.ref.pointer, _sel_conformsToProtocol_, _protocol_MTLCommandQueue);
  }

  /// Returns the [objc.Protocol] object for this protocol.
  static objc.Protocol get $protocol =>
      objc.Protocol.castFromPointer(_protocol_MTLCommandQueue.cast());

  /// Builds an object that implements the MTLCommandQueue protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static MTLCommandQueue implement({bool $keepIsolateAlive = true}) {
    final builder = objc.ObjCProtocolBuilder(debugName: 'MTLCommandQueue');

    builder.addProtocol($protocol);
    return MTLCommandQueue.castFrom(
        builder.build(keepIsolateAlive: $keepIsolateAlive));
  }

  /// Adds the implementation of the MTLCommandQueue protocol to an existing
  /// [objc.ObjCProtocolBuilder].
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilder(objc.ObjCProtocolBuilder builder,
      {bool $keepIsolateAlive = true}) {
    builder.addProtocol($protocol);
  }
}

late final _sel_contextWithMTLCommandQueue_ =
    objc.registerName("contextWithMTLCommandQueue:");
late final _sel_contextWithMTLCommandQueue_options_ =
    objc.registerName("contextWithMTLCommandQueue:options:");
late final _sel_workingColorSpace = objc.registerName("workingColorSpace");
late final _sel_workingFormat = objc.registerName("workingFormat");
final _objc_msgSend_13yqbb6 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Int Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        int Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_drawImage_atPoint_fromRect_ =
    objc.registerName("drawImage:atPoint:fromRect:");
final _objc_msgSend_qws559 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                CGPoint,
                CGRect)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            CGPoint,
            CGRect)>();
late final _sel_drawImage_inRect_fromRect_ =
    objc.registerName("drawImage:inRect:fromRect:");
final _objc_msgSend_15pistd = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                CGRect,
                CGRect)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            CGRect,
            CGRect)>();
late final _sel_createCGLayerWithSize_info_ =
    objc.registerName("createCGLayerWithSize:info:");
final _objc_msgSend_v6vpm1 = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Pointer<CGLayer> Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                CGSize,
                ffi.Pointer<__CFDictionary>)>>()
    .asFunction<
        ffi.Pointer<CGLayer> Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            CGSize,
            ffi.Pointer<__CFDictionary>)>();
late final _sel_render_toBitmap_rowBytes_bounds_format_colorSpace_ =
    objc.registerName("render:toBitmap:rowBytes:bounds:format:colorSpace:");
final _objc_msgSend_1yanhgf = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<ffi.Void>,
                ffi.Long,
                CGRect,
                ffi.Int,
                ffi.Pointer<CGColorSpace>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<ffi.Void>,
            int,
            CGRect,
            int,
            ffi.Pointer<CGColorSpace>)>();
late final _sel_render_toIOSurface_bounds_colorSpace_ =
    objc.registerName("render:toIOSurface:bounds:colorSpace:");
final _objc_msgSend_1lc4r2i = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<__IOSurface>,
                CGRect,
                ffi.Pointer<CGColorSpace>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<__IOSurface>,
            CGRect,
            ffi.Pointer<CGColorSpace>)>();
late final _sel_render_toCVPixelBuffer_ =
    objc.registerName("render:toCVPixelBuffer:");
final _objc_msgSend_1694vex = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<__CVBuffer>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<__CVBuffer>)>();
late final _sel_render_toCVPixelBuffer_bounds_colorSpace_ =
    objc.registerName("render:toCVPixelBuffer:bounds:colorSpace:");
final _objc_msgSend_74fsgu = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<__CVBuffer>,
                CGRect,
                ffi.Pointer<CGColorSpace>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<__CVBuffer>,
            CGRect,
            ffi.Pointer<CGColorSpace>)>();
late final _sel_render_toMTLTexture_commandBuffer_bounds_colorSpace_ =
    objc.registerName("render:toMTLTexture:commandBuffer:bounds:colorSpace:");
final _objc_msgSend_1hst2tk = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCObject>,
                CGRect,
                ffi.Pointer<CGColorSpace>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCObject>,
            CGRect,
            ffi.Pointer<CGColorSpace>)>();
late final _sel_reclaimResources = objc.registerName("reclaimResources");
late final _sel_clearCaches = objc.registerName("clearCaches");
late final _sel_inputImageMaximumSize =
    objc.registerName("inputImageMaximumSize");
final _objc_msgSend_1vdfken = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            CGSize Function(ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        CGSize Function(
            ffi.Pointer<objc.ObjCObject>, ffi.Pointer<objc.ObjCSelector>)>();
final _objc_msgSend_1vdfkenStret = objc.msgSendStretPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(ffi.Pointer<CGSize>, ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<
        void Function(ffi.Pointer<CGSize>, ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_outputImageMaximumSize =
    objc.registerName("outputImageMaximumSize");

/// CIContext
class CIContext extends objc.NSObject {
  CIContext._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super.castFromPointer(pointer, retain: retain, release: release) {
    objc.checkOsVersionInternal('CIContext', macOS: (false, (10, 4, 0)));
  }

  /// Constructs a [CIContext] that points to the same underlying object as [other].
  CIContext.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [CIContext] that wraps the given raw object pointer.
  CIContext.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [CIContext].
  static bool isInstance(objc.ObjCObjectBase obj) {
    return _objc_msgSend_19nvye5(
        obj.ref.pointer, _sel_isKindOfClass_, _class_CIContext);
  }

  /// contextWithCGLContext:pixelFormat:colorSpace:options:
  static CIContext contextWithCGLContext_pixelFormat_colorSpace_options_(
      ffi.Pointer<_CGLContextObject> cglctx,
      ffi.Pointer<_CGLPixelFormatObject> pixelFormat,
      ffi.Pointer<CGColorSpace> colorSpace,
      objc.NSDictionary? options) {
    objc.checkOsVersionInternal(
        'CIContext.contextWithCGLContext:pixelFormat:colorSpace:options:',
        macOS: (false, (10, 6, 0)));
    final _ret = _objc_msgSend_d3q2kp(
        _class_CIContext,
        _sel_contextWithCGLContext_pixelFormat_colorSpace_options_,
        cglctx,
        pixelFormat,
        colorSpace,
        options?.ref.pointer ?? ffi.nullptr);
    return CIContext.castFromPointer(_ret, retain: true, release: true);
  }

  /// contextWithCGLContext:pixelFormat:options:
  static CIContext contextWithCGLContext_pixelFormat_options_(
      ffi.Pointer<_CGLContextObject> cglctx,
      ffi.Pointer<_CGLPixelFormatObject> pixelFormat,
      objc.NSDictionary? options) {
    objc.checkOsVersionInternal(
        'CIContext.contextWithCGLContext:pixelFormat:options:',
        macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_1c0v1cr(
        _class_CIContext,
        _sel_contextWithCGLContext_pixelFormat_options_,
        cglctx,
        pixelFormat,
        options?.ref.pointer ?? ffi.nullptr);
    return CIContext.castFromPointer(_ret, retain: true, release: true);
  }

  /// contextWithCGContext:options:
  static CIContext contextWithCGContext_options_(
      ffi.Pointer<CGContext> cgctx, objc.NSDictionary? options) {
    objc.checkOsVersionInternal('CIContext.contextWithCGContext:options:',
        macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_1tjcpid(
        _class_CIContext,
        _sel_contextWithCGContext_options_,
        cgctx,
        options?.ref.pointer ?? ffi.nullptr);
    return CIContext.castFromPointer(_ret, retain: true, release: true);
  }

  /// contextWithOptions:
  static CIContext contextWithOptions_(objc.NSDictionary? options) {
    objc.checkOsVersionInternal('CIContext.contextWithOptions:',
        macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_1sotr3r(_class_CIContext,
        _sel_contextWithOptions_, options?.ref.pointer ?? ffi.nullptr);
    return CIContext.castFromPointer(_ret, retain: true, release: true);
  }

  /// context
  static CIContext context() {
    objc.checkOsVersionInternal('CIContext.context',
        macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_151sglz(_class_CIContext, _sel_context);
    return CIContext.castFromPointer(_ret, retain: true, release: true);
  }

  /// initWithOptions:
  CIContext initWithOptions_(objc.NSDictionary? options) {
    objc.checkOsVersionInternal('CIContext.initWithOptions:',
        macOS: (false, (10, 4, 0)));
    final _ret = _objc_msgSend_1sotr3r(this.ref.retainAndReturnPointer(),
        _sel_initWithOptions_, options?.ref.pointer ?? ffi.nullptr);
    return CIContext.castFromPointer(_ret, retain: false, release: true);
  }

  /// init
  CIContext init() {
    objc.checkOsVersionInternal('CIContext.init',
        iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final _ret =
        _objc_msgSend_151sglz(this.ref.retainAndReturnPointer(), _sel_init);
    return CIContext.castFromPointer(_ret, retain: false, release: true);
  }

  /// contextWithMTLDevice:
  static CIContext contextWithMTLDevice_(MTLDevice device) {
    objc.checkOsVersionInternal('CIContext.contextWithMTLDevice:',
        macOS: (false, (10, 11, 0)));
    final _ret = _objc_msgSend_1sotr3r(
        _class_CIContext, _sel_contextWithMTLDevice_, device.ref.pointer);
    return CIContext.castFromPointer(_ret, retain: true, release: true);
  }

  /// contextWithMTLDevice:options:
  static CIContext contextWithMTLDevice_options_(
      MTLDevice device, objc.NSDictionary? options) {
    objc.checkOsVersionInternal('CIContext.contextWithMTLDevice:options:',
        macOS: (false, (10, 11, 0)));
    final _ret = _objc_msgSend_15qeuct(
        _class_CIContext,
        _sel_contextWithMTLDevice_options_,
        device.ref.pointer,
        options?.ref.pointer ?? ffi.nullptr);
    return CIContext.castFromPointer(_ret, retain: true, release: true);
  }

  /// contextWithMTLCommandQueue:
  static CIContext contextWithMTLCommandQueue_(MTLCommandQueue commandQueue) {
    objc.checkOsVersionInternal('CIContext.contextWithMTLCommandQueue:',
        macOS: (false, (10, 15, 0)));
    final _ret = _objc_msgSend_1sotr3r(_class_CIContext,
        _sel_contextWithMTLCommandQueue_, commandQueue.ref.pointer);
    return CIContext.castFromPointer(_ret, retain: true, release: true);
  }

  /// contextWithMTLCommandQueue:options:
  static CIContext contextWithMTLCommandQueue_options_(
      MTLCommandQueue commandQueue, objc.NSDictionary? options) {
    objc.checkOsVersionInternal('CIContext.contextWithMTLCommandQueue:options:',
        macOS: (false, (10, 15, 0)));
    final _ret = _objc_msgSend_15qeuct(
        _class_CIContext,
        _sel_contextWithMTLCommandQueue_options_,
        commandQueue.ref.pointer,
        options?.ref.pointer ?? ffi.nullptr);
    return CIContext.castFromPointer(_ret, retain: true, release: true);
  }

  /// workingColorSpace
  ffi.Pointer<CGColorSpace> get workingColorSpace {
    objc.checkOsVersionInternal('CIContext.workingColorSpace',
        macOS: (false, (10, 11, 0)));
    return _objc_msgSend_19mkw1n(this.ref.pointer, _sel_workingColorSpace);
  }

  /// workingFormat
  int get workingFormat {
    objc.checkOsVersionInternal('CIContext.workingFormat',
        macOS: (false, (10, 11, 0)));
    return _objc_msgSend_13yqbb6(this.ref.pointer, _sel_workingFormat);
  }

  /// drawImage:atPoint:fromRect:
  void drawImage_atPoint_fromRect_(
      CIImage image, CGPoint atPoint, CGRect fromRect) {
    objc.checkOsVersionInternal('CIContext.drawImage:atPoint:fromRect:',
        macOS: (false, (10, 4, 0)));
    _objc_msgSend_qws559(this.ref.pointer, _sel_drawImage_atPoint_fromRect_,
        image.ref.pointer, atPoint, fromRect);
  }

  /// drawImage:inRect:fromRect:
  void drawImage_inRect_fromRect_(
      CIImage image, CGRect inRect, CGRect fromRect) {
    objc.checkOsVersionInternal('CIContext.drawImage:inRect:fromRect:',
        macOS: (false, (10, 4, 0)));
    _objc_msgSend_15pistd(this.ref.pointer, _sel_drawImage_inRect_fromRect_,
        image.ref.pointer, inRect, fromRect);
  }

  /// createCGLayerWithSize:info:
  ffi.Pointer<CGLayer> createCGLayerWithSize_info_(
      CGSize size, ffi.Pointer<__CFDictionary> info) {
    objc.checkOsVersionInternal('CIContext.createCGLayerWithSize:info:',
        macOS: (false, (10, 4, 0)));
    return _objc_msgSend_v6vpm1(
        this.ref.pointer, _sel_createCGLayerWithSize_info_, size, info);
  }

  /// render:toBitmap:rowBytes:bounds:format:colorSpace:
  void render_toBitmap_rowBytes_bounds_format_colorSpace_(
      CIImage image,
      ffi.Pointer<ffi.Void> data,
      int rowBytes,
      CGRect bounds,
      int format,
      ffi.Pointer<CGColorSpace> colorSpace) {
    objc.checkOsVersionInternal(
        'CIContext.render:toBitmap:rowBytes:bounds:format:colorSpace:',
        macOS: (false, (10, 4, 0)));
    _objc_msgSend_1yanhgf(
        this.ref.pointer,
        _sel_render_toBitmap_rowBytes_bounds_format_colorSpace_,
        image.ref.pointer,
        data,
        rowBytes,
        bounds,
        format,
        colorSpace);
  }

  /// render:toIOSurface:bounds:colorSpace:
  void render_toIOSurface_bounds_colorSpace_(
      CIImage image,
      ffi.Pointer<__IOSurface> surface,
      CGRect bounds,
      ffi.Pointer<CGColorSpace> colorSpace) {
    objc.checkOsVersionInternal(
        'CIContext.render:toIOSurface:bounds:colorSpace:',
        macOS: (false, (10, 6, 0)));
    _objc_msgSend_1lc4r2i(
        this.ref.pointer,
        _sel_render_toIOSurface_bounds_colorSpace_,
        image.ref.pointer,
        surface,
        bounds,
        colorSpace);
  }

  /// render:toCVPixelBuffer:
  void render_toCVPixelBuffer_(CIImage image, ffi.Pointer<__CVBuffer> buffer) {
    objc.checkOsVersionInternal('CIContext.render:toCVPixelBuffer:',
        macOS: (false, (10, 11, 0)));
    _objc_msgSend_1694vex(this.ref.pointer, _sel_render_toCVPixelBuffer_,
        image.ref.pointer, buffer);
  }

  /// render:toCVPixelBuffer:bounds:colorSpace:
  void render_toCVPixelBuffer_bounds_colorSpace_(
      CIImage image,
      ffi.Pointer<__CVBuffer> buffer,
      CGRect bounds,
      ffi.Pointer<CGColorSpace> colorSpace) {
    objc.checkOsVersionInternal(
        'CIContext.render:toCVPixelBuffer:bounds:colorSpace:',
        macOS: (false, (10, 11, 0)));
    _objc_msgSend_74fsgu(
        this.ref.pointer,
        _sel_render_toCVPixelBuffer_bounds_colorSpace_,
        image.ref.pointer,
        buffer,
        bounds,
        colorSpace);
  }

  /// render:toMTLTexture:commandBuffer:bounds:colorSpace:
  void render_toMTLTexture_commandBuffer_bounds_colorSpace_(
      CIImage image,
      MTLTexture texture,
      MTLCommandBuffer? commandBuffer,
      CGRect bounds,
      ffi.Pointer<CGColorSpace> colorSpace) {
    objc.checkOsVersionInternal(
        'CIContext.render:toMTLTexture:commandBuffer:bounds:colorSpace:',
        macOS: (false, (10, 11, 0)));
    _objc_msgSend_1hst2tk(
        this.ref.pointer,
        _sel_render_toMTLTexture_commandBuffer_bounds_colorSpace_,
        image.ref.pointer,
        texture.ref.pointer,
        commandBuffer?.ref.pointer ?? ffi.nullptr,
        bounds,
        colorSpace);
  }

  /// reclaimResources
  void reclaimResources() {
    objc.checkOsVersionInternal('CIContext.reclaimResources',
        macOS: (false, (10, 4, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_reclaimResources);
  }

  /// clearCaches
  void clearCaches() {
    objc.checkOsVersionInternal('CIContext.clearCaches',
        macOS: (false, (10, 4, 0)));
    _objc_msgSend_1pl9qdv(this.ref.pointer, _sel_clearCaches);
  }

  /// inputImageMaximumSize
  CGSize inputImageMaximumSize() {
    objc.checkOsVersionInternal('CIContext.inputImageMaximumSize',
        macOS: (true, null));
    final _ptr = pkg_ffi.calloc<CGSize>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1vdfkenStret(
            _ptr, this.ref.pointer, _sel_inputImageMaximumSize)
        : _ptr.ref =
            _objc_msgSend_1vdfken(this.ref.pointer, _sel_inputImageMaximumSize);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<CGSize>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<CGSize>(_finalizable);
  }

  /// outputImageMaximumSize
  CGSize outputImageMaximumSize() {
    objc.checkOsVersionInternal('CIContext.outputImageMaximumSize',
        macOS: (true, null));
    final _ptr = pkg_ffi.calloc<CGSize>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1vdfkenStret(
            _ptr, this.ref.pointer, _sel_outputImageMaximumSize)
        : _ptr.ref = _objc_msgSend_1vdfken(
            this.ref.pointer, _sel_outputImageMaximumSize);
    final _finalizable = _ptr.cast<ffi.Uint8>().asTypedList(
        ffi.sizeOf<CGSize>(),
        finalizer: pkg_ffi.calloc.nativeFree);
    return ffi.Struct.create<CGSize>(_finalizable);
  }

  /// new
  static CIContext new$() {
    final _ret = _objc_msgSend_151sglz(_class_CIContext, _sel_new);
    return CIContext.castFromPointer(_ret, retain: false, release: true);
  }

  /// allocWithZone:
  static CIContext allocWithZone_(ffi.Pointer<objc.NSZone> zone) {
    final _ret =
        _objc_msgSend_1cwp428(_class_CIContext, _sel_allocWithZone_, zone);
    return CIContext.castFromPointer(_ret, retain: false, release: true);
  }

  /// alloc
  static CIContext alloc() {
    final _ret = _objc_msgSend_151sglz(_class_CIContext, _sel_alloc);
    return CIContext.castFromPointer(_ret, retain: false, release: true);
  }

  /// self
  CIContext self$1() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_self);
    return CIContext.castFromPointer(_ret, retain: true, release: true);
  }

  /// retain
  CIContext retain() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_retain);
    return CIContext.castFromPointer(_ret, retain: true, release: true);
  }

  /// autorelease
  CIContext autorelease() {
    final _ret = _objc_msgSend_151sglz(this.ref.pointer, _sel_autorelease);
    return CIContext.castFromPointer(_ret, retain: true, release: true);
  }

  /// Returns a new instance of CIContext constructed with the default `new` method.
  factory CIContext() => new$();
}

late final _protocol_CIFilter = objc.getProtocol("CIFilter");
ffi.Pointer<objc.ObjCObject> _ObjCBlock_CIImage_ffiVoid_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<ffi.Void> arg0)>>()
        .asFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_CIImage_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_CIImage_ffiVoid_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject> _ObjCBlock_CIImage_ffiVoid_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_CIImage_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_CIImage_ffiVoid_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<CIImage? Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_CIImage_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<CIImage? Function(ffi.Pointer<ffi.Void>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<CIImage? Function(ffi.Pointer<ffi.Void>)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<CIImage? Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Pointer<objc.ObjCObject> Function(
                          ffi.Pointer<ffi.Void> arg0)>>
              ptr) =>
      objc.ObjCBlock<CIImage? Function(ffi.Pointer<ffi.Void>)>(
          objc.newPointerBlock(
              _ObjCBlock_CIImage_ffiVoid_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<CIImage? Function(ffi.Pointer<ffi.Void>)> fromFunction(
          CIImage? Function(ffi.Pointer<ffi.Void>) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<CIImage? Function(ffi.Pointer<ffi.Void>)>(
          objc.newClosureBlock(
              _ObjCBlock_CIImage_ffiVoid_closureCallable,
              (ffi.Pointer<ffi.Void> arg0) =>
                  fn(arg0)?.ref.retainAndAutorelease() ?? ffi.nullptr,
              keepIsolateAlive),
          retain: false,
          release: true);
}

/// Call operator for `objc.ObjCBlock<CIImage? Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_CIImage_ffiVoid_CallExtension
    on objc.ObjCBlock<CIImage? Function(ffi.Pointer<ffi.Void>)> {
  CIImage? call(ffi.Pointer<ffi.Void> arg0) => ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Pointer<objc.ObjCObject> Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0)>>()
              .asFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                      ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>()
              (ref.pointer, arg0)
              .address ==
          0
      ? null
      : CIImage.castFromPointer(
          ref.pointer.ref.invoke
              .cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)>>()
              .asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0),
          retain: true,
          release: true);
}

/// CIFilter
interface class CIFilter$1 extends objc.ObjCProtocolBase {
  CIFilter$1._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [CIFilter$1] that points to the same underlying object as [other].
  CIFilter$1.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [CIFilter$1] that wraps the given raw object pointer.
  CIFilter$1.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [CIFilter$1].
  static bool conformsTo(objc.ObjCObjectBase obj) {
    return _objc_msgSend_e3qsqz(
        obj.ref.pointer, _sel_conformsToProtocol_, _protocol_CIFilter);
  }

  /// Returns the [objc.Protocol] object for this protocol.
  static objc.Protocol get $protocol =>
      objc.Protocol.castFromPointer(_protocol_CIFilter.cast());

  /// Builds an object that implements the CIFilter protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static CIFilter$1 implement(
      {required CIImage? Function() outputImage,
      bool $keepIsolateAlive = true}) {
    final builder = objc.ObjCProtocolBuilder(debugName: 'CIFilter');
    CIFilter$1.outputImage.implement(builder, outputImage);
    builder.addProtocol($protocol);
    return CIFilter$1.castFrom(
        builder.build(keepIsolateAlive: $keepIsolateAlive));
  }

  /// Adds the implementation of the CIFilter protocol to an existing
  /// [objc.ObjCProtocolBuilder].
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilder(objc.ObjCProtocolBuilder builder,
      {required CIImage? Function() outputImage,
      bool $keepIsolateAlive = true}) {
    CIFilter$1.outputImage.implement(builder, outputImage);
    builder.addProtocol($protocol);
  }

  /// outputImage
  static final outputImage = objc.ObjCProtocolMethod<CIImage? Function()>(
    _protocol_CIFilter,
    _sel_outputImage,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Pointer<objc.ObjCObject> Function(
                        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>>(
            _CoreImageBindings_protocolTrampoline_1mbt9g9)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_CIFilter,
      _sel_outputImage,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (CIImage? Function() func) => ObjCBlock_CIImage_ffiVoid.fromFunction((
      ffi.Pointer<ffi.Void> _,
    ) =>
        func()),
  );
}

late final _class_NSObject = objc.getClass("NSObject");
late final _sel_provideImageData_bytesPerRow_origin__size__userInfo_ =
    objc.registerName("provideImageData:bytesPerRow:origin::size::userInfo:");
final _objc_msgSend_haq63t = objc.msgSendPointer
    .cast<
        ffi.NativeFunction<
            ffi.Void Function(
                ffi.Pointer<objc.ObjCObject>,
                ffi.Pointer<objc.ObjCSelector>,
                ffi.Pointer<ffi.Void>,
                ffi.Size,
                ffi.Size,
                ffi.Size,
                ffi.Size,
                ffi.Size,
                ffi.Pointer<objc.ObjCObject>)>>()
    .asFunction<
        void Function(
            ffi.Pointer<objc.ObjCObject>,
            ffi.Pointer<objc.ObjCSelector>,
            ffi.Pointer<ffi.Void>,
            int,
            int,
            int,
            int,
            int,
            ffi.Pointer<objc.ObjCObject>)>();

/// CIImageProvider
extension CIImageProvider$1 on objc.NSObject {
  /// provideImageData:bytesPerRow:origin::size::userInfo:
  void provideImageData_bytesPerRow_origin__size__userInfo_(
      ffi.Pointer<ffi.Void> data,
      int rowbytes,
      int x,
      int y,
      int width,
      int height,
      objc.ObjCObjectBase? info) {
    objc.checkOsVersionInternal(
        'NSObject.provideImageData:bytesPerRow:origin::size::userInfo:',
        iOS: (false, (2, 0, 0)),
        macOS: (false, (10, 0, 0)));
    _objc_msgSend_haq63t(
        this.ref.pointer,
        _sel_provideImageData_bytesPerRow_origin__size__userInfo_,
        data,
        rowbytes,
        x,
        y,
        width,
        height,
        info?.ref.pointer ?? ffi.nullptr);
  }
}

late final _protocol_CIImageProcessorInput =
    objc.getProtocol("CIImageProcessorInput");
late final _sel_region = objc.registerName("region");
CGRect _ObjCBlock_CGRect_ffiVoid_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    block.ref.target
        .cast<ffi.NativeFunction<CGRect Function(ffi.Pointer<ffi.Void> arg0)>>()
        .asFunction<CGRect Function(ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_CGRect_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<
                CGRect Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_CGRect_ffiVoid_fnPtrTrampoline)
        .cast();
CGRect _ObjCBlock_CGRect_ffiVoid_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    (objc.getBlockClosure(block) as CGRect Function(
        ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_CGRect_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<
                CGRect Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_CGRect_ffiVoid_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<CGRect Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_CGRect_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<CGRect Function(ffi.Pointer<ffi.Void>)> castFromPointer(
          ffi.Pointer<objc.ObjCBlockImpl> pointer,
          {bool retain = false,
          bool release = false}) =>
      objc.ObjCBlock<CGRect Function(ffi.Pointer<ffi.Void>)>(pointer,
          retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<CGRect Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(
          ffi.Pointer<
                  ffi
                  .NativeFunction<CGRect Function(ffi.Pointer<ffi.Void> arg0)>>
              ptr) =>
      objc.ObjCBlock<CGRect Function(ffi.Pointer<ffi.Void>)>(
          objc.newPointerBlock(
              _ObjCBlock_CGRect_ffiVoid_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<CGRect Function(ffi.Pointer<ffi.Void>)> fromFunction(
          CGRect Function(ffi.Pointer<ffi.Void>) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<CGRect Function(ffi.Pointer<ffi.Void>)>(
          objc.newClosureBlock(_ObjCBlock_CGRect_ffiVoid_closureCallable,
              (ffi.Pointer<ffi.Void> arg0) => fn(arg0), keepIsolateAlive),
          retain: false,
          release: true);
}

/// Call operator for `objc.ObjCBlock<CGRect Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_CGRect_ffiVoid_CallExtension
    on objc.ObjCBlock<CGRect Function(ffi.Pointer<ffi.Void>)> {
  CGRect call(ffi.Pointer<ffi.Void> arg0) => ref.pointer.ref.invoke
      .cast<
          ffi.NativeFunction<
              CGRect Function(ffi.Pointer<objc.ObjCBlockImpl> block,
                  ffi.Pointer<ffi.Void> arg0)>>()
      .asFunction<
          CGRect Function(ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0);
}

int _ObjCBlock_ffiSize_ffiVoid_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.Void> arg0)>>()
        .asFunction<int Function(ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiSize_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Size Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_ffiSize_ffiVoid_fnPtrTrampoline, 0)
        .cast();
int _ObjCBlock_ffiSize_ffiVoid_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    (objc.getBlockClosure(block) as int Function(ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_ffiSize_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Size Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_ffiSize_ffiVoid_closureTrampoline, 0)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Size Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_ffiSize_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Size Function(ffi.Pointer<ffi.Void>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<ffi.Size Function(ffi.Pointer<ffi.Void>)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Size Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Size Function(ffi.Pointer<ffi.Void> arg0)>>
              ptr) =>
      objc.ObjCBlock<ffi.Size Function(ffi.Pointer<ffi.Void>)>(
          objc.newPointerBlock(
              _ObjCBlock_ffiSize_ffiVoid_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Size Function(ffi.Pointer<ffi.Void>)> fromFunction(
          int Function(ffi.Pointer<ffi.Void>) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Size Function(ffi.Pointer<ffi.Void>)>(
          objc.newClosureBlock(_ObjCBlock_ffiSize_ffiVoid_closureCallable,
              (ffi.Pointer<ffi.Void> arg0) => fn(arg0), keepIsolateAlive),
          retain: false,
          release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.Size Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_ffiSize_ffiVoid_CallExtension
    on objc.ObjCBlock<ffi.Size Function(ffi.Pointer<ffi.Void>)> {
  int call(ffi.Pointer<ffi.Void> arg0) => ref.pointer.ref.invoke
      .cast<
          ffi.NativeFunction<
              ffi.Size Function(ffi.Pointer<objc.ObjCBlockImpl> block,
                  ffi.Pointer<ffi.Void> arg0)>>()
      .asFunction<
          int Function(ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0);
}

late final _sel_format = objc.registerName("format");
int _ObjCBlock_CIFormat_ffiVoid_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Void> arg0)>>()
        .asFunction<int Function(ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_CIFormat_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Int Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_CIFormat_ffiVoid_fnPtrTrampoline, 0)
        .cast();
int _ObjCBlock_CIFormat_ffiVoid_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    (objc.getBlockClosure(block) as int Function(ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_CIFormat_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Int Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_CIFormat_ffiVoid_closureTrampoline, 0)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Int Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_CIFormat_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Int Function(ffi.Pointer<ffi.Void>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<ffi.Int Function(ffi.Pointer<ffi.Void>)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Int Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(
          ffi.Pointer<
                  ffi
                  .NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Void> arg0)>>
              ptr) =>
      objc.ObjCBlock<ffi.Int Function(ffi.Pointer<ffi.Void>)>(
          objc.newPointerBlock(
              _ObjCBlock_CIFormat_ffiVoid_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Int Function(ffi.Pointer<ffi.Void>)> fromFunction(
          int Function(ffi.Pointer<ffi.Void>) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Int Function(ffi.Pointer<ffi.Void>)>(
          objc.newClosureBlock(_ObjCBlock_CIFormat_ffiVoid_closureCallable,
              (ffi.Pointer<ffi.Void> arg0) => fn(arg0), keepIsolateAlive),
          retain: false,
          release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.Int Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_CIFormat_ffiVoid_CallExtension
    on objc.ObjCBlock<ffi.Int Function(ffi.Pointer<ffi.Void>)> {
  int call(ffi.Pointer<ffi.Void> arg0) => ref.pointer.ref.invoke
      .cast<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<objc.ObjCBlockImpl> block,
                  ffi.Pointer<ffi.Void> arg0)>>()
      .asFunction<
          int Function(ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0);
}

ffi.Pointer<ffi.Void> _ObjCBlock_CFTypeRef_CFTypeRef_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void> arg0)>>()
        .asFunction<
            ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_CFTypeRef_CFTypeRef_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<ffi.Void> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_CFTypeRef_CFTypeRef_fnPtrTrampoline)
        .cast();
ffi.Pointer<ffi.Void> _ObjCBlock_CFTypeRef_CFTypeRef_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    (objc.getBlockClosure(block) as ffi.Pointer<ffi.Void> Function(
        ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_CFTypeRef_CFTypeRef_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<ffi.Void> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_CFTypeRef_CFTypeRef_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_CFTypeRef_CFTypeRef {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>(
              pointer,
              retain: retain,
              release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>
      fromFunctionPointer(
              ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.Pointer<ffi.Void> Function(
                              ffi.Pointer<ffi.Void> arg0)>>
                  ptr) =>
          objc.ObjCBlock<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>(
              objc.newPointerBlock(_ObjCBlock_CFTypeRef_CFTypeRef_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>
      fromFunction(ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>(
              objc.newClosureBlock(
                  _ObjCBlock_CFTypeRef_CFTypeRef_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0) => fn(arg0),
                  keepIsolateAlive),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_CFTypeRef_CFTypeRef_CallExtension
    on objc.ObjCBlock<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)> {
  ffi.Pointer<ffi.Void> call(ffi.Pointer<ffi.Void> arg0) =>
      ref.pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Pointer<ffi.Void> Function(
                      ffi.Pointer<objc.ObjCBlockImpl> block,
                      ffi.Pointer<ffi.Void> arg0)>>()
          .asFunction<
              ffi.Pointer<ffi.Void> Function(ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0);
}

late final _sel_surface = objc.registerName("surface");
ffi.Pointer<__IOSurface> _ObjCBlock_IOSurfaceRef_ffiVoid_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Pointer<__IOSurface> Function(
                    ffi.Pointer<ffi.Void> arg0)>>()
        .asFunction<
            ffi.Pointer<__IOSurface> Function(ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_IOSurfaceRef_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<__IOSurface> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_IOSurfaceRef_ffiVoid_fnPtrTrampoline)
        .cast();
ffi.Pointer<__IOSurface> _ObjCBlock_IOSurfaceRef_ffiVoid_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    (objc.getBlockClosure(block) as ffi.Pointer<__IOSurface> Function(
        ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_IOSurfaceRef_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<__IOSurface> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_IOSurfaceRef_ffiVoid_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<__IOSurface> Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_IOSurfaceRef_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
      ffi.Pointer<__IOSurface> Function(ffi.Pointer<ffi.Void>)> castFromPointer(
          ffi.Pointer<objc.ObjCBlockImpl> pointer,
          {bool retain = false,
          bool release = false}) =>
      objc.ObjCBlock<ffi.Pointer<__IOSurface> Function(ffi.Pointer<ffi.Void>)>(
          pointer,
          retain: retain,
          release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Pointer<__IOSurface> Function(ffi.Pointer<ffi.Void>)>
      fromFunctionPointer(
              ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.Pointer<__IOSurface> Function(
                              ffi.Pointer<ffi.Void> arg0)>>
                  ptr) =>
          objc.ObjCBlock<ffi.Pointer<__IOSurface> Function(ffi.Pointer<ffi.Void>)>(
              objc.newPointerBlock(_ObjCBlock_IOSurfaceRef_ffiVoid_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
      ffi.Pointer<__IOSurface> Function(ffi.Pointer<ffi.Void>)> fromFunction(
          ffi.Pointer<__IOSurface> Function(ffi.Pointer<ffi.Void>) fn,
          {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Pointer<__IOSurface> Function(ffi.Pointer<ffi.Void>)>(
          objc.newClosureBlock(_ObjCBlock_IOSurfaceRef_ffiVoid_closureCallable,
              (ffi.Pointer<ffi.Void> arg0) => fn(arg0), keepIsolateAlive),
          retain: false,
          release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<__IOSurface> Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_IOSurfaceRef_ffiVoid_CallExtension on objc
    .ObjCBlock<ffi.Pointer<__IOSurface> Function(ffi.Pointer<ffi.Void>)> {
  ffi.Pointer<__IOSurface> call(ffi.Pointer<ffi.Void> arg0) =>
      ref.pointer.ref.invoke
          .cast<
              ffi.NativeFunction<
                  ffi.Pointer<__IOSurface> Function(
                      ffi.Pointer<objc.ObjCBlockImpl> block,
                      ffi.Pointer<ffi.Void> arg0)>>()
          .asFunction<
              ffi.Pointer<__IOSurface> Function(ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0);
}

ffi.Pointer<__CVBuffer> _ObjCBlock_CVPixelBufferRef_ffiVoid_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Pointer<__CVBuffer> Function(ffi.Pointer<ffi.Void> arg0)>>()
        .asFunction<
            ffi.Pointer<__CVBuffer> Function(ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_CVPixelBufferRef_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<__CVBuffer> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_CVPixelBufferRef_ffiVoid_fnPtrTrampoline)
        .cast();
ffi.Pointer<__CVBuffer> _ObjCBlock_CVPixelBufferRef_ffiVoid_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    (objc.getBlockClosure(block) as ffi.Pointer<__CVBuffer> Function(
        ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_CVPixelBufferRef_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<__CVBuffer> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_CVPixelBufferRef_ffiVoid_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<__CVBuffer> Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_CVPixelBufferRef_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Pointer<__CVBuffer> Function(ffi.Pointer<ffi.Void>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  ffi.Pointer<__CVBuffer> Function(ffi.Pointer<ffi.Void>)>(
              pointer,
              retain: retain,
              release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Pointer<__CVBuffer> Function(ffi.Pointer<ffi.Void>)>
      fromFunctionPointer(
              ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.Pointer<__CVBuffer> Function(
                              ffi.Pointer<ffi.Void> arg0)>>
                  ptr) =>
          objc.ObjCBlock<ffi.Pointer<__CVBuffer> Function(ffi.Pointer<ffi.Void>)>(
              objc.newPointerBlock(_ObjCBlock_CVPixelBufferRef_ffiVoid_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Pointer<__CVBuffer> Function(ffi.Pointer<ffi.Void>)>
      fromFunction(ffi.Pointer<__CVBuffer> Function(ffi.Pointer<ffi.Void>) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<
                  ffi.Pointer<__CVBuffer> Function(ffi.Pointer<ffi.Void>)>(
              objc.newClosureBlock(
                  _ObjCBlock_CVPixelBufferRef_ffiVoid_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0) => fn(arg0),
                  keepIsolateAlive),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<__CVBuffer> Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_CVPixelBufferRef_ffiVoid_CallExtension
    on objc.ObjCBlock<ffi.Pointer<__CVBuffer> Function(ffi.Pointer<ffi.Void>)> {
  ffi.Pointer<__CVBuffer> call(ffi.Pointer<ffi.Void> arg0) => ref
      .pointer.ref.invoke
      .cast<
          ffi.NativeFunction<
              ffi.Pointer<__CVBuffer> Function(
                  ffi.Pointer<objc.ObjCBlockImpl> block,
                  ffi.Pointer<ffi.Void> arg0)>>()
      .asFunction<
          ffi.Pointer<__CVBuffer> Function(ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0);
}

ffi.Pointer<objc.ObjCObject> _ObjCBlock_idMTLTexture_ffiVoid_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<ffi.Void> arg0)>>()
        .asFunction<
            ffi.Pointer<objc.ObjCObject> Function(
                ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_idMTLTexture_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_idMTLTexture_ffiVoid_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject> _ObjCBlock_idMTLTexture_ffiVoid_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(
        ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_idMTLTexture_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_idMTLTexture_ffiVoid_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_idMTLTexture_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc
      .ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  ffi.Pointer<objc.ObjCObject>? Function(
                      ffi.Pointer<ffi.Void>)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)>
      fromFunctionPointer(
              ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.Pointer<objc.ObjCObject> Function(
                              ffi.Pointer<ffi.Void> arg0)>>
                  ptr) =>
          objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)>(
              objc.newPointerBlock(_ObjCBlock_idMTLTexture_ffiVoid_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc
      .ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)>
      fromFunction(MTLTexture? Function(ffi.Pointer<ffi.Void>) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<
                  ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)>(
              objc.newClosureBlock(
                  _ObjCBlock_idMTLTexture_ffiVoid_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0) =>
                      fn(arg0)?.ref.retainAndAutorelease() ?? ffi.nullptr,
                  keepIsolateAlive),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_idMTLTexture_ffiVoid_CallExtension on objc
    .ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)> {
  MTLTexture? call(ffi.Pointer<ffi.Void> arg0) => ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Pointer<objc.ObjCObject> Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0)>>()
              .asFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                      ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>()
              (ref.pointer, arg0)
              .address ==
          0
      ? null
      : MTLTexture.castFromPointer(
          ref.pointer.ref.invoke
              .cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)>>()
              .asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0),
          retain: true,
          release: true);
}

late final _sel_digest = objc.registerName("digest");
int _ObjCBlock_Uint64_ffiVoid_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    block.ref.target
        .cast<
            ffi
            .NativeFunction<ffi.Uint64 Function(ffi.Pointer<ffi.Void> arg0)>>()
        .asFunction<int Function(ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_Uint64_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Uint64 Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_Uint64_ffiVoid_fnPtrTrampoline, 0)
        .cast();
int _ObjCBlock_Uint64_ffiVoid_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    (objc.getBlockClosure(block) as int Function(ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_Uint64_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Uint64 Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_Uint64_ffiVoid_closureTrampoline, 0)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Uint64 Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_Uint64_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Uint64 Function(ffi.Pointer<ffi.Void>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<ffi.Uint64 Function(ffi.Pointer<ffi.Void>)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Uint64 Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(
          ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Uint64 Function(ffi.Pointer<ffi.Void> arg0)>>
              ptr) =>
      objc.ObjCBlock<ffi.Uint64 Function(ffi.Pointer<ffi.Void>)>(
          objc.newPointerBlock(
              _ObjCBlock_Uint64_ffiVoid_fnPtrCallable, ptr.cast()),
          retain: false,
          release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Uint64 Function(ffi.Pointer<ffi.Void>)>
      fromFunction(int Function(ffi.Pointer<ffi.Void>) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<ffi.Uint64 Function(ffi.Pointer<ffi.Void>)>(
              objc.newClosureBlock(_ObjCBlock_Uint64_ffiVoid_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0) => fn(arg0), keepIsolateAlive),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.Uint64 Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_Uint64_ffiVoid_CallExtension
    on objc.ObjCBlock<ffi.Uint64 Function(ffi.Pointer<ffi.Void>)> {
  int call(ffi.Pointer<ffi.Void> arg0) => ref.pointer.ref.invoke
      .cast<
          ffi.NativeFunction<
              ffi.Uint64 Function(ffi.Pointer<objc.ObjCBlockImpl> block,
                  ffi.Pointer<ffi.Void> arg0)>>()
      .asFunction<
          int Function(ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0);
}

late final _sel_roiTileIndex = objc.registerName("roiTileIndex");
int _ObjCBlock_NSUInteger_ffiVoid_fnPtrTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    block.ref.target
        .cast<
            ffi.NativeFunction<
                ffi.UnsignedLong Function(ffi.Pointer<ffi.Void> arg0)>>()
        .asFunction<int Function(ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_NSUInteger_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.UnsignedLong Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_NSUInteger_ffiVoid_fnPtrTrampoline, 0)
        .cast();
int _ObjCBlock_NSUInteger_ffiVoid_closureTrampoline(
        ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
    (objc.getBlockClosure(block) as int Function(ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_NSUInteger_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.UnsignedLong Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_NSUInteger_ffiVoid_closureTrampoline, 0)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_NSUInteger_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>(
              pointer,
              retain: retain,
              release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>
      fromFunctionPointer(
              ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.UnsignedLong Function(
                              ffi.Pointer<ffi.Void> arg0)>>
                  ptr) =>
          objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>(
              objc.newPointerBlock(_ObjCBlock_NSUInteger_ffiVoid_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>
      fromFunction(int Function(ffi.Pointer<ffi.Void>) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>(
              objc.newClosureBlock(
                  _ObjCBlock_NSUInteger_ffiVoid_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0) => fn(arg0),
                  keepIsolateAlive),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_NSUInteger_ffiVoid_CallExtension
    on objc.ObjCBlock<ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>)> {
  int call(ffi.Pointer<ffi.Void> arg0) => ref.pointer.ref.invoke
      .cast<
          ffi.NativeFunction<
              ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCBlockImpl> block,
                  ffi.Pointer<ffi.Void> arg0)>>()
      .asFunction<
          int Function(ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0);
}

late final _sel_roiTileCount = objc.registerName("roiTileCount");

/// CIImageProcessorInput
interface class CIImageProcessorInput extends objc.ObjCProtocolBase {
  CIImageProcessorInput._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [CIImageProcessorInput] that points to the same underlying object as [other].
  CIImageProcessorInput.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [CIImageProcessorInput] that wraps the given raw object pointer.
  CIImageProcessorInput.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [CIImageProcessorInput].
  static bool conformsTo(objc.ObjCObjectBase obj) {
    return _objc_msgSend_e3qsqz(obj.ref.pointer, _sel_conformsToProtocol_,
        _protocol_CIImageProcessorInput);
  }

  /// Returns the [objc.Protocol] object for this protocol.
  static objc.Protocol get $protocol =>
      objc.Protocol.castFromPointer(_protocol_CIImageProcessorInput.cast());

  /// Builds an object that implements the CIImageProcessorInput protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static CIImageProcessorInput implement(
      {required CGRect Function() region,
      required int Function() bytesPerRow,
      required int Function() format,
      required ffi.Pointer<ffi.Void> Function() baseAddress,
      required ffi.Pointer<__IOSurface> Function() surface,
      required ffi.Pointer<__CVBuffer> Function() pixelBuffer,
      required MTLTexture? Function() metalTexture,
      required int Function() digest,
      required int Function() roiTileIndex,
      required int Function() roiTileCount,
      bool $keepIsolateAlive = true}) {
    final builder =
        objc.ObjCProtocolBuilder(debugName: 'CIImageProcessorInput');
    CIImageProcessorInput.region.implement(builder, region);
    CIImageProcessorInput.bytesPerRow.implement(builder, bytesPerRow);
    CIImageProcessorInput.format.implement(builder, format);
    CIImageProcessorInput.baseAddress.implement(builder, baseAddress);
    CIImageProcessorInput.surface.implement(builder, surface);
    CIImageProcessorInput.pixelBuffer.implement(builder, pixelBuffer);
    CIImageProcessorInput.metalTexture.implement(builder, metalTexture);
    CIImageProcessorInput.digest.implement(builder, digest);
    CIImageProcessorInput.roiTileIndex.implement(builder, roiTileIndex);
    CIImageProcessorInput.roiTileCount.implement(builder, roiTileCount);
    builder.addProtocol($protocol);
    return CIImageProcessorInput.castFrom(
        builder.build(keepIsolateAlive: $keepIsolateAlive));
  }

  /// Adds the implementation of the CIImageProcessorInput protocol to an existing
  /// [objc.ObjCProtocolBuilder].
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilder(objc.ObjCProtocolBuilder builder,
      {required CGRect Function() region,
      required int Function() bytesPerRow,
      required int Function() format,
      required ffi.Pointer<ffi.Void> Function() baseAddress,
      required ffi.Pointer<__IOSurface> Function() surface,
      required ffi.Pointer<__CVBuffer> Function() pixelBuffer,
      required MTLTexture? Function() metalTexture,
      required int Function() digest,
      required int Function() roiTileIndex,
      required int Function() roiTileCount,
      bool $keepIsolateAlive = true}) {
    CIImageProcessorInput.region.implement(builder, region);
    CIImageProcessorInput.bytesPerRow.implement(builder, bytesPerRow);
    CIImageProcessorInput.format.implement(builder, format);
    CIImageProcessorInput.baseAddress.implement(builder, baseAddress);
    CIImageProcessorInput.surface.implement(builder, surface);
    CIImageProcessorInput.pixelBuffer.implement(builder, pixelBuffer);
    CIImageProcessorInput.metalTexture.implement(builder, metalTexture);
    CIImageProcessorInput.digest.implement(builder, digest);
    CIImageProcessorInput.roiTileIndex.implement(builder, roiTileIndex);
    CIImageProcessorInput.roiTileCount.implement(builder, roiTileCount);
    builder.addProtocol($protocol);
  }

  /// region
  static final region = objc.ObjCProtocolMethod<CGRect Function()>(
    _protocol_CIImageProcessorInput,
    _sel_region,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    CGRect Function(
                        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>>(
            _CoreImageBindings_protocolTrampoline_1c3uc0w)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_CIImageProcessorInput,
      _sel_region,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (CGRect Function() func) => ObjCBlock_CGRect_ffiVoid.fromFunction((
      ffi.Pointer<ffi.Void> _,
    ) =>
        func()),
  );

  /// bytesPerRow
  static final bytesPerRow = objc.ObjCProtocolMethod<int Function()>(
    _protocol_CIImageProcessorInput,
    _sel_bytesPerRow,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Size Function(
                        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>>(
            _CoreImageBindings_protocolTrampoline_150qdkd)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_CIImageProcessorInput,
      _sel_bytesPerRow,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (int Function() func) => ObjCBlock_ffiSize_ffiVoid.fromFunction((
      ffi.Pointer<ffi.Void> _,
    ) =>
        func()),
  );

  /// format
  static final format = objc.ObjCProtocolMethod<int Function()>(
    _protocol_CIImageProcessorInput,
    _sel_format,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Int Function(
                        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>>(
            _CoreImageBindings_protocolTrampoline_1l0nlq)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_CIImageProcessorInput,
      _sel_format,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (int Function() func) => ObjCBlock_CIFormat_ffiVoid.fromFunction((
      ffi.Pointer<ffi.Void> _,
    ) =>
        func()),
  );

  /// baseAddress
  static final baseAddress =
      objc.ObjCProtocolMethod<ffi.Pointer<ffi.Void> Function()>(
    _protocol_CIImageProcessorInput,
    _sel_baseAddress,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Pointer<ffi.Void> Function(
                        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>>(
            _CoreImageBindings_protocolTrampoline_3fl8pv)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_CIImageProcessorInput,
      _sel_baseAddress,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (ffi.Pointer<ffi.Void> Function() func) =>
        ObjCBlock_CFTypeRef_CFTypeRef.fromFunction((
      ffi.Pointer<ffi.Void> _,
    ) =>
            func()),
  );

  /// surface
  static final surface =
      objc.ObjCProtocolMethod<ffi.Pointer<__IOSurface> Function()>(
    _protocol_CIImageProcessorInput,
    _sel_surface,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Pointer<__IOSurface> Function(
                        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>>(
            _CoreImageBindings_protocolTrampoline_tg5r79)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_CIImageProcessorInput,
      _sel_surface,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (ffi.Pointer<__IOSurface> Function() func) =>
        ObjCBlock_IOSurfaceRef_ffiVoid.fromFunction((
      ffi.Pointer<ffi.Void> _,
    ) =>
            func()),
  );

  /// pixelBuffer
  static final pixelBuffer =
      objc.ObjCProtocolMethod<ffi.Pointer<__CVBuffer> Function()>(
    _protocol_CIImageProcessorInput,
    _sel_pixelBuffer,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Pointer<__CVBuffer> Function(
                        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>>(
            _CoreImageBindings_protocolTrampoline_vfhx8p)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_CIImageProcessorInput,
      _sel_pixelBuffer,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (ffi.Pointer<__CVBuffer> Function() func) =>
        ObjCBlock_CVPixelBufferRef_ffiVoid.fromFunction((
      ffi.Pointer<ffi.Void> _,
    ) =>
            func()),
  );

  /// metalTexture
  static final metalTexture = objc.ObjCProtocolMethod<MTLTexture? Function()>(
    _protocol_CIImageProcessorInput,
    _sel_metalTexture,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Pointer<objc.ObjCObject> Function(
                        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>>(
            _CoreImageBindings_protocolTrampoline_1mbt9g9)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_CIImageProcessorInput,
      _sel_metalTexture,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (MTLTexture? Function() func) =>
        ObjCBlock_idMTLTexture_ffiVoid.fromFunction((
      ffi.Pointer<ffi.Void> _,
    ) =>
            func()),
  );

  /// digest
  static final digest = objc.ObjCProtocolMethod<int Function()>(
    _protocol_CIImageProcessorInput,
    _sel_digest,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Uint64 Function(
                        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>>(
            _CoreImageBindings_protocolTrampoline_k3xjiw)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_CIImageProcessorInput,
      _sel_digest,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (int Function() func) => ObjCBlock_Uint64_ffiVoid.fromFunction((
      ffi.Pointer<ffi.Void> _,
    ) =>
        func()),
  );

  /// roiTileIndex
  static final roiTileIndex = objc.ObjCProtocolMethod<int Function()>(
    _protocol_CIImageProcessorInput,
    _sel_roiTileIndex,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.UnsignedLong Function(
                        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>>(
            _CoreImageBindings_protocolTrampoline_1ckyi24)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_CIImageProcessorInput,
      _sel_roiTileIndex,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (int Function() func) => ObjCBlock_NSUInteger_ffiVoid.fromFunction((
      ffi.Pointer<ffi.Void> _,
    ) =>
        func()),
  );

  /// roiTileCount
  static final roiTileCount = objc.ObjCProtocolMethod<int Function()>(
    _protocol_CIImageProcessorInput,
    _sel_roiTileCount,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.UnsignedLong Function(
                        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>>(
            _CoreImageBindings_protocolTrampoline_1ckyi24)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_CIImageProcessorInput,
      _sel_roiTileCount,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (int Function() func) => ObjCBlock_NSUInteger_ffiVoid.fromFunction((
      ffi.Pointer<ffi.Void> _,
    ) =>
        func()),
  );
}

late final _protocol_CIImageProcessorOutput =
    objc.getProtocol("CIImageProcessorOutput");
late final _sel_metalCommandBuffer = objc.registerName("metalCommandBuffer");
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_idMTLCommandBuffer_ffiVoid_fnPtrTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0) =>
        block.ref.target
            .cast<
                ffi.NativeFunction<
                    ffi.Pointer<objc.ObjCObject> Function(
                        ffi.Pointer<ffi.Void> arg0)>>()
            .asFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<ffi.Void>)>()(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_idMTLCommandBuffer_ffiVoid_fnPtrCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_idMTLCommandBuffer_ffiVoid_fnPtrTrampoline)
        .cast();
ffi.Pointer<objc.ObjCObject>
    _ObjCBlock_idMTLCommandBuffer_ffiVoid_closureTrampoline(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<ffi.Void> arg0) =>
        (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObject> Function(
            ffi.Pointer<ffi.Void>))(arg0);
ffi.Pointer<ffi.Void> _ObjCBlock_idMTLCommandBuffer_ffiVoid_closureCallable =
    ffi.Pointer.fromFunction<
                ffi.Pointer<objc.ObjCObject> Function(
                    ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
            _ObjCBlock_idMTLCommandBuffer_ffiVoid_closureTrampoline)
        .cast();

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_idMTLCommandBuffer_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc
      .ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)>
      castFromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer,
              {bool retain = false, bool release = false}) =>
          objc.ObjCBlock<
                  ffi.Pointer<objc.ObjCObject>? Function(
                      ffi.Pointer<ffi.Void>)>(pointer,
              retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)>
      fromFunctionPointer(
              ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.Pointer<objc.ObjCObject> Function(
                              ffi.Pointer<ffi.Void> arg0)>>
                  ptr) =>
          objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)>(
              objc.newPointerBlock(_ObjCBlock_idMTLCommandBuffer_ffiVoid_fnPtrCallable, ptr.cast()),
              retain: false,
              release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc
      .ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)>
      fromFunction(MTLCommandBuffer? Function(ffi.Pointer<ffi.Void>) fn,
              {bool keepIsolateAlive = true}) =>
          objc.ObjCBlock<
                  ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)>(
              objc.newClosureBlock(
                  _ObjCBlock_idMTLCommandBuffer_ffiVoid_closureCallable,
                  (ffi.Pointer<ffi.Void> arg0) =>
                      fn(arg0)?.ref.retainAndAutorelease() ?? ffi.nullptr,
                  keepIsolateAlive),
              retain: false,
              release: true);
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_idMTLCommandBuffer_ffiVoid_CallExtension on objc
    .ObjCBlock<ffi.Pointer<objc.ObjCObject>? Function(ffi.Pointer<ffi.Void>)> {
  MTLCommandBuffer? call(ffi.Pointer<ffi.Void> arg0) => ref.pointer.ref.invoke
              .cast<
                  ffi.NativeFunction<
                      ffi.Pointer<objc.ObjCObject> Function(
                          ffi.Pointer<objc.ObjCBlockImpl> block,
                          ffi.Pointer<ffi.Void> arg0)>>()
              .asFunction<
                  ffi.Pointer<objc.ObjCObject> Function(
                      ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>()
              (ref.pointer, arg0)
              .address ==
          0
      ? null
      : MTLCommandBuffer.castFromPointer(
          ref.pointer.ref.invoke
              .cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)>>()
              .asFunction<ffi.Pointer<objc.ObjCObject> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0),
          retain: true,
          release: true);
}

/// CIImageProcessorOutput
interface class CIImageProcessorOutput extends objc.ObjCProtocolBase {
  CIImageProcessorOutput._(ffi.Pointer<objc.ObjCObject> pointer,
      {bool retain = false, bool release = false})
      : super(pointer, retain: retain, release: release);

  /// Constructs a [CIImageProcessorOutput] that points to the same underlying object as [other].
  CIImageProcessorOutput.castFrom(objc.ObjCObjectBase other)
      : this._(other.ref.pointer, retain: true, release: true);

  /// Constructs a [CIImageProcessorOutput] that wraps the given raw object pointer.
  CIImageProcessorOutput.castFromPointer(ffi.Pointer<objc.ObjCObject> other,
      {bool retain = false, bool release = false})
      : this._(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [CIImageProcessorOutput].
  static bool conformsTo(objc.ObjCObjectBase obj) {
    return _objc_msgSend_e3qsqz(obj.ref.pointer, _sel_conformsToProtocol_,
        _protocol_CIImageProcessorOutput);
  }

  /// Returns the [objc.Protocol] object for this protocol.
  static objc.Protocol get $protocol =>
      objc.Protocol.castFromPointer(_protocol_CIImageProcessorOutput.cast());

  /// Builds an object that implements the CIImageProcessorOutput protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static CIImageProcessorOutput implement(
      {required CGRect Function() region,
      required int Function() bytesPerRow,
      required int Function() format,
      required ffi.Pointer<ffi.Void> Function() baseAddress,
      required ffi.Pointer<__IOSurface> Function() surface,
      required ffi.Pointer<__CVBuffer> Function() pixelBuffer,
      required MTLTexture? Function() metalTexture,
      required MTLCommandBuffer? Function() metalCommandBuffer,
      required int Function() digest,
      bool $keepIsolateAlive = true}) {
    final builder =
        objc.ObjCProtocolBuilder(debugName: 'CIImageProcessorOutput');
    CIImageProcessorOutput.region.implement(builder, region);
    CIImageProcessorOutput.bytesPerRow.implement(builder, bytesPerRow);
    CIImageProcessorOutput.format.implement(builder, format);
    CIImageProcessorOutput.baseAddress.implement(builder, baseAddress);
    CIImageProcessorOutput.surface.implement(builder, surface);
    CIImageProcessorOutput.pixelBuffer.implement(builder, pixelBuffer);
    CIImageProcessorOutput.metalTexture.implement(builder, metalTexture);
    CIImageProcessorOutput.metalCommandBuffer
        .implement(builder, metalCommandBuffer);
    CIImageProcessorOutput.digest.implement(builder, digest);
    builder.addProtocol($protocol);
    return CIImageProcessorOutput.castFrom(
        builder.build(keepIsolateAlive: $keepIsolateAlive));
  }

  /// Adds the implementation of the CIImageProcessorOutput protocol to an existing
  /// [objc.ObjCProtocolBuilder].
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilder(objc.ObjCProtocolBuilder builder,
      {required CGRect Function() region,
      required int Function() bytesPerRow,
      required int Function() format,
      required ffi.Pointer<ffi.Void> Function() baseAddress,
      required ffi.Pointer<__IOSurface> Function() surface,
      required ffi.Pointer<__CVBuffer> Function() pixelBuffer,
      required MTLTexture? Function() metalTexture,
      required MTLCommandBuffer? Function() metalCommandBuffer,
      required int Function() digest,
      bool $keepIsolateAlive = true}) {
    CIImageProcessorOutput.region.implement(builder, region);
    CIImageProcessorOutput.bytesPerRow.implement(builder, bytesPerRow);
    CIImageProcessorOutput.format.implement(builder, format);
    CIImageProcessorOutput.baseAddress.implement(builder, baseAddress);
    CIImageProcessorOutput.surface.implement(builder, surface);
    CIImageProcessorOutput.pixelBuffer.implement(builder, pixelBuffer);
    CIImageProcessorOutput.metalTexture.implement(builder, metalTexture);
    CIImageProcessorOutput.metalCommandBuffer
        .implement(builder, metalCommandBuffer);
    CIImageProcessorOutput.digest.implement(builder, digest);
    builder.addProtocol($protocol);
  }

  /// region
  static final region = objc.ObjCProtocolMethod<CGRect Function()>(
    _protocol_CIImageProcessorOutput,
    _sel_region,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    CGRect Function(
                        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>>(
            _CoreImageBindings_protocolTrampoline_1c3uc0w)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_CIImageProcessorOutput,
      _sel_region,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (CGRect Function() func) => ObjCBlock_CGRect_ffiVoid.fromFunction((
      ffi.Pointer<ffi.Void> _,
    ) =>
        func()),
  );

  /// bytesPerRow
  static final bytesPerRow = objc.ObjCProtocolMethod<int Function()>(
    _protocol_CIImageProcessorOutput,
    _sel_bytesPerRow,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Size Function(
                        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>>(
            _CoreImageBindings_protocolTrampoline_150qdkd)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_CIImageProcessorOutput,
      _sel_bytesPerRow,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (int Function() func) => ObjCBlock_ffiSize_ffiVoid.fromFunction((
      ffi.Pointer<ffi.Void> _,
    ) =>
        func()),
  );

  /// format
  static final format = objc.ObjCProtocolMethod<int Function()>(
    _protocol_CIImageProcessorOutput,
    _sel_format,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Int Function(
                        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>>(
            _CoreImageBindings_protocolTrampoline_1l0nlq)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_CIImageProcessorOutput,
      _sel_format,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (int Function() func) => ObjCBlock_CIFormat_ffiVoid.fromFunction((
      ffi.Pointer<ffi.Void> _,
    ) =>
        func()),
  );

  /// baseAddress
  static final baseAddress =
      objc.ObjCProtocolMethod<ffi.Pointer<ffi.Void> Function()>(
    _protocol_CIImageProcessorOutput,
    _sel_baseAddress,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Pointer<ffi.Void> Function(
                        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>>(
            _CoreImageBindings_protocolTrampoline_3fl8pv)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_CIImageProcessorOutput,
      _sel_baseAddress,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (ffi.Pointer<ffi.Void> Function() func) =>
        ObjCBlock_CFTypeRef_CFTypeRef.fromFunction((
      ffi.Pointer<ffi.Void> _,
    ) =>
            func()),
  );

  /// surface
  static final surface =
      objc.ObjCProtocolMethod<ffi.Pointer<__IOSurface> Function()>(
    _protocol_CIImageProcessorOutput,
    _sel_surface,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Pointer<__IOSurface> Function(
                        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>>(
            _CoreImageBindings_protocolTrampoline_tg5r79)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_CIImageProcessorOutput,
      _sel_surface,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (ffi.Pointer<__IOSurface> Function() func) =>
        ObjCBlock_IOSurfaceRef_ffiVoid.fromFunction((
      ffi.Pointer<ffi.Void> _,
    ) =>
            func()),
  );

  /// pixelBuffer
  static final pixelBuffer =
      objc.ObjCProtocolMethod<ffi.Pointer<__CVBuffer> Function()>(
    _protocol_CIImageProcessorOutput,
    _sel_pixelBuffer,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Pointer<__CVBuffer> Function(
                        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>>(
            _CoreImageBindings_protocolTrampoline_vfhx8p)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_CIImageProcessorOutput,
      _sel_pixelBuffer,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (ffi.Pointer<__CVBuffer> Function() func) =>
        ObjCBlock_CVPixelBufferRef_ffiVoid.fromFunction((
      ffi.Pointer<ffi.Void> _,
    ) =>
            func()),
  );

  /// metalTexture
  static final metalTexture = objc.ObjCProtocolMethod<MTLTexture? Function()>(
    _protocol_CIImageProcessorOutput,
    _sel_metalTexture,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Pointer<objc.ObjCObject> Function(
                        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>>(
            _CoreImageBindings_protocolTrampoline_1mbt9g9)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_CIImageProcessorOutput,
      _sel_metalTexture,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (MTLTexture? Function() func) =>
        ObjCBlock_idMTLTexture_ffiVoid.fromFunction((
      ffi.Pointer<ffi.Void> _,
    ) =>
            func()),
  );

  /// metalCommandBuffer
  static final metalCommandBuffer =
      objc.ObjCProtocolMethod<MTLCommandBuffer? Function()>(
    _protocol_CIImageProcessorOutput,
    _sel_metalCommandBuffer,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Pointer<objc.ObjCObject> Function(
                        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>>(
            _CoreImageBindings_protocolTrampoline_1mbt9g9)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_CIImageProcessorOutput,
      _sel_metalCommandBuffer,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (MTLCommandBuffer? Function() func) =>
        ObjCBlock_idMTLCommandBuffer_ffiVoid.fromFunction((
      ffi.Pointer<ffi.Void> _,
    ) =>
            func()),
  );

  /// digest
  static final digest = objc.ObjCProtocolMethod<int Function()>(
    _protocol_CIImageProcessorOutput,
    _sel_digest,
    ffi.Native.addressOf<
                ffi.NativeFunction<
                    ffi.Uint64 Function(
                        ffi.Pointer<objc.ObjCObject>, ffi.Pointer<ffi.Void>)>>(
            _CoreImageBindings_protocolTrampoline_k3xjiw)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_CIImageProcessorOutput,
      _sel_digest,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (int Function() func) => ObjCBlock_Uint64_ffiVoid.fromFunction((
      ffi.Pointer<ffi.Void> _,
    ) =>
        func()),
  );
}
