// ignore_for_file: camel_case_types, non_constant_identifier_names, unused_element, unused_field

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// WebP image format library
class LibwebpFlutterLibsBindings {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  LibwebpFlutterLibsBindings(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  LibwebpFlutterLibsBindings.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  void __va_start(
    ffi.Pointer<va_list> arg0,
  ) {
    return ___va_start(
      arg0,
    );
  }

  late final ___va_startPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<va_list>)>>(
          '__va_start');
  late final ___va_start =
      ___va_startPtr.asFunction<void Function(ffi.Pointer<va_list>)>();

  void __security_init_cookie() {
    return ___security_init_cookie();
  }

  late final ___security_init_cookiePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          '__security_init_cookie');
  late final ___security_init_cookie =
      ___security_init_cookiePtr.asFunction<void Function()>();

  void __security_check_cookie(
    int _StackCookie,
  ) {
    return ___security_check_cookie(
      _StackCookie,
    );
  }

  late final ___security_check_cookiePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.UintPtr)>>(
          '__security_check_cookie');
  late final ___security_check_cookie =
      ___security_check_cookiePtr.asFunction<void Function(int)>();

  void __report_gsfailure(
    int _StackCookie,
  ) {
    return ___report_gsfailure(
      _StackCookie,
    );
  }

  late final ___report_gsfailurePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.UintPtr)>>(
          '__report_gsfailure');
  late final ___report_gsfailure =
      ___report_gsfailurePtr.asFunction<void Function(int)>();

  late final ffi.Pointer<ffi.UintPtr> __security_cookie =
      _lookup<ffi.UintPtr>('__security_cookie');

  int get _security_cookie => __security_cookie.value;

  set _security_cookie(int value) => __security_cookie.value = value;

  void _invalid_parameter_noinfo() {
    return __invalid_parameter_noinfo();
  }

  late final __invalid_parameter_noinfoPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          '_invalid_parameter_noinfo');
  late final __invalid_parameter_noinfo =
      __invalid_parameter_noinfoPtr.asFunction<void Function()>();

  void _invalid_parameter_noinfo_noreturn() {
    return __invalid_parameter_noinfo_noreturn();
  }

  late final __invalid_parameter_noinfo_noreturnPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          '_invalid_parameter_noinfo_noreturn');
  late final __invalid_parameter_noinfo_noreturn =
      __invalid_parameter_noinfo_noreturnPtr.asFunction<void Function()>();

  void _invoke_watson(
    ffi.Pointer<ffi.WChar> _Expression,
    ffi.Pointer<ffi.WChar> _FunctionName,
    ffi.Pointer<ffi.WChar> _FileName,
    int _LineNo,
    int _Reserved,
  ) {
    return __invoke_watson(
      _Expression,
      _FunctionName,
      _FileName,
      _LineNo,
      _Reserved,
    );
  }

  late final __invoke_watsonPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.WChar>,
              ffi.Pointer<ffi.WChar>,
              ffi.Pointer<ffi.WChar>,
              ffi.UnsignedInt,
              ffi.UintPtr)>>('_invoke_watson');
  late final __invoke_watson = __invoke_watsonPtr.asFunction<
      void Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
          ffi.Pointer<ffi.WChar>, int, int)>();

  ffi.Pointer<ffi.Int> _errno() {
    return __errno();
  }

  late final __errnoPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Int> Function()>>('_errno');
  late final __errno = __errnoPtr.asFunction<ffi.Pointer<ffi.Int> Function()>();

  int _set_errno(
    int _Value,
  ) {
    return __set_errno(
      _Value,
    );
  }

  late final __set_errnoPtr =
      _lookup<ffi.NativeFunction<errno_t Function(ffi.Int)>>('_set_errno');
  late final __set_errno = __set_errnoPtr.asFunction<int Function(int)>();

  int _get_errno(
    ffi.Pointer<ffi.Int> _Value,
  ) {
    return __get_errno(
      _Value,
    );
  }

  late final __get_errnoPtr =
      _lookup<ffi.NativeFunction<errno_t Function(ffi.Pointer<ffi.Int>)>>(
          '_get_errno');
  late final __get_errno =
      __get_errnoPtr.asFunction<int Function(ffi.Pointer<ffi.Int>)>();

  int __threadid() {
    return ___threadid();
  }

  late final ___threadidPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedLong Function()>>('__threadid');
  late final ___threadid = ___threadidPtr.asFunction<int Function()>();

  int __threadhandle() {
    return ___threadhandle();
  }

  late final ___threadhandlePtr =
      _lookup<ffi.NativeFunction<ffi.UintPtr Function()>>('__threadhandle');
  late final ___threadhandle = ___threadhandlePtr.asFunction<int Function()>();

  /// Allocates 'size' bytes of memory. Returns NULL upon error. Memory
  /// must be deallocated by calling WebPFree(). This function is made available
  /// by the core 'libwebp' library.
  ffi.Pointer<ffi.Void> WebPMalloc(
    int size,
  ) {
    return _WebPMalloc(
      size,
    );
  }

  late final _WebPMallocPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>>(
          'WebPMalloc');
  late final _WebPMalloc =
      _WebPMallocPtr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  /// Releases memory returned by the WebPDecode*() functions (from decode.h).
  void WebPFree(
    ffi.Pointer<ffi.Void> ptr,
  ) {
    return _WebPFree(
      ptr,
    );
  }

  late final _WebPFreePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'WebPFree');
  late final _WebPFree =
      _WebPFreePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// Return the decoder's version number, packed in hexadecimal using 8bits for
  /// each of major/minor/revision. E.g: v2.5.7 is 0x020507.
  int WebPGetDecoderVersion() {
    return _WebPGetDecoderVersion();
  }

  late final _WebPGetDecoderVersionPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('WebPGetDecoderVersion');
  late final _WebPGetDecoderVersion =
      _WebPGetDecoderVersionPtr.asFunction<int Function()>();

  /// Retrieve basic header information: width, height.
  /// This function will also validate the header, returning true on success,
  /// false otherwise. '*width' and '*height' are only valid on successful return.
  /// Pointers 'width' and 'height' can be passed NULL if deemed irrelevant.
  /// Note: The following chunk sequences (before the raw VP8/VP8L data) are
  /// considered valid by this function:
  /// RIFF + VP8(L)
  /// RIFF + VP8X + (optional chunks) + VP8(L)
  /// ALPH + VP8 <-- Not a valid WebP format: only allowed for internal purpose.
  /// VP8(L)     <-- Not a valid WebP format: only allowed for internal purpose.
  int WebPGetInfo(
    ffi.Pointer<ffi.Uint8> data,
    int data_size,
    ffi.Pointer<ffi.Int> width,
    ffi.Pointer<ffi.Int> height,
  ) {
    return _WebPGetInfo(
      data,
      data_size,
      width,
      height,
    );
  }

  late final _WebPGetInfoPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Uint8>, ffi.Size,
              ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>>('WebPGetInfo');
  late final _WebPGetInfo = _WebPGetInfoPtr.asFunction<
      int Function(ffi.Pointer<ffi.Uint8>, int, ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Int>)>();

  /// Decodes WebP images pointed to by 'data' and returns RGBA samples, along
  /// with the dimensions in *width and *height. The ordering of samples in
  /// memory is R, G, B, A, R, G, B, A... in scan order (endian-independent).
  /// The returned pointer should be deleted calling WebPFree().
  /// Returns NULL in case of error.
  ffi.Pointer<ffi.Uint8> WebPDecodeRGBA(
    ffi.Pointer<ffi.Uint8> data,
    int data_size,
    ffi.Pointer<ffi.Int> width,
    ffi.Pointer<ffi.Int> height,
  ) {
    return _WebPDecodeRGBA(
      data,
      data_size,
      width,
      height,
    );
  }

  late final _WebPDecodeRGBAPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Uint8> Function(ffi.Pointer<ffi.Uint8>, ffi.Size,
              ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>>('WebPDecodeRGBA');
  late final _WebPDecodeRGBA = _WebPDecodeRGBAPtr.asFunction<
      ffi.Pointer<ffi.Uint8> Function(ffi.Pointer<ffi.Uint8>, int,
          ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>();

  /// Same as WebPDecodeRGBA, but returning A, R, G, B, A, R, G, B... ordered data.
  ffi.Pointer<ffi.Uint8> WebPDecodeARGB(
    ffi.Pointer<ffi.Uint8> data,
    int data_size,
    ffi.Pointer<ffi.Int> width,
    ffi.Pointer<ffi.Int> height,
  ) {
    return _WebPDecodeARGB(
      data,
      data_size,
      width,
      height,
    );
  }

  late final _WebPDecodeARGBPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Uint8> Function(ffi.Pointer<ffi.Uint8>, ffi.Size,
              ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>>('WebPDecodeARGB');
  late final _WebPDecodeARGB = _WebPDecodeARGBPtr.asFunction<
      ffi.Pointer<ffi.Uint8> Function(ffi.Pointer<ffi.Uint8>, int,
          ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>();

  /// Same as WebPDecodeRGBA, but returning B, G, R, A, B, G, R, A... ordered data.
  ffi.Pointer<ffi.Uint8> WebPDecodeBGRA(
    ffi.Pointer<ffi.Uint8> data,
    int data_size,
    ffi.Pointer<ffi.Int> width,
    ffi.Pointer<ffi.Int> height,
  ) {
    return _WebPDecodeBGRA(
      data,
      data_size,
      width,
      height,
    );
  }

  late final _WebPDecodeBGRAPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Uint8> Function(ffi.Pointer<ffi.Uint8>, ffi.Size,
              ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>>('WebPDecodeBGRA');
  late final _WebPDecodeBGRA = _WebPDecodeBGRAPtr.asFunction<
      ffi.Pointer<ffi.Uint8> Function(ffi.Pointer<ffi.Uint8>, int,
          ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>();

  /// Same as WebPDecodeRGBA, but returning R, G, B, R, G, B... ordered data.
  /// If the bitstream contains transparency, it is ignored.
  ffi.Pointer<ffi.Uint8> WebPDecodeRGB(
    ffi.Pointer<ffi.Uint8> data,
    int data_size,
    ffi.Pointer<ffi.Int> width,
    ffi.Pointer<ffi.Int> height,
  ) {
    return _WebPDecodeRGB(
      data,
      data_size,
      width,
      height,
    );
  }

  late final _WebPDecodeRGBPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Uint8> Function(ffi.Pointer<ffi.Uint8>, ffi.Size,
              ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>>('WebPDecodeRGB');
  late final _WebPDecodeRGB = _WebPDecodeRGBPtr.asFunction<
      ffi.Pointer<ffi.Uint8> Function(ffi.Pointer<ffi.Uint8>, int,
          ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>();

  /// Same as WebPDecodeRGB, but returning B, G, R, B, G, R... ordered data.
  ffi.Pointer<ffi.Uint8> WebPDecodeBGR(
    ffi.Pointer<ffi.Uint8> data,
    int data_size,
    ffi.Pointer<ffi.Int> width,
    ffi.Pointer<ffi.Int> height,
  ) {
    return _WebPDecodeBGR(
      data,
      data_size,
      width,
      height,
    );
  }

  late final _WebPDecodeBGRPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Uint8> Function(ffi.Pointer<ffi.Uint8>, ffi.Size,
              ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>>('WebPDecodeBGR');
  late final _WebPDecodeBGR = _WebPDecodeBGRPtr.asFunction<
      ffi.Pointer<ffi.Uint8> Function(ffi.Pointer<ffi.Uint8>, int,
          ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>();

  /// Decode WebP images pointed to by 'data' to Y'UV format(*). The pointer
  /// returned is the Y samples buffer. Upon return, *u and *v will point to
  /// the U and V chroma data. These U and V buffers need NOT be passed to
  /// WebPFree(), unlike the returned Y luma one. The dimension of the U and V
  /// planes are both (*width + 1) / 2 and (*height + 1) / 2.
  /// Upon return, the Y buffer has a stride returned as '*stride', while U and V
  /// have a common stride returned as '*uv_stride'.
  /// 'width' and 'height' may be NULL, the other pointers must not be.
  /// Returns NULL in case of error.
  /// (*) Also named Y'CbCr. See: https://en.wikipedia.org/wiki/YCbCr
  ffi.Pointer<ffi.Uint8> WebPDecodeYUV(
    ffi.Pointer<ffi.Uint8> data,
    int data_size,
    ffi.Pointer<ffi.Int> width,
    ffi.Pointer<ffi.Int> height,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> u,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> v,
    ffi.Pointer<ffi.Int> stride,
    ffi.Pointer<ffi.Int> uv_stride,
  ) {
    return _WebPDecodeYUV(
      data,
      data_size,
      width,
      height,
      u,
      v,
      stride,
      uv_stride,
    );
  }

  late final _WebPDecodeYUVPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Uint8> Function(
              ffi.Pointer<ffi.Uint8>,
              ffi.Size,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('WebPDecodeYUV');
  late final _WebPDecodeYUV = _WebPDecodeYUVPtr.asFunction<
      ffi.Pointer<ffi.Uint8> Function(
          ffi.Pointer<ffi.Uint8>,
          int,
          ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
          ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
          ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Int>)>();

  /// These five functions are variants of the above ones, that decode the image
  /// directly into a pre-allocated buffer 'output_buffer'. The maximum storage
  /// available in this buffer is indicated by 'output_buffer_size'. If this
  /// storage is not sufficient (or an error occurred), NULL is returned.
  /// Otherwise, output_buffer is returned, for convenience.
  /// The parameter 'output_stride' specifies the distance (in bytes)
  /// between scanlines. Hence, output_buffer_size is expected to be at least
  /// output_stride x picture-height.
  ffi.Pointer<ffi.Uint8> WebPDecodeRGBAInto(
    ffi.Pointer<ffi.Uint8> data,
    int data_size,
    ffi.Pointer<ffi.Uint8> output_buffer,
    int output_buffer_size,
    int output_stride,
  ) {
    return _WebPDecodeRGBAInto(
      data,
      data_size,
      output_buffer,
      output_buffer_size,
      output_stride,
    );
  }

  late final _WebPDecodeRGBAIntoPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Uint8> Function(
              ffi.Pointer<ffi.Uint8>,
              ffi.Size,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size,
              ffi.Int)>>('WebPDecodeRGBAInto');
  late final _WebPDecodeRGBAInto = _WebPDecodeRGBAIntoPtr.asFunction<
      ffi.Pointer<ffi.Uint8> Function(
          ffi.Pointer<ffi.Uint8>, int, ffi.Pointer<ffi.Uint8>, int, int)>();

  ffi.Pointer<ffi.Uint8> WebPDecodeARGBInto(
    ffi.Pointer<ffi.Uint8> data,
    int data_size,
    ffi.Pointer<ffi.Uint8> output_buffer,
    int output_buffer_size,
    int output_stride,
  ) {
    return _WebPDecodeARGBInto(
      data,
      data_size,
      output_buffer,
      output_buffer_size,
      output_stride,
    );
  }

  late final _WebPDecodeARGBIntoPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Uint8> Function(
              ffi.Pointer<ffi.Uint8>,
              ffi.Size,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size,
              ffi.Int)>>('WebPDecodeARGBInto');
  late final _WebPDecodeARGBInto = _WebPDecodeARGBIntoPtr.asFunction<
      ffi.Pointer<ffi.Uint8> Function(
          ffi.Pointer<ffi.Uint8>, int, ffi.Pointer<ffi.Uint8>, int, int)>();

  ffi.Pointer<ffi.Uint8> WebPDecodeBGRAInto(
    ffi.Pointer<ffi.Uint8> data,
    int data_size,
    ffi.Pointer<ffi.Uint8> output_buffer,
    int output_buffer_size,
    int output_stride,
  ) {
    return _WebPDecodeBGRAInto(
      data,
      data_size,
      output_buffer,
      output_buffer_size,
      output_stride,
    );
  }

  late final _WebPDecodeBGRAIntoPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Uint8> Function(
              ffi.Pointer<ffi.Uint8>,
              ffi.Size,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size,
              ffi.Int)>>('WebPDecodeBGRAInto');
  late final _WebPDecodeBGRAInto = _WebPDecodeBGRAIntoPtr.asFunction<
      ffi.Pointer<ffi.Uint8> Function(
          ffi.Pointer<ffi.Uint8>, int, ffi.Pointer<ffi.Uint8>, int, int)>();

  /// RGB and BGR variants. Here too the transparency information, if present,
  /// will be dropped and ignored.
  ffi.Pointer<ffi.Uint8> WebPDecodeRGBInto(
    ffi.Pointer<ffi.Uint8> data,
    int data_size,
    ffi.Pointer<ffi.Uint8> output_buffer,
    int output_buffer_size,
    int output_stride,
  ) {
    return _WebPDecodeRGBInto(
      data,
      data_size,
      output_buffer,
      output_buffer_size,
      output_stride,
    );
  }

  late final _WebPDecodeRGBIntoPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Uint8> Function(ffi.Pointer<ffi.Uint8>, ffi.Size,
              ffi.Pointer<ffi.Uint8>, ffi.Size, ffi.Int)>>('WebPDecodeRGBInto');
  late final _WebPDecodeRGBInto = _WebPDecodeRGBIntoPtr.asFunction<
      ffi.Pointer<ffi.Uint8> Function(
          ffi.Pointer<ffi.Uint8>, int, ffi.Pointer<ffi.Uint8>, int, int)>();

  ffi.Pointer<ffi.Uint8> WebPDecodeBGRInto(
    ffi.Pointer<ffi.Uint8> data,
    int data_size,
    ffi.Pointer<ffi.Uint8> output_buffer,
    int output_buffer_size,
    int output_stride,
  ) {
    return _WebPDecodeBGRInto(
      data,
      data_size,
      output_buffer,
      output_buffer_size,
      output_stride,
    );
  }

  late final _WebPDecodeBGRIntoPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Uint8> Function(ffi.Pointer<ffi.Uint8>, ffi.Size,
              ffi.Pointer<ffi.Uint8>, ffi.Size, ffi.Int)>>('WebPDecodeBGRInto');
  late final _WebPDecodeBGRInto = _WebPDecodeBGRIntoPtr.asFunction<
      ffi.Pointer<ffi.Uint8> Function(
          ffi.Pointer<ffi.Uint8>, int, ffi.Pointer<ffi.Uint8>, int, int)>();

  /// WebPDecodeYUVInto() is a variant of WebPDecodeYUV() that operates directly
  /// into pre-allocated luma/chroma plane buffers. This function requires the
  /// strides to be passed: one for the luma plane and one for each of the
  /// chroma ones. The size of each plane buffer is passed as 'luma_size',
  /// 'u_size' and 'v_size' respectively.
  /// Pointer to the luma plane ('*luma') is returned or NULL if an error occurred
  /// during decoding (or because some buffers were found to be too small).
  ffi.Pointer<ffi.Uint8> WebPDecodeYUVInto(
    ffi.Pointer<ffi.Uint8> data,
    int data_size,
    ffi.Pointer<ffi.Uint8> luma,
    int luma_size,
    int luma_stride,
    ffi.Pointer<ffi.Uint8> u,
    int u_size,
    int u_stride,
    ffi.Pointer<ffi.Uint8> v,
    int v_size,
    int v_stride,
  ) {
    return _WebPDecodeYUVInto(
      data,
      data_size,
      luma,
      luma_size,
      luma_stride,
      u,
      u_size,
      u_stride,
      v,
      v_size,
      v_stride,
    );
  }

  late final _WebPDecodeYUVIntoPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Uint8> Function(
              ffi.Pointer<ffi.Uint8>,
              ffi.Size,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size,
              ffi.Int,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size,
              ffi.Int,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size,
              ffi.Int)>>('WebPDecodeYUVInto');
  late final _WebPDecodeYUVInto = _WebPDecodeYUVIntoPtr.asFunction<
      ffi.Pointer<ffi.Uint8> Function(
          ffi.Pointer<ffi.Uint8>,
          int,
          ffi.Pointer<ffi.Uint8>,
          int,
          int,
          ffi.Pointer<ffi.Uint8>,
          int,
          int,
          ffi.Pointer<ffi.Uint8>,
          int,
          int)>();

  /// Internal, version-checked, entry point
  int WebPInitDecBufferInternal(
    ffi.Pointer<WebPDecBuffer> arg0,
    int arg1,
  ) {
    return _WebPInitDecBufferInternal(
      arg0,
      arg1,
    );
  }

  late final _WebPInitDecBufferInternalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<WebPDecBuffer>,
              ffi.Int)>>('WebPInitDecBufferInternal');
  late final _WebPInitDecBufferInternal = _WebPInitDecBufferInternalPtr
      .asFunction<int Function(ffi.Pointer<WebPDecBuffer>, int)>();

  /// Free any memory associated with the buffer. Must always be called last.
  /// Note: doesn't free the 'buffer' structure itself.
  void WebPFreeDecBuffer(
    ffi.Pointer<WebPDecBuffer> buffer,
  ) {
    return _WebPFreeDecBuffer(
      buffer,
    );
  }

  late final _WebPFreeDecBufferPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<WebPDecBuffer>)>>(
      'WebPFreeDecBuffer');
  late final _WebPFreeDecBuffer = _WebPFreeDecBufferPtr.asFunction<
      void Function(ffi.Pointer<WebPDecBuffer>)>();

  /// Creates a new incremental decoder with the supplied buffer parameter.
  /// This output_buffer can be passed NULL, in which case a default output buffer
  /// is used (with MODE_RGB). Otherwise, an internal reference to 'output_buffer'
  /// is kept, which means that the lifespan of 'output_buffer' must be larger than
  /// that of the returned WebPIDecoder object.
  /// The supplied 'output_buffer' content MUST NOT be changed between calls to
  /// WebPIAppend() or WebPIUpdate() unless 'output_buffer.is_external_memory' is
  /// not set to 0. In such a case, it is allowed to modify the pointers, size and
  /// stride of output_buffer.u.RGBA or output_buffer.u.YUVA, provided they remain
  /// within valid bounds.
  /// All other fields of WebPDecBuffer MUST remain constant between calls.
  /// Returns NULL if the allocation failed.
  ffi.Pointer<WebPIDecoder> WebPINewDecoder(
    ffi.Pointer<WebPDecBuffer> output_buffer,
  ) {
    return _WebPINewDecoder(
      output_buffer,
    );
  }

  late final _WebPINewDecoderPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<WebPIDecoder> Function(
              ffi.Pointer<WebPDecBuffer>)>>('WebPINewDecoder');
  late final _WebPINewDecoder = _WebPINewDecoderPtr.asFunction<
      ffi.Pointer<WebPIDecoder> Function(ffi.Pointer<WebPDecBuffer>)>();

  /// This function allocates and initializes an incremental-decoder object, which
  /// will output the RGB/A samples specified by 'csp' into a preallocated
  /// buffer 'output_buffer'. The size of this buffer is at least
  /// 'output_buffer_size' and the stride (distance in bytes between two scanlines)
  /// is specified by 'output_stride'.
  /// Additionally, output_buffer can be passed NULL in which case the output
  /// buffer will be allocated automatically when the decoding starts. The
  /// colorspace 'csp' is taken into account for allocating this buffer. All other
  /// parameters are ignored.
  /// Returns NULL if the allocation failed, or if some parameters are invalid.
  ffi.Pointer<WebPIDecoder> WebPINewRGB(
    int csp,
    ffi.Pointer<ffi.Uint8> output_buffer,
    int output_buffer_size,
    int output_stride,
  ) {
    return _WebPINewRGB(
      csp,
      output_buffer,
      output_buffer_size,
      output_stride,
    );
  }

  late final _WebPINewRGBPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<WebPIDecoder> Function(ffi.Int32, ffi.Pointer<ffi.Uint8>,
              ffi.Size, ffi.Int)>>('WebPINewRGB');
  late final _WebPINewRGB = _WebPINewRGBPtr.asFunction<
      ffi.Pointer<WebPIDecoder> Function(
          int, ffi.Pointer<ffi.Uint8>, int, int)>();

  /// This function allocates and initializes an incremental-decoder object, which
  /// will output the raw luma/chroma samples into a preallocated planes if
  /// supplied. The luma plane is specified by its pointer 'luma', its size
  /// 'luma_size' and its stride 'luma_stride'. Similarly, the chroma-u plane
  /// is specified by the 'u', 'u_size' and 'u_stride' parameters, and the chroma-v
  /// plane by 'v' and 'v_size'. And same for the alpha-plane. The 'a' pointer
  /// can be pass NULL in case one is not interested in the transparency plane.
  /// Conversely, 'luma' can be passed NULL if no preallocated planes are supplied.
  /// In this case, the output buffer will be automatically allocated (using
  /// MODE_YUVA) when decoding starts. All parameters are then ignored.
  /// Returns NULL if the allocation failed or if a parameter is invalid.
  ffi.Pointer<WebPIDecoder> WebPINewYUVA(
    ffi.Pointer<ffi.Uint8> luma,
    int luma_size,
    int luma_stride,
    ffi.Pointer<ffi.Uint8> u,
    int u_size,
    int u_stride,
    ffi.Pointer<ffi.Uint8> v,
    int v_size,
    int v_stride,
    ffi.Pointer<ffi.Uint8> a,
    int a_size,
    int a_stride,
  ) {
    return _WebPINewYUVA(
      luma,
      luma_size,
      luma_stride,
      u,
      u_size,
      u_stride,
      v,
      v_size,
      v_stride,
      a,
      a_size,
      a_stride,
    );
  }

  late final _WebPINewYUVAPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<WebPIDecoder> Function(
              ffi.Pointer<ffi.Uint8>,
              ffi.Size,
              ffi.Int,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size,
              ffi.Int,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size,
              ffi.Int,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size,
              ffi.Int)>>('WebPINewYUVA');
  late final _WebPINewYUVA = _WebPINewYUVAPtr.asFunction<
      ffi.Pointer<WebPIDecoder> Function(
          ffi.Pointer<ffi.Uint8>,
          int,
          int,
          ffi.Pointer<ffi.Uint8>,
          int,
          int,
          ffi.Pointer<ffi.Uint8>,
          int,
          int,
          ffi.Pointer<ffi.Uint8>,
          int,
          int)>();

  /// Deprecated version of the above, without the alpha plane.
  /// Kept for backward compatibility.
  ffi.Pointer<WebPIDecoder> WebPINewYUV(
    ffi.Pointer<ffi.Uint8> luma,
    int luma_size,
    int luma_stride,
    ffi.Pointer<ffi.Uint8> u,
    int u_size,
    int u_stride,
    ffi.Pointer<ffi.Uint8> v,
    int v_size,
    int v_stride,
  ) {
    return _WebPINewYUV(
      luma,
      luma_size,
      luma_stride,
      u,
      u_size,
      u_stride,
      v,
      v_size,
      v_stride,
    );
  }

  late final _WebPINewYUVPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<WebPIDecoder> Function(
              ffi.Pointer<ffi.Uint8>,
              ffi.Size,
              ffi.Int,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size,
              ffi.Int,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size,
              ffi.Int)>>('WebPINewYUV');
  late final _WebPINewYUV = _WebPINewYUVPtr.asFunction<
      ffi.Pointer<WebPIDecoder> Function(
          ffi.Pointer<ffi.Uint8>,
          int,
          int,
          ffi.Pointer<ffi.Uint8>,
          int,
          int,
          ffi.Pointer<ffi.Uint8>,
          int,
          int)>();

  /// Deletes the WebPIDecoder object and associated memory. Must always be called
  /// if WebPINewDecoder, WebPINewRGB or WebPINewYUV succeeded.
  void WebPIDelete(
    ffi.Pointer<WebPIDecoder> idec,
  ) {
    return _WebPIDelete(
      idec,
    );
  }

  late final _WebPIDeletePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<WebPIDecoder>)>>(
          'WebPIDelete');
  late final _WebPIDelete =
      _WebPIDeletePtr.asFunction<void Function(ffi.Pointer<WebPIDecoder>)>();

  /// Copies and decodes the next available data. Returns VP8_STATUS_OK when
  /// the image is successfully decoded. Returns VP8_STATUS_SUSPENDED when more
  /// data is expected. Returns error in other cases.
  int WebPIAppend(
    ffi.Pointer<WebPIDecoder> idec,
    ffi.Pointer<ffi.Uint8> data,
    int data_size,
  ) {
    return _WebPIAppend(
      idec,
      data,
      data_size,
    );
  }

  late final _WebPIAppendPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<WebPIDecoder>, ffi.Pointer<ffi.Uint8>,
              ffi.Size)>>('WebPIAppend');
  late final _WebPIAppend = _WebPIAppendPtr.asFunction<
      int Function(ffi.Pointer<WebPIDecoder>, ffi.Pointer<ffi.Uint8>, int)>();

  /// A variant of the above function to be used when data buffer contains
  /// partial data from the beginning. In this case data buffer is not copied
  /// to the internal memory.
  /// Note that the value of the 'data' pointer can change between calls to
  /// WebPIUpdate, for instance when the data buffer is resized to fit larger data.
  int WebPIUpdate(
    ffi.Pointer<WebPIDecoder> idec,
    ffi.Pointer<ffi.Uint8> data,
    int data_size,
  ) {
    return _WebPIUpdate(
      idec,
      data,
      data_size,
    );
  }

  late final _WebPIUpdatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<WebPIDecoder>, ffi.Pointer<ffi.Uint8>,
              ffi.Size)>>('WebPIUpdate');
  late final _WebPIUpdate = _WebPIUpdatePtr.asFunction<
      int Function(ffi.Pointer<WebPIDecoder>, ffi.Pointer<ffi.Uint8>, int)>();

  /// Returns the RGB/A image decoded so far. Returns NULL if output params
  /// are not initialized yet. The RGB/A output type corresponds to the colorspace
  /// specified during call to WebPINewDecoder() or WebPINewRGB().
  /// *last_y is the index of last decoded row in raster scan order. Some pointers
  /// (*last_y, *width etc.) can be NULL if corresponding information is not
  /// needed. The values in these pointers are only valid on successful (non-NULL)
  /// return.
  ffi.Pointer<ffi.Uint8> WebPIDecGetRGB(
    ffi.Pointer<WebPIDecoder> idec,
    ffi.Pointer<ffi.Int> last_y,
    ffi.Pointer<ffi.Int> width,
    ffi.Pointer<ffi.Int> height,
    ffi.Pointer<ffi.Int> stride,
  ) {
    return _WebPIDecGetRGB(
      idec,
      last_y,
      width,
      height,
      stride,
    );
  }

  late final _WebPIDecGetRGBPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Uint8> Function(
              ffi.Pointer<WebPIDecoder>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('WebPIDecGetRGB');
  late final _WebPIDecGetRGB = _WebPIDecGetRGBPtr.asFunction<
      ffi.Pointer<ffi.Uint8> Function(
          ffi.Pointer<WebPIDecoder>,
          ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Int>)>();

  /// Same as above function to get a YUVA image. Returns pointer to the luma
  /// plane or NULL in case of error. If there is no alpha information
  /// the alpha pointer '*a' will be returned NULL.
  ffi.Pointer<ffi.Uint8> WebPIDecGetYUVA(
    ffi.Pointer<WebPIDecoder> idec,
    ffi.Pointer<ffi.Int> last_y,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> u,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> v,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> a,
    ffi.Pointer<ffi.Int> width,
    ffi.Pointer<ffi.Int> height,
    ffi.Pointer<ffi.Int> stride,
    ffi.Pointer<ffi.Int> uv_stride,
    ffi.Pointer<ffi.Int> a_stride,
  ) {
    return _WebPIDecGetYUVA(
      idec,
      last_y,
      u,
      v,
      a,
      width,
      height,
      stride,
      uv_stride,
      a_stride,
    );
  }

  late final _WebPIDecGetYUVAPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Uint8> Function(
              ffi.Pointer<WebPIDecoder>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('WebPIDecGetYUVA');
  late final _WebPIDecGetYUVA = _WebPIDecGetYUVAPtr.asFunction<
      ffi.Pointer<ffi.Uint8> Function(
          ffi.Pointer<WebPIDecoder>,
          ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
          ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
          ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
          ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Int>)>();

  /// Generic call to retrieve information about the displayable area.
  /// If non NULL, the left/right/width/height pointers are filled with the visible
  /// rectangular area so far.
  /// Returns NULL in case the incremental decoder object is in an invalid state.
  /// Otherwise returns the pointer to the internal representation. This structure
  /// is read-only, tied to WebPIDecoder's lifespan and should not be modified.
  ffi.Pointer<WebPDecBuffer> WebPIDecodedArea(
    ffi.Pointer<WebPIDecoder> idec,
    ffi.Pointer<ffi.Int> left,
    ffi.Pointer<ffi.Int> top,
    ffi.Pointer<ffi.Int> width,
    ffi.Pointer<ffi.Int> height,
  ) {
    return _WebPIDecodedArea(
      idec,
      left,
      top,
      width,
      height,
    );
  }

  late final _WebPIDecodedAreaPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<WebPDecBuffer> Function(
              ffi.Pointer<WebPIDecoder>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('WebPIDecodedArea');
  late final _WebPIDecodedArea = _WebPIDecodedAreaPtr.asFunction<
      ffi.Pointer<WebPDecBuffer> Function(
          ffi.Pointer<WebPIDecoder>,
          ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Int>)>();

  /// Internal, version-checked, entry point
  int WebPGetFeaturesInternal(
    ffi.Pointer<ffi.Uint8> arg0,
    int arg1,
    ffi.Pointer<WebPBitstreamFeatures> arg2,
    int arg3,
  ) {
    return _WebPGetFeaturesInternal(
      arg0,
      arg1,
      arg2,
      arg3,
    );
  }

  late final _WebPGetFeaturesInternalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ffi.Uint8>,
              ffi.Size,
              ffi.Pointer<WebPBitstreamFeatures>,
              ffi.Int)>>('WebPGetFeaturesInternal');
  late final _WebPGetFeaturesInternal = _WebPGetFeaturesInternalPtr.asFunction<
      int Function(ffi.Pointer<ffi.Uint8>, int,
          ffi.Pointer<WebPBitstreamFeatures>, int)>();

  /// Internal, version-checked, entry point
  int WebPInitDecoderConfigInternal(
    ffi.Pointer<WebPDecoderConfig> arg0,
    int arg1,
  ) {
    return _WebPInitDecoderConfigInternal(
      arg0,
      arg1,
    );
  }

  late final _WebPInitDecoderConfigInternalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<WebPDecoderConfig>,
              ffi.Int)>>('WebPInitDecoderConfigInternal');
  late final _WebPInitDecoderConfigInternal = _WebPInitDecoderConfigInternalPtr
      .asFunction<int Function(ffi.Pointer<WebPDecoderConfig>, int)>();

  /// Instantiate a new incremental decoder object with the requested
  /// configuration. The bitstream can be passed using 'data' and 'data_size'
  /// parameter, in which case the features will be parsed and stored into
  /// config->input. Otherwise, 'data' can be NULL and no parsing will occur.
  /// Note that 'config' can be NULL too, in which case a default configuration
  /// is used. If 'config' is not NULL, it must outlive the WebPIDecoder object
  /// as some references to its fields will be used. No internal copy of 'config'
  /// is made.
  /// The return WebPIDecoder object must always be deleted calling WebPIDelete().
  /// Returns NULL in case of error (and config->status will then reflect
  /// the error condition, if available).
  ffi.Pointer<WebPIDecoder> WebPIDecode(
    ffi.Pointer<ffi.Uint8> data,
    int data_size,
    ffi.Pointer<WebPDecoderConfig> config,
  ) {
    return _WebPIDecode(
      data,
      data_size,
      config,
    );
  }

  late final _WebPIDecodePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<WebPIDecoder> Function(ffi.Pointer<ffi.Uint8>, ffi.Size,
              ffi.Pointer<WebPDecoderConfig>)>>('WebPIDecode');
  late final _WebPIDecode = _WebPIDecodePtr.asFunction<
      ffi.Pointer<WebPIDecoder> Function(
          ffi.Pointer<ffi.Uint8>, int, ffi.Pointer<WebPDecoderConfig>)>();

  /// Non-incremental version. This version decodes the full data at once, taking
  /// 'config' into account. Returns decoding status (which should be VP8_STATUS_OK
  /// if the decoding was successful). Note that 'config' cannot be NULL.
  int WebPDecode(
    ffi.Pointer<ffi.Uint8> data,
    int data_size,
    ffi.Pointer<WebPDecoderConfig> config,
  ) {
    return _WebPDecode(
      data,
      data_size,
      config,
    );
  }

  late final _WebPDecodePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<ffi.Uint8>, ffi.Size,
              ffi.Pointer<WebPDecoderConfig>)>>('WebPDecode');
  late final _WebPDecode = _WebPDecodePtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Uint8>, int, ffi.Pointer<WebPDecoderConfig>)>();

  ffi.Pointer<ffi.UnsignedLong> __doserrno() {
    return ___doserrno();
  }

  late final ___doserrnoPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.UnsignedLong> Function()>>(
          '__doserrno');
  late final ___doserrno =
      ___doserrnoPtr.asFunction<ffi.Pointer<ffi.UnsignedLong> Function()>();

  int _set_doserrno(
    int _Value,
  ) {
    return __set_doserrno(
      _Value,
    );
  }

  late final __set_doserrnoPtr =
      _lookup<ffi.NativeFunction<errno_t Function(ffi.UnsignedLong)>>(
          '_set_doserrno');
  late final __set_doserrno = __set_doserrnoPtr.asFunction<int Function(int)>();

  int _get_doserrno(
    ffi.Pointer<ffi.UnsignedLong> _Value,
  ) {
    return __get_doserrno(
      _Value,
    );
  }

  late final __get_doserrnoPtr = _lookup<
          ffi.NativeFunction<errno_t Function(ffi.Pointer<ffi.UnsignedLong>)>>(
      '_get_doserrno');
  late final __get_doserrno = __get_doserrnoPtr
      .asFunction<int Function(ffi.Pointer<ffi.UnsignedLong>)>();

  ffi.Pointer<ffi.Void> memchr(
    ffi.Pointer<ffi.Void> _Buf,
    int _Val,
    int _MaxCount,
  ) {
    return _memchr(
      _Buf,
      _Val,
      _MaxCount,
    );
  }

  late final _memchrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Int, ffi.Size)>>('memchr');
  late final _memchr = _memchrPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int, int)>();

  int memcmp(
    ffi.Pointer<ffi.Void> _Buf1,
    ffi.Pointer<ffi.Void> _Buf2,
    int _Size,
  ) {
    return _memcmp(
      _Buf1,
      _Buf2,
      _Size,
    );
  }

  late final _memcmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('memcmp');
  late final _memcmp = _memcmpPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> memcpy(
    ffi.Pointer<ffi.Void> _Dst,
    ffi.Pointer<ffi.Void> _Src,
    int _Size,
  ) {
    return _memcpy(
      _Dst,
      _Src,
      _Size,
    );
  }

  late final _memcpyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('memcpy');
  late final _memcpy = _memcpyPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> memmove(
    ffi.Pointer<ffi.Void> _Dst,
    ffi.Pointer<ffi.Void> _Src,
    int _Size,
  ) {
    return _memmove(
      _Dst,
      _Src,
      _Size,
    );
  }

  late final _memmovePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('memmove');
  late final _memmove = _memmovePtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> memset(
    ffi.Pointer<ffi.Void> _Dst,
    int _Val,
    int _Size,
  ) {
    return _memset(
      _Dst,
      _Val,
      _Size,
    );
  }

  late final _memsetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Int, ffi.Size)>>('memset');
  late final _memset = _memsetPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int, int)>();

  ffi.Pointer<ffi.Char> strchr(
    ffi.Pointer<ffi.Char> _Str,
    int _Val,
  ) {
    return _strchr(
      _Str,
      _Val,
    );
  }

  late final _strchrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('strchr');
  late final _strchr = _strchrPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> strrchr(
    ffi.Pointer<ffi.Char> _Str,
    int _Ch,
  ) {
    return _strrchr(
      _Str,
      _Ch,
    );
  }

  late final _strrchrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('strrchr');
  late final _strrchr = _strrchrPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> strstr(
    ffi.Pointer<ffi.Char> _Str,
    ffi.Pointer<ffi.Char> _SubStr,
  ) {
    return _strstr(
      _Str,
      _SubStr,
    );
  }

  late final _strstrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strstr');
  late final _strstr = _strstrPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.UnsignedShort> wcschr(
    ffi.Pointer<ffi.WChar> _Str,
    int _Ch,
  ) {
    return _wcschr(
      _Str,
      _Ch,
    );
  }

  late final _wcschrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.UnsignedShort> Function(
              ffi.Pointer<ffi.WChar>, ffi.WChar)>>('wcschr');
  late final _wcschr = _wcschrPtr.asFunction<
      ffi.Pointer<ffi.UnsignedShort> Function(ffi.Pointer<ffi.WChar>, int)>();

  ffi.Pointer<ffi.WChar> wcsrchr(
    ffi.Pointer<ffi.WChar> _Str,
    int _Ch,
  ) {
    return _wcsrchr(
      _Str,
      _Ch,
    );
  }

  late final _wcsrchrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<ffi.WChar>, ffi.WChar)>>('wcsrchr');
  late final _wcsrchr = _wcsrchrPtr.asFunction<
      ffi.Pointer<ffi.WChar> Function(ffi.Pointer<ffi.WChar>, int)>();

  ffi.Pointer<ffi.WChar> wcsstr(
    ffi.Pointer<ffi.WChar> _Str,
    ffi.Pointer<ffi.WChar> _SubStr,
  ) {
    return _wcsstr(
      _Str,
      _SubStr,
    );
  }

  late final _wcsstrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>>('wcsstr');
  late final _wcsstr = _wcsstrPtr.asFunction<
      ffi.Pointer<ffi.WChar> Function(
          ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int _memicmp(
    ffi.Pointer<ffi.Void> _Buf1,
    ffi.Pointer<ffi.Void> _Buf2,
    int _Size,
  ) {
    return __memicmp(
      _Buf1,
      _Buf2,
      _Size,
    );
  }

  late final __memicmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('_memicmp');
  late final __memicmp = __memicmpPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  int _memicmp_l(
    ffi.Pointer<ffi.Void> _Buf1,
    ffi.Pointer<ffi.Void> _Buf2,
    int _Size,
    _locale_t _Locale,
  ) {
    return __memicmp_l(
      _Buf1,
      _Buf2,
      _Size,
      _Locale,
    );
  }

  late final __memicmp_lPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Size, _locale_t)>>('_memicmp_l');
  late final __memicmp_l = __memicmp_lPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, _locale_t)>();

  ffi.Pointer<ffi.Void> memccpy(
    ffi.Pointer<ffi.Void> _Dst,
    ffi.Pointer<ffi.Void> _Src,
    int _Val,
    int _Size,
  ) {
    return _memccpy1(
      _Dst,
      _Src,
      _Val,
      _Size,
    );
  }

  late final _memccpyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Int, ffi.Size)>>('memccpy');
  late final _memccpy1 = _memccpyPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int)>();

  int memicmp(
    ffi.Pointer<ffi.Void> _Buf1,
    ffi.Pointer<ffi.Void> _Buf2,
    int _Size,
  ) {
    return _memicmp1(
      _Buf1,
      _Buf2,
      _Size,
    );
  }

  late final _memicmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('memicmp');
  late final _memicmp1 = _memicmpPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  int wcscat_s(
    ffi.Pointer<ffi.WChar> _Destination,
    int _SizeInWords,
    ffi.Pointer<ffi.WChar> _Source,
  ) {
    return _wcscat_s(
      _Destination,
      _SizeInWords,
      _Source,
    );
  }

  late final _wcscat_sPtr = _lookup<
      ffi.NativeFunction<
          errno_t Function(ffi.Pointer<ffi.WChar>, rsize_t,
              ffi.Pointer<ffi.WChar>)>>('wcscat_s');
  late final _wcscat_s = _wcscat_sPtr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, int, ffi.Pointer<ffi.WChar>)>();

  int wcscpy_s(
    ffi.Pointer<ffi.WChar> _Destination,
    int _SizeInWords,
    ffi.Pointer<ffi.WChar> _Source,
  ) {
    return _wcscpy_s(
      _Destination,
      _SizeInWords,
      _Source,
    );
  }

  late final _wcscpy_sPtr = _lookup<
      ffi.NativeFunction<
          errno_t Function(ffi.Pointer<ffi.WChar>, rsize_t,
              ffi.Pointer<ffi.WChar>)>>('wcscpy_s');
  late final _wcscpy_s = _wcscpy_sPtr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, int, ffi.Pointer<ffi.WChar>)>();

  int wcsncat_s(
    ffi.Pointer<ffi.WChar> _Destination,
    int _SizeInWords,
    ffi.Pointer<ffi.WChar> _Source,
    int _MaxCount,
  ) {
    return _wcsncat_s(
      _Destination,
      _SizeInWords,
      _Source,
      _MaxCount,
    );
  }

  late final _wcsncat_sPtr = _lookup<
      ffi.NativeFunction<
          errno_t Function(ffi.Pointer<ffi.WChar>, rsize_t,
              ffi.Pointer<ffi.WChar>, rsize_t)>>('wcsncat_s');
  late final _wcsncat_s = _wcsncat_sPtr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, int, ffi.Pointer<ffi.WChar>, int)>();

  int wcsncpy_s(
    ffi.Pointer<ffi.WChar> _Destination,
    int _SizeInWords,
    ffi.Pointer<ffi.WChar> _Source,
    int _MaxCount,
  ) {
    return _wcsncpy_s(
      _Destination,
      _SizeInWords,
      _Source,
      _MaxCount,
    );
  }

  late final _wcsncpy_sPtr = _lookup<
      ffi.NativeFunction<
          errno_t Function(ffi.Pointer<ffi.WChar>, rsize_t,
              ffi.Pointer<ffi.WChar>, rsize_t)>>('wcsncpy_s');
  late final _wcsncpy_s = _wcsncpy_sPtr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, int, ffi.Pointer<ffi.WChar>, int)>();

  ffi.Pointer<ffi.WChar> wcstok_s(
    ffi.Pointer<ffi.WChar> _String,
    ffi.Pointer<ffi.WChar> _Delimiter,
    ffi.Pointer<ffi.Pointer<ffi.WChar>> _Context,
  ) {
    return _wcstok_s(
      _String,
      _Delimiter,
      _Context,
    );
  }

  late final _wcstok_sPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<ffi.WChar>,
              ffi.Pointer<ffi.WChar>,
              ffi.Pointer<ffi.Pointer<ffi.WChar>>)>>('wcstok_s');
  late final _wcstok_s = _wcstok_sPtr.asFunction<
      ffi.Pointer<ffi.WChar> Function(ffi.Pointer<ffi.WChar>,
          ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.Pointer<ffi.WChar>>)>();

  ffi.Pointer<ffi.WChar> _wcsdup(
    ffi.Pointer<ffi.WChar> _String,
  ) {
    return __wcsdup(
      _String,
    );
  }

  late final __wcsdupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(ffi.Pointer<ffi.WChar>)>>('_wcsdup');
  late final __wcsdup = __wcsdupPtr
      .asFunction<ffi.Pointer<ffi.WChar> Function(ffi.Pointer<ffi.WChar>)>();

  ffi.Pointer<ffi.WChar> wcscat(
    ffi.Pointer<ffi.WChar> _Destination,
    ffi.Pointer<ffi.WChar> _Source,
  ) {
    return _wcscat(
      _Destination,
      _Source,
    );
  }

  late final _wcscatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>>('wcscat');
  late final _wcscat = _wcscatPtr.asFunction<
      ffi.Pointer<ffi.WChar> Function(
          ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int wcscmp(
    ffi.Pointer<ffi.WChar> _String1,
    ffi.Pointer<ffi.WChar> _String2,
  ) {
    return _wcscmp(
      _String1,
      _String2,
    );
  }

  late final _wcscmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>>('wcscmp');
  late final _wcscmp = _wcscmpPtr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  ffi.Pointer<ffi.WChar> wcscpy(
    ffi.Pointer<ffi.WChar> _Destination,
    ffi.Pointer<ffi.WChar> _Source,
  ) {
    return _wcscpy(
      _Destination,
      _Source,
    );
  }

  late final _wcscpyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>>('wcscpy');
  late final _wcscpy = _wcscpyPtr.asFunction<
      ffi.Pointer<ffi.WChar> Function(
          ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int wcscspn(
    ffi.Pointer<ffi.WChar> _String,
    ffi.Pointer<ffi.WChar> _Control,
  ) {
    return _wcscspn(
      _String,
      _Control,
    );
  }

  late final _wcscspnPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(
              ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>>('wcscspn');
  late final _wcscspn = _wcscspnPtr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int wcslen(
    ffi.Pointer<ffi.WChar> _String,
  ) {
    return _wcslen(
      _String,
    );
  }

  late final _wcslenPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLongLong Function(ffi.Pointer<ffi.WChar>)>>('wcslen');
  late final _wcslen =
      _wcslenPtr.asFunction<int Function(ffi.Pointer<ffi.WChar>)>();

  int wcsnlen(
    ffi.Pointer<ffi.WChar> _Source,
    int _MaxCount,
  ) {
    return _wcsnlen(
      _Source,
      _MaxCount,
    );
  }

  late final _wcsnlenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.WChar>, ffi.Size)>>('wcsnlen');
  late final _wcsnlen =
      _wcsnlenPtr.asFunction<int Function(ffi.Pointer<ffi.WChar>, int)>();

  ffi.Pointer<ffi.WChar> wcsncat(
    ffi.Pointer<ffi.WChar> _Destination,
    ffi.Pointer<ffi.WChar> _Source,
    int _Count,
  ) {
    return _wcsncat(
      _Destination,
      _Source,
      _Count,
    );
  }

  late final _wcsncatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(ffi.Pointer<ffi.WChar>,
              ffi.Pointer<ffi.WChar>, ffi.Size)>>('wcsncat');
  late final _wcsncat = _wcsncatPtr.asFunction<
      ffi.Pointer<ffi.WChar> Function(
          ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int wcsncmp(
    ffi.Pointer<ffi.WChar> _String1,
    ffi.Pointer<ffi.WChar> _String2,
    int _MaxCount,
  ) {
    return _wcsncmp(
      _String1,
      _String2,
      _MaxCount,
    );
  }

  late final _wcsncmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('wcsncmp');
  late final _wcsncmp = _wcsncmpPtr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  ffi.Pointer<ffi.WChar> wcsncpy(
    ffi.Pointer<ffi.WChar> _Destination,
    ffi.Pointer<ffi.WChar> _Source,
    int _Count,
  ) {
    return _wcsncpy(
      _Destination,
      _Source,
      _Count,
    );
  }

  late final _wcsncpyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(ffi.Pointer<ffi.WChar>,
              ffi.Pointer<ffi.WChar>, ffi.Size)>>('wcsncpy');
  late final _wcsncpy = _wcsncpyPtr.asFunction<
      ffi.Pointer<ffi.WChar> Function(
          ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  ffi.Pointer<ffi.WChar> wcspbrk(
    ffi.Pointer<ffi.WChar> _String,
    ffi.Pointer<ffi.WChar> _Control,
  ) {
    return _wcspbrk(
      _String,
      _Control,
    );
  }

  late final _wcspbrkPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>>('wcspbrk');
  late final _wcspbrk = _wcspbrkPtr.asFunction<
      ffi.Pointer<ffi.WChar> Function(
          ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int wcsspn(
    ffi.Pointer<ffi.WChar> _String,
    ffi.Pointer<ffi.WChar> _Control,
  ) {
    return _wcsspn(
      _String,
      _Control,
    );
  }

  late final _wcsspnPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(
              ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>>('wcsspn');
  late final _wcsspn = _wcsspnPtr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  ffi.Pointer<ffi.WChar> wcstok(
    ffi.Pointer<ffi.WChar> _String,
    ffi.Pointer<ffi.WChar> _Delimiter,
    ffi.Pointer<ffi.Pointer<ffi.WChar>> _Context,
  ) {
    return _wcstok(
      _String,
      _Delimiter,
      _Context,
    );
  }

  late final _wcstokPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<ffi.WChar>,
              ffi.Pointer<ffi.WChar>,
              ffi.Pointer<ffi.Pointer<ffi.WChar>>)>>('wcstok');
  late final _wcstok = _wcstokPtr.asFunction<
      ffi.Pointer<ffi.WChar> Function(ffi.Pointer<ffi.WChar>,
          ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.Pointer<ffi.WChar>>)>();

  ffi.Pointer<ffi.WChar> _wcserror(
    int _ErrorNumber,
  ) {
    return __wcserror1(
      _ErrorNumber,
    );
  }

  late final __wcserrorPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.WChar> Function(ffi.Int)>>(
          '_wcserror');
  late final __wcserror1 =
      __wcserrorPtr.asFunction<ffi.Pointer<ffi.WChar> Function(int)>();

  int _wcserror_s(
    ffi.Pointer<ffi.WChar> _Buffer,
    int _SizeInWords,
    int _ErrorNumber,
  ) {
    return __wcserror_s1(
      _Buffer,
      _SizeInWords,
      _ErrorNumber,
    );
  }

  late final __wcserror_sPtr = _lookup<
      ffi.NativeFunction<
          errno_t Function(
              ffi.Pointer<ffi.WChar>, ffi.Size, ffi.Int)>>('_wcserror_s');
  late final __wcserror_s1 = __wcserror_sPtr
      .asFunction<int Function(ffi.Pointer<ffi.WChar>, int, int)>();

  ffi.Pointer<ffi.WChar> __wcserror(
    ffi.Pointer<ffi.WChar> _String,
  ) {
    return ___wcserror(
      _String,
    );
  }

  late final ___wcserrorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<ffi.WChar>)>>('__wcserror');
  late final ___wcserror = ___wcserrorPtr
      .asFunction<ffi.Pointer<ffi.WChar> Function(ffi.Pointer<ffi.WChar>)>();

  int __wcserror_s(
    ffi.Pointer<ffi.WChar> _Buffer,
    int _SizeInWords,
    ffi.Pointer<ffi.WChar> _ErrorMessage,
  ) {
    return ___wcserror_s(
      _Buffer,
      _SizeInWords,
      _ErrorMessage,
    );
  }

  late final ___wcserror_sPtr = _lookup<
      ffi.NativeFunction<
          errno_t Function(ffi.Pointer<ffi.WChar>, ffi.Size,
              ffi.Pointer<ffi.WChar>)>>('__wcserror_s');
  late final ___wcserror_s = ___wcserror_sPtr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, int, ffi.Pointer<ffi.WChar>)>();

  int _wcsicmp(
    ffi.Pointer<ffi.WChar> _String1,
    ffi.Pointer<ffi.WChar> _String2,
  ) {
    return __wcsicmp(
      _String1,
      _String2,
    );
  }

  late final __wcsicmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>>('_wcsicmp');
  late final __wcsicmp = __wcsicmpPtr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int _wcsicmp_l(
    ffi.Pointer<ffi.WChar> _String1,
    ffi.Pointer<ffi.WChar> _String2,
    _locale_t _Locale,
  ) {
    return __wcsicmp_l(
      _String1,
      _String2,
      _Locale,
    );
  }

  late final __wcsicmp_lPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              _locale_t)>>('_wcsicmp_l');
  late final __wcsicmp_l = __wcsicmp_lPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, _locale_t)>();

  int _wcsnicmp(
    ffi.Pointer<ffi.WChar> _String1,
    ffi.Pointer<ffi.WChar> _String2,
    int _MaxCount,
  ) {
    return __wcsnicmp(
      _String1,
      _String2,
      _MaxCount,
    );
  }

  late final __wcsnicmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('_wcsnicmp');
  late final __wcsnicmp = __wcsnicmpPtr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int _wcsnicmp_l(
    ffi.Pointer<ffi.WChar> _String1,
    ffi.Pointer<ffi.WChar> _String2,
    int _MaxCount,
    _locale_t _Locale,
  ) {
    return __wcsnicmp_l(
      _String1,
      _String2,
      _MaxCount,
      _Locale,
    );
  }

  late final __wcsnicmp_lPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size, _locale_t)>>('_wcsnicmp_l');
  late final __wcsnicmp_l = __wcsnicmp_lPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int, _locale_t)>();

  int _wcsnset_s(
    ffi.Pointer<ffi.WChar> _Destination,
    int _SizeInWords,
    int _Value,
    int _MaxCount,
  ) {
    return __wcsnset_s(
      _Destination,
      _SizeInWords,
      _Value,
      _MaxCount,
    );
  }

  late final __wcsnset_sPtr = _lookup<
      ffi.NativeFunction<
          errno_t Function(ffi.Pointer<ffi.WChar>, ffi.Size, ffi.WChar,
              ffi.Size)>>('_wcsnset_s');
  late final __wcsnset_s = __wcsnset_sPtr
      .asFunction<int Function(ffi.Pointer<ffi.WChar>, int, int, int)>();

  ffi.Pointer<ffi.WChar> _wcsnset(
    ffi.Pointer<ffi.WChar> _String,
    int _Value,
    int _MaxCount,
  ) {
    return __wcsnset(
      _String,
      _Value,
      _MaxCount,
    );
  }

  late final __wcsnsetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<ffi.WChar>, ffi.WChar, ffi.Size)>>('_wcsnset');
  late final __wcsnset = __wcsnsetPtr.asFunction<
      ffi.Pointer<ffi.WChar> Function(ffi.Pointer<ffi.WChar>, int, int)>();

  ffi.Pointer<ffi.WChar> _wcsrev(
    ffi.Pointer<ffi.WChar> _String,
  ) {
    return __wcsrev(
      _String,
    );
  }

  late final __wcsrevPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(ffi.Pointer<ffi.WChar>)>>('_wcsrev');
  late final __wcsrev = __wcsrevPtr
      .asFunction<ffi.Pointer<ffi.WChar> Function(ffi.Pointer<ffi.WChar>)>();

  int _wcsset_s(
    ffi.Pointer<ffi.WChar> _Destination,
    int _SizeInWords,
    int _Value,
  ) {
    return __wcsset_s(
      _Destination,
      _SizeInWords,
      _Value,
    );
  }

  late final __wcsset_sPtr = _lookup<
      ffi.NativeFunction<
          errno_t Function(
              ffi.Pointer<ffi.WChar>, ffi.Size, ffi.WChar)>>('_wcsset_s');
  late final __wcsset_s = __wcsset_sPtr
      .asFunction<int Function(ffi.Pointer<ffi.WChar>, int, int)>();

  ffi.Pointer<ffi.WChar> _wcsset(
    ffi.Pointer<ffi.WChar> _String,
    int _Value,
  ) {
    return __wcsset(
      _String,
      _Value,
    );
  }

  late final __wcssetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<ffi.WChar>, ffi.WChar)>>('_wcsset');
  late final __wcsset = __wcssetPtr.asFunction<
      ffi.Pointer<ffi.WChar> Function(ffi.Pointer<ffi.WChar>, int)>();

  int _wcslwr_s(
    ffi.Pointer<ffi.WChar> _String,
    int _SizeInWords,
  ) {
    return __wcslwr_s(
      _String,
      _SizeInWords,
    );
  }

  late final __wcslwr_sPtr = _lookup<
      ffi.NativeFunction<
          errno_t Function(ffi.Pointer<ffi.WChar>, ffi.Size)>>('_wcslwr_s');
  late final __wcslwr_s =
      __wcslwr_sPtr.asFunction<int Function(ffi.Pointer<ffi.WChar>, int)>();

  ffi.Pointer<ffi.WChar> _wcslwr(
    ffi.Pointer<ffi.WChar> _String,
  ) {
    return __wcslwr(
      _String,
    );
  }

  late final __wcslwrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(ffi.Pointer<ffi.WChar>)>>('_wcslwr');
  late final __wcslwr = __wcslwrPtr
      .asFunction<ffi.Pointer<ffi.WChar> Function(ffi.Pointer<ffi.WChar>)>();

  int _wcslwr_s_l(
    ffi.Pointer<ffi.WChar> _String,
    int _SizeInWords,
    _locale_t _Locale,
  ) {
    return __wcslwr_s_l(
      _String,
      _SizeInWords,
      _Locale,
    );
  }

  late final __wcslwr_s_lPtr = _lookup<
      ffi.NativeFunction<
          errno_t Function(
              ffi.Pointer<ffi.WChar>, ffi.Size, _locale_t)>>('_wcslwr_s_l');
  late final __wcslwr_s_l = __wcslwr_s_lPtr
      .asFunction<int Function(ffi.Pointer<ffi.WChar>, int, _locale_t)>();

  ffi.Pointer<ffi.WChar> _wcslwr_l(
    ffi.Pointer<ffi.WChar> _String,
    _locale_t _Locale,
  ) {
    return __wcslwr_l(
      _String,
      _Locale,
    );
  }

  late final __wcslwr_lPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<ffi.WChar>, _locale_t)>>('_wcslwr_l');
  late final __wcslwr_l = __wcslwr_lPtr.asFunction<
      ffi.Pointer<ffi.WChar> Function(ffi.Pointer<ffi.WChar>, _locale_t)>();

  int _wcsupr_s(
    ffi.Pointer<ffi.WChar> _String,
    int _Size,
  ) {
    return __wcsupr_s(
      _String,
      _Size,
    );
  }

  late final __wcsupr_sPtr = _lookup<
      ffi.NativeFunction<
          errno_t Function(ffi.Pointer<ffi.WChar>, ffi.Size)>>('_wcsupr_s');
  late final __wcsupr_s =
      __wcsupr_sPtr.asFunction<int Function(ffi.Pointer<ffi.WChar>, int)>();

  ffi.Pointer<ffi.WChar> _wcsupr(
    ffi.Pointer<ffi.WChar> _String,
  ) {
    return __wcsupr(
      _String,
    );
  }

  late final __wcsuprPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(ffi.Pointer<ffi.WChar>)>>('_wcsupr');
  late final __wcsupr = __wcsuprPtr
      .asFunction<ffi.Pointer<ffi.WChar> Function(ffi.Pointer<ffi.WChar>)>();

  int _wcsupr_s_l(
    ffi.Pointer<ffi.WChar> _String,
    int _Size,
    _locale_t _Locale,
  ) {
    return __wcsupr_s_l(
      _String,
      _Size,
      _Locale,
    );
  }

  late final __wcsupr_s_lPtr = _lookup<
      ffi.NativeFunction<
          errno_t Function(
              ffi.Pointer<ffi.WChar>, ffi.Size, _locale_t)>>('_wcsupr_s_l');
  late final __wcsupr_s_l = __wcsupr_s_lPtr
      .asFunction<int Function(ffi.Pointer<ffi.WChar>, int, _locale_t)>();

  ffi.Pointer<ffi.WChar> _wcsupr_l(
    ffi.Pointer<ffi.WChar> _String,
    _locale_t _Locale,
  ) {
    return __wcsupr_l(
      _String,
      _Locale,
    );
  }

  late final __wcsupr_lPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<ffi.WChar>, _locale_t)>>('_wcsupr_l');
  late final __wcsupr_l = __wcsupr_lPtr.asFunction<
      ffi.Pointer<ffi.WChar> Function(ffi.Pointer<ffi.WChar>, _locale_t)>();

  int wcsxfrm(
    ffi.Pointer<ffi.WChar> _Destination,
    ffi.Pointer<ffi.WChar> _Source,
    int _MaxCount,
  ) {
    return _wcsxfrm(
      _Destination,
      _Source,
      _MaxCount,
    );
  }

  late final _wcsxfrmPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('wcsxfrm');
  late final _wcsxfrm = _wcsxfrmPtr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int _wcsxfrm_l(
    ffi.Pointer<ffi.WChar> _Destination,
    ffi.Pointer<ffi.WChar> _Source,
    int _MaxCount,
    _locale_t _Locale,
  ) {
    return __wcsxfrm_l(
      _Destination,
      _Source,
      _MaxCount,
      _Locale,
    );
  }

  late final __wcsxfrm_lPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size, _locale_t)>>('_wcsxfrm_l');
  late final __wcsxfrm_l = __wcsxfrm_lPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int, _locale_t)>();

  int wcscoll(
    ffi.Pointer<ffi.WChar> _String1,
    ffi.Pointer<ffi.WChar> _String2,
  ) {
    return _wcscoll(
      _String1,
      _String2,
    );
  }

  late final _wcscollPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>>('wcscoll');
  late final _wcscoll = _wcscollPtr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int _wcscoll_l(
    ffi.Pointer<ffi.WChar> _String1,
    ffi.Pointer<ffi.WChar> _String2,
    _locale_t _Locale,
  ) {
    return __wcscoll_l(
      _String1,
      _String2,
      _Locale,
    );
  }

  late final __wcscoll_lPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              _locale_t)>>('_wcscoll_l');
  late final __wcscoll_l = __wcscoll_lPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, _locale_t)>();

  int _wcsicoll(
    ffi.Pointer<ffi.WChar> _String1,
    ffi.Pointer<ffi.WChar> _String2,
  ) {
    return __wcsicoll(
      _String1,
      _String2,
    );
  }

  late final __wcsicollPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>>('_wcsicoll');
  late final __wcsicoll = __wcsicollPtr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int _wcsicoll_l(
    ffi.Pointer<ffi.WChar> _String1,
    ffi.Pointer<ffi.WChar> _String2,
    _locale_t _Locale,
  ) {
    return __wcsicoll_l(
      _String1,
      _String2,
      _Locale,
    );
  }

  late final __wcsicoll_lPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              _locale_t)>>('_wcsicoll_l');
  late final __wcsicoll_l = __wcsicoll_lPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, _locale_t)>();

  int _wcsncoll(
    ffi.Pointer<ffi.WChar> _String1,
    ffi.Pointer<ffi.WChar> _String2,
    int _MaxCount,
  ) {
    return __wcsncoll(
      _String1,
      _String2,
      _MaxCount,
    );
  }

  late final __wcsncollPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('_wcsncoll');
  late final __wcsncoll = __wcsncollPtr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int _wcsncoll_l(
    ffi.Pointer<ffi.WChar> _String1,
    ffi.Pointer<ffi.WChar> _String2,
    int _MaxCount,
    _locale_t _Locale,
  ) {
    return __wcsncoll_l(
      _String1,
      _String2,
      _MaxCount,
      _Locale,
    );
  }

  late final __wcsncoll_lPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size, _locale_t)>>('_wcsncoll_l');
  late final __wcsncoll_l = __wcsncoll_lPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int, _locale_t)>();

  int _wcsnicoll(
    ffi.Pointer<ffi.WChar> _String1,
    ffi.Pointer<ffi.WChar> _String2,
    int _MaxCount,
  ) {
    return __wcsnicoll(
      _String1,
      _String2,
      _MaxCount,
    );
  }

  late final __wcsnicollPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('_wcsnicoll');
  late final __wcsnicoll = __wcsnicollPtr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  int _wcsnicoll_l(
    ffi.Pointer<ffi.WChar> _String1,
    ffi.Pointer<ffi.WChar> _String2,
    int _MaxCount,
    _locale_t _Locale,
  ) {
    return __wcsnicoll_l(
      _String1,
      _String2,
      _MaxCount,
      _Locale,
    );
  }

  late final __wcsnicoll_lPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size, _locale_t)>>('_wcsnicoll_l');
  late final __wcsnicoll_l = __wcsnicoll_lPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int, _locale_t)>();

  ffi.Pointer<ffi.WChar> wcsdup(
    ffi.Pointer<ffi.WChar> _String,
  ) {
    return _wcsdup1(
      _String,
    );
  }

  late final _wcsdupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(ffi.Pointer<ffi.WChar>)>>('wcsdup');
  late final _wcsdup1 = _wcsdupPtr
      .asFunction<ffi.Pointer<ffi.WChar> Function(ffi.Pointer<ffi.WChar>)>();

  int wcsicmp(
    ffi.Pointer<ffi.WChar> _String1,
    ffi.Pointer<ffi.WChar> _String2,
  ) {
    return _wcsicmp1(
      _String1,
      _String2,
    );
  }

  late final _wcsicmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>>('wcsicmp');
  late final _wcsicmp1 = _wcsicmpPtr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int wcsnicmp(
    ffi.Pointer<ffi.WChar> _String1,
    ffi.Pointer<ffi.WChar> _String2,
    int _MaxCount,
  ) {
    return _wcsnicmp1(
      _String1,
      _String2,
      _MaxCount,
    );
  }

  late final _wcsnicmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('wcsnicmp');
  late final _wcsnicmp1 = _wcsnicmpPtr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>, int)>();

  ffi.Pointer<ffi.WChar> wcsnset(
    ffi.Pointer<ffi.WChar> _String,
    int _Value,
    int _MaxCount,
  ) {
    return _wcsnset1(
      _String,
      _Value,
      _MaxCount,
    );
  }

  late final _wcsnsetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<ffi.WChar>, ffi.WChar, ffi.Size)>>('wcsnset');
  late final _wcsnset1 = _wcsnsetPtr.asFunction<
      ffi.Pointer<ffi.WChar> Function(ffi.Pointer<ffi.WChar>, int, int)>();

  ffi.Pointer<ffi.WChar> wcsrev(
    ffi.Pointer<ffi.WChar> _String,
  ) {
    return _wcsrev1(
      _String,
    );
  }

  late final _wcsrevPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(ffi.Pointer<ffi.WChar>)>>('wcsrev');
  late final _wcsrev1 = _wcsrevPtr
      .asFunction<ffi.Pointer<ffi.WChar> Function(ffi.Pointer<ffi.WChar>)>();

  ffi.Pointer<ffi.WChar> wcsset(
    ffi.Pointer<ffi.WChar> _String,
    int _Value,
  ) {
    return _wcsset1(
      _String,
      _Value,
    );
  }

  late final _wcssetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(
              ffi.Pointer<ffi.WChar>, ffi.WChar)>>('wcsset');
  late final _wcsset1 = _wcssetPtr.asFunction<
      ffi.Pointer<ffi.WChar> Function(ffi.Pointer<ffi.WChar>, int)>();

  ffi.Pointer<ffi.WChar> wcslwr(
    ffi.Pointer<ffi.WChar> _String,
  ) {
    return _wcslwr1(
      _String,
    );
  }

  late final _wcslwrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(ffi.Pointer<ffi.WChar>)>>('wcslwr');
  late final _wcslwr1 = _wcslwrPtr
      .asFunction<ffi.Pointer<ffi.WChar> Function(ffi.Pointer<ffi.WChar>)>();

  ffi.Pointer<ffi.WChar> wcsupr(
    ffi.Pointer<ffi.WChar> _String,
  ) {
    return _wcsupr1(
      _String,
    );
  }

  late final _wcsuprPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.WChar> Function(ffi.Pointer<ffi.WChar>)>>('wcsupr');
  late final _wcsupr1 = _wcsuprPtr
      .asFunction<ffi.Pointer<ffi.WChar> Function(ffi.Pointer<ffi.WChar>)>();

  int wcsicoll(
    ffi.Pointer<ffi.WChar> _String1,
    ffi.Pointer<ffi.WChar> _String2,
  ) {
    return _wcsicoll1(
      _String1,
      _String2,
    );
  }

  late final _wcsicollPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>>('wcsicoll');
  late final _wcsicoll1 = _wcsicollPtr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.WChar>)>();

  int strcpy_s(
    ffi.Pointer<ffi.Char> _Destination,
    int _SizeInBytes,
    ffi.Pointer<ffi.Char> _Source,
  ) {
    return _strcpy_s(
      _Destination,
      _SizeInBytes,
      _Source,
    );
  }

  late final _strcpy_sPtr = _lookup<
      ffi.NativeFunction<
          errno_t Function(ffi.Pointer<ffi.Char>, rsize_t,
              ffi.Pointer<ffi.Char>)>>('strcpy_s');
  late final _strcpy_s = _strcpy_sPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>)>();

  int strcat_s(
    ffi.Pointer<ffi.Char> _Destination,
    int _SizeInBytes,
    ffi.Pointer<ffi.Char> _Source,
  ) {
    return _strcat_s(
      _Destination,
      _SizeInBytes,
      _Source,
    );
  }

  late final _strcat_sPtr = _lookup<
      ffi.NativeFunction<
          errno_t Function(ffi.Pointer<ffi.Char>, rsize_t,
              ffi.Pointer<ffi.Char>)>>('strcat_s');
  late final _strcat_s = _strcat_sPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>)>();

  int strerror_s(
    ffi.Pointer<ffi.Char> _Buffer,
    int _SizeInBytes,
    int _ErrorNumber,
  ) {
    return _strerror_s1(
      _Buffer,
      _SizeInBytes,
      _ErrorNumber,
    );
  }

  late final _strerror_sPtr = _lookup<
      ffi.NativeFunction<
          errno_t Function(
              ffi.Pointer<ffi.Char>, ffi.Size, ffi.Int)>>('strerror_s');
  late final _strerror_s1 = _strerror_sPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, int, int)>();

  int strncat_s(
    ffi.Pointer<ffi.Char> _Destination,
    int _SizeInBytes,
    ffi.Pointer<ffi.Char> _Source,
    int _MaxCount,
  ) {
    return _strncat_s(
      _Destination,
      _SizeInBytes,
      _Source,
      _MaxCount,
    );
  }

  late final _strncat_sPtr = _lookup<
      ffi.NativeFunction<
          errno_t Function(ffi.Pointer<ffi.Char>, rsize_t,
              ffi.Pointer<ffi.Char>, rsize_t)>>('strncat_s');
  late final _strncat_s = _strncat_sPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>, int)>();

  int strncpy_s(
    ffi.Pointer<ffi.Char> _Destination,
    int _SizeInBytes,
    ffi.Pointer<ffi.Char> _Source,
    int _MaxCount,
  ) {
    return _strncpy_s(
      _Destination,
      _SizeInBytes,
      _Source,
      _MaxCount,
    );
  }

  late final _strncpy_sPtr = _lookup<
      ffi.NativeFunction<
          errno_t Function(ffi.Pointer<ffi.Char>, rsize_t,
              ffi.Pointer<ffi.Char>, rsize_t)>>('strncpy_s');
  late final _strncpy_s = _strncpy_sPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> strtok_s(
    ffi.Pointer<ffi.Char> _String,
    ffi.Pointer<ffi.Char> _Delimiter,
    ffi.Pointer<ffi.Pointer<ffi.Char>> _Context,
  ) {
    return _strtok_s(
      _String,
      _Delimiter,
      _Context,
    );
  }

  late final _strtok_sPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('strtok_s');
  late final _strtok_s = _strtok_sPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  ffi.Pointer<ffi.Void> _memccpy(
    ffi.Pointer<ffi.Void> _Dst,
    ffi.Pointer<ffi.Void> _Src,
    int _Val,
    int _MaxCount,
  ) {
    return __memccpy(
      _Dst,
      _Src,
      _Val,
      _MaxCount,
    );
  }

  late final __memccpyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Int, ffi.Size)>>('_memccpy');
  late final __memccpy = __memccpyPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int)>();

  ffi.Pointer<ffi.Char> strcat(
    ffi.Pointer<ffi.Char> _Destination,
    ffi.Pointer<ffi.Char> _Source,
  ) {
    return _strcat(
      _Destination,
      _Source,
    );
  }

  late final _strcatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strcat');
  late final _strcat = _strcatPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int strcmp(
    ffi.Pointer<ffi.Char> _Str1,
    ffi.Pointer<ffi.Char> _Str2,
  ) {
    return _strcmp(
      _Str1,
      _Str2,
    );
  }

  late final _strcmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strcmp');
  late final _strcmp = _strcmpPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int _strcmpi(
    ffi.Pointer<ffi.Char> _String1,
    ffi.Pointer<ffi.Char> _String2,
  ) {
    return __strcmpi(
      _String1,
      _String2,
    );
  }

  late final __strcmpiPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('_strcmpi');
  late final __strcmpi = __strcmpiPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int strcoll(
    ffi.Pointer<ffi.Char> _String1,
    ffi.Pointer<ffi.Char> _String2,
  ) {
    return _strcoll(
      _String1,
      _String2,
    );
  }

  late final _strcollPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strcoll');
  late final _strcoll = _strcollPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int _strcoll_l(
    ffi.Pointer<ffi.Char> _String1,
    ffi.Pointer<ffi.Char> _String2,
    _locale_t _Locale,
  ) {
    return __strcoll_l(
      _String1,
      _String2,
      _Locale,
    );
  }

  late final __strcoll_lPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              _locale_t)>>('_strcoll_l');
  late final __strcoll_l = __strcoll_lPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, _locale_t)>();

  ffi.Pointer<ffi.Char> strcpy(
    ffi.Pointer<ffi.Char> _Destination,
    ffi.Pointer<ffi.Char> _Source,
  ) {
    return _strcpy(
      _Destination,
      _Source,
    );
  }

  late final _strcpyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strcpy');
  late final _strcpy = _strcpyPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int strcspn(
    ffi.Pointer<ffi.Char> _Str,
    ffi.Pointer<ffi.Char> _Control,
  ) {
    return _strcspn(
      _Str,
      _Control,
    );
  }

  late final _strcspnPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLongLong Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strcspn');
  late final _strcspn = _strcspnPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> _strdup(
    ffi.Pointer<ffi.Char> _Source,
  ) {
    return __strdup(
      _Source,
    );
  }

  late final __strdupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('_strdup');
  late final __strdup = __strdupPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> _strerror(
    ffi.Pointer<ffi.Char> _ErrorMessage,
  ) {
    return __strerror(
      _ErrorMessage,
    );
  }

  late final __strerrorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('_strerror');
  late final __strerror = __strerrorPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int _strerror_s(
    ffi.Pointer<ffi.Char> _Buffer,
    int _SizeInBytes,
    ffi.Pointer<ffi.Char> _ErrorMessage,
  ) {
    return __strerror_s(
      _Buffer,
      _SizeInBytes,
      _ErrorMessage,
    );
  }

  late final __strerror_sPtr = _lookup<
      ffi.NativeFunction<
          errno_t Function(ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<ffi.Char>)>>('_strerror_s');
  late final __strerror_s = __strerror_sPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> strerror(
    int _ErrorMessage,
  ) {
    return _strerror1(
      _ErrorMessage,
    );
  }

  late final _strerrorPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int)>>(
          'strerror');
  late final _strerror1 =
      _strerrorPtr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  int _stricmp(
    ffi.Pointer<ffi.Char> _String1,
    ffi.Pointer<ffi.Char> _String2,
  ) {
    return __stricmp(
      _String1,
      _String2,
    );
  }

  late final __stricmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('_stricmp');
  late final __stricmp = __stricmpPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int _stricoll(
    ffi.Pointer<ffi.Char> _String1,
    ffi.Pointer<ffi.Char> _String2,
  ) {
    return __stricoll(
      _String1,
      _String2,
    );
  }

  late final __stricollPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('_stricoll');
  late final __stricoll = __stricollPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int _stricoll_l(
    ffi.Pointer<ffi.Char> _String1,
    ffi.Pointer<ffi.Char> _String2,
    _locale_t _Locale,
  ) {
    return __stricoll_l(
      _String1,
      _String2,
      _Locale,
    );
  }

  late final __stricoll_lPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              _locale_t)>>('_stricoll_l');
  late final __stricoll_l = __stricoll_lPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, _locale_t)>();

  int _stricmp_l(
    ffi.Pointer<ffi.Char> _String1,
    ffi.Pointer<ffi.Char> _String2,
    _locale_t _Locale,
  ) {
    return __stricmp_l(
      _String1,
      _String2,
      _Locale,
    );
  }

  late final __stricmp_lPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              _locale_t)>>('_stricmp_l');
  late final __stricmp_l = __stricmp_lPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, _locale_t)>();

  int strlen(
    ffi.Pointer<ffi.Char> _Str,
  ) {
    return _strlen(
      _Str,
    );
  }

  late final _strlenPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLongLong Function(ffi.Pointer<ffi.Char>)>>('strlen');
  late final _strlen =
      _strlenPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int _strlwr_s(
    ffi.Pointer<ffi.Char> _String,
    int _Size,
  ) {
    return __strlwr_s(
      _String,
      _Size,
    );
  }

  late final __strlwr_sPtr = _lookup<
      ffi.NativeFunction<
          errno_t Function(ffi.Pointer<ffi.Char>, ffi.Size)>>('_strlwr_s');
  late final __strlwr_s =
      __strlwr_sPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> _strlwr(
    ffi.Pointer<ffi.Char> _String,
  ) {
    return __strlwr(
      _String,
    );
  }

  late final __strlwrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('_strlwr');
  late final __strlwr = __strlwrPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int _strlwr_s_l(
    ffi.Pointer<ffi.Char> _String,
    int _Size,
    _locale_t _Locale,
  ) {
    return __strlwr_s_l(
      _String,
      _Size,
      _Locale,
    );
  }

  late final __strlwr_s_lPtr = _lookup<
      ffi.NativeFunction<
          errno_t Function(
              ffi.Pointer<ffi.Char>, ffi.Size, _locale_t)>>('_strlwr_s_l');
  late final __strlwr_s_l = __strlwr_s_lPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, int, _locale_t)>();

  ffi.Pointer<ffi.Char> _strlwr_l(
    ffi.Pointer<ffi.Char> _String,
    _locale_t _Locale,
  ) {
    return __strlwr_l(
      _String,
      _Locale,
    );
  }

  late final __strlwr_lPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, _locale_t)>>('_strlwr_l');
  late final __strlwr_l = __strlwr_lPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, _locale_t)>();

  ffi.Pointer<ffi.Char> strncat(
    ffi.Pointer<ffi.Char> _Destination,
    ffi.Pointer<ffi.Char> _Source,
    int _Count,
  ) {
    return _strncat(
      _Destination,
      _Source,
      _Count,
    );
  }

  late final _strncatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Size)>>('strncat');
  late final _strncat = _strncatPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int strncmp(
    ffi.Pointer<ffi.Char> _Str1,
    ffi.Pointer<ffi.Char> _Str2,
    int _MaxCount,
  ) {
    return _strncmp(
      _Str1,
      _Str2,
      _MaxCount,
    );
  }

  late final _strncmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('strncmp');
  late final _strncmp = _strncmpPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int _strnicmp(
    ffi.Pointer<ffi.Char> _String1,
    ffi.Pointer<ffi.Char> _String2,
    int _MaxCount,
  ) {
    return __strnicmp(
      _String1,
      _String2,
      _MaxCount,
    );
  }

  late final __strnicmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('_strnicmp');
  late final __strnicmp = __strnicmpPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int _strnicmp_l(
    ffi.Pointer<ffi.Char> _String1,
    ffi.Pointer<ffi.Char> _String2,
    int _MaxCount,
    _locale_t _Locale,
  ) {
    return __strnicmp_l(
      _String1,
      _String2,
      _MaxCount,
      _Locale,
    );
  }

  late final __strnicmp_lPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size, _locale_t)>>('_strnicmp_l');
  late final __strnicmp_l = __strnicmp_lPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int, _locale_t)>();

  int _strnicoll(
    ffi.Pointer<ffi.Char> _String1,
    ffi.Pointer<ffi.Char> _String2,
    int _MaxCount,
  ) {
    return __strnicoll(
      _String1,
      _String2,
      _MaxCount,
    );
  }

  late final __strnicollPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('_strnicoll');
  late final __strnicoll = __strnicollPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int _strnicoll_l(
    ffi.Pointer<ffi.Char> _String1,
    ffi.Pointer<ffi.Char> _String2,
    int _MaxCount,
    _locale_t _Locale,
  ) {
    return __strnicoll_l(
      _String1,
      _String2,
      _MaxCount,
      _Locale,
    );
  }

  late final __strnicoll_lPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size, _locale_t)>>('_strnicoll_l');
  late final __strnicoll_l = __strnicoll_lPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int, _locale_t)>();

  int _strncoll(
    ffi.Pointer<ffi.Char> _String1,
    ffi.Pointer<ffi.Char> _String2,
    int _MaxCount,
  ) {
    return __strncoll(
      _String1,
      _String2,
      _MaxCount,
    );
  }

  late final __strncollPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('_strncoll');
  late final __strncoll = __strncollPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int _strncoll_l(
    ffi.Pointer<ffi.Char> _String1,
    ffi.Pointer<ffi.Char> _String2,
    int _MaxCount,
    _locale_t _Locale,
  ) {
    return __strncoll_l(
      _String1,
      _String2,
      _MaxCount,
      _Locale,
    );
  }

  late final __strncoll_lPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size, _locale_t)>>('_strncoll_l');
  late final __strncoll_l = __strncoll_lPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int, _locale_t)>();

  int __strncnt(
    ffi.Pointer<ffi.Char> _String,
    int _Count,
  ) {
    return ___strncnt(
      _String,
      _Count,
    );
  }

  late final ___strncntPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Size)>>('__strncnt');
  late final ___strncnt =
      ___strncntPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> strncpy(
    ffi.Pointer<ffi.Char> _Destination,
    ffi.Pointer<ffi.Char> _Source,
    int _Count,
  ) {
    return _strncpy(
      _Destination,
      _Source,
      _Count,
    );
  }

  late final _strncpyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Size)>>('strncpy');
  late final _strncpy = _strncpyPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int strnlen(
    ffi.Pointer<ffi.Char> _String,
    int _MaxCount,
  ) {
    return _strnlen(
      _String,
      _MaxCount,
    );
  }

  late final _strnlenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Size)>>('strnlen');
  late final _strnlen =
      _strnlenPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  int _strnset_s(
    ffi.Pointer<ffi.Char> _String,
    int _SizeInBytes,
    int _Value,
    int _MaxCount,
  ) {
    return __strnset_s(
      _String,
      _SizeInBytes,
      _Value,
      _MaxCount,
    );
  }

  late final __strnset_sPtr = _lookup<
      ffi.NativeFunction<
          errno_t Function(ffi.Pointer<ffi.Char>, ffi.Size, ffi.Int,
              ffi.Size)>>('_strnset_s');
  late final __strnset_s = __strnset_sPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, int, int, int)>();

  ffi.Pointer<ffi.Char> _strnset(
    ffi.Pointer<ffi.Char> _Destination,
    int _Value,
    int _Count,
  ) {
    return __strnset(
      _Destination,
      _Value,
      _Count,
    );
  }

  late final __strnsetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int, ffi.Size)>>('_strnset');
  late final __strnset = __strnsetPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int, int)>();

  ffi.Pointer<ffi.Char> strpbrk(
    ffi.Pointer<ffi.Char> _Str,
    ffi.Pointer<ffi.Char> _Control,
  ) {
    return _strpbrk(
      _Str,
      _Control,
    );
  }

  late final _strpbrkPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strpbrk');
  late final _strpbrk = _strpbrkPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> _strrev(
    ffi.Pointer<ffi.Char> _Str,
  ) {
    return __strrev(
      _Str,
    );
  }

  late final __strrevPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('_strrev');
  late final __strrev = __strrevPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int _strset_s(
    ffi.Pointer<ffi.Char> _Destination,
    int _DestinationSize,
    int _Value,
  ) {
    return __strset_s(
      _Destination,
      _DestinationSize,
      _Value,
    );
  }

  late final __strset_sPtr = _lookup<
      ffi.NativeFunction<
          errno_t Function(
              ffi.Pointer<ffi.Char>, ffi.Size, ffi.Int)>>('_strset_s');
  late final __strset_s =
      __strset_sPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int, int)>();

  ffi.Pointer<ffi.Char> _strset(
    ffi.Pointer<ffi.Char> _Destination,
    int _Value,
  ) {
    return __strset(
      _Destination,
      _Value,
    );
  }

  late final __strsetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('_strset');
  late final __strset = __strsetPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  int strspn(
    ffi.Pointer<ffi.Char> _Str,
    ffi.Pointer<ffi.Char> _Control,
  ) {
    return _strspn(
      _Str,
      _Control,
    );
  }

  late final _strspnPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLongLong Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strspn');
  late final _strspn = _strspnPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> strtok(
    ffi.Pointer<ffi.Char> _String,
    ffi.Pointer<ffi.Char> _Delimiter,
  ) {
    return _strtok(
      _String,
      _Delimiter,
    );
  }

  late final _strtokPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strtok');
  late final _strtok = _strtokPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int _strupr_s(
    ffi.Pointer<ffi.Char> _String,
    int _Size,
  ) {
    return __strupr_s(
      _String,
      _Size,
    );
  }

  late final __strupr_sPtr = _lookup<
      ffi.NativeFunction<
          errno_t Function(ffi.Pointer<ffi.Char>, ffi.Size)>>('_strupr_s');
  late final __strupr_s =
      __strupr_sPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> _strupr(
    ffi.Pointer<ffi.Char> _String,
  ) {
    return __strupr(
      _String,
    );
  }

  late final __struprPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('_strupr');
  late final __strupr = __struprPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int _strupr_s_l(
    ffi.Pointer<ffi.Char> _String,
    int _Size,
    _locale_t _Locale,
  ) {
    return __strupr_s_l(
      _String,
      _Size,
      _Locale,
    );
  }

  late final __strupr_s_lPtr = _lookup<
      ffi.NativeFunction<
          errno_t Function(
              ffi.Pointer<ffi.Char>, ffi.Size, _locale_t)>>('_strupr_s_l');
  late final __strupr_s_l = __strupr_s_lPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, int, _locale_t)>();

  ffi.Pointer<ffi.Char> _strupr_l(
    ffi.Pointer<ffi.Char> _String,
    _locale_t _Locale,
  ) {
    return __strupr_l(
      _String,
      _Locale,
    );
  }

  late final __strupr_lPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, _locale_t)>>('_strupr_l');
  late final __strupr_l = __strupr_lPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, _locale_t)>();

  int strxfrm(
    ffi.Pointer<ffi.Char> _Destination,
    ffi.Pointer<ffi.Char> _Source,
    int _MaxCount,
  ) {
    return _strxfrm(
      _Destination,
      _Source,
      _MaxCount,
    );
  }

  late final _strxfrmPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLongLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Size)>>('strxfrm');
  late final _strxfrm = _strxfrmPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int _strxfrm_l(
    ffi.Pointer<ffi.Char> _Destination,
    ffi.Pointer<ffi.Char> _Source,
    int _MaxCount,
    _locale_t _Locale,
  ) {
    return __strxfrm_l(
      _Destination,
      _Source,
      _MaxCount,
      _Locale,
    );
  }

  late final __strxfrm_lPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size, _locale_t)>>('_strxfrm_l');
  late final __strxfrm_l = __strxfrm_lPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int, _locale_t)>();

  ffi.Pointer<ffi.Char> strdup(
    ffi.Pointer<ffi.Char> _String,
  ) {
    return _strdup1(
      _String,
    );
  }

  late final _strdupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('strdup');
  late final _strdup1 = _strdupPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int strcmpi(
    ffi.Pointer<ffi.Char> _String1,
    ffi.Pointer<ffi.Char> _String2,
  ) {
    return _strcmpi1(
      _String1,
      _String2,
    );
  }

  late final _strcmpiPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strcmpi');
  late final _strcmpi1 = _strcmpiPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int stricmp(
    ffi.Pointer<ffi.Char> _String1,
    ffi.Pointer<ffi.Char> _String2,
  ) {
    return _stricmp1(
      _String1,
      _String2,
    );
  }

  late final _stricmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('stricmp');
  late final _stricmp1 = _stricmpPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> strlwr(
    ffi.Pointer<ffi.Char> _String,
  ) {
    return _strlwr1(
      _String,
    );
  }

  late final _strlwrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('strlwr');
  late final _strlwr1 = _strlwrPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int strnicmp(
    ffi.Pointer<ffi.Char> _String1,
    ffi.Pointer<ffi.Char> _String2,
    int _MaxCount,
  ) {
    return _strnicmp1(
      _String1,
      _String2,
      _MaxCount,
    );
  }

  late final _strnicmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('strnicmp');
  late final _strnicmp1 = _strnicmpPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> strnset(
    ffi.Pointer<ffi.Char> _String,
    int _Value,
    int _MaxCount,
  ) {
    return _strnset1(
      _String,
      _Value,
      _MaxCount,
    );
  }

  late final _strnsetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int, ffi.Size)>>('strnset');
  late final _strnset1 = _strnsetPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int, int)>();

  ffi.Pointer<ffi.Char> strrev(
    ffi.Pointer<ffi.Char> _String,
  ) {
    return _strrev1(
      _String,
    );
  }

  late final _strrevPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('strrev');
  late final _strrev1 = _strrevPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> strset(
    ffi.Pointer<ffi.Char> _String,
    int _Value,
  ) {
    return _strset1(
      _String,
      _Value,
    );
  }

  late final _strsetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('strset');
  late final _strset1 = _strsetPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> strupr(
    ffi.Pointer<ffi.Char> _String,
  ) {
    return _strupr1(
      _String,
    );
  }

  late final _struprPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('strupr');
  late final _strupr1 = _struprPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  /// Returns the version number of the demux library, packed in hexadecimal using
  /// 8bits for each of major/minor/revision. E.g: v2.5.7 is 0x020507.
  int WebPGetDemuxVersion() {
    return _WebPGetDemuxVersion();
  }

  late final _WebPGetDemuxVersionPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('WebPGetDemuxVersion');
  late final _WebPGetDemuxVersion =
      _WebPGetDemuxVersionPtr.asFunction<int Function()>();

  /// Internal, version-checked, entry point
  ffi.Pointer<WebPDemuxer> WebPDemuxInternal(
    ffi.Pointer<WebPData> arg0,
    int arg1,
    ffi.Pointer<ffi.Int32> arg2,
    int arg3,
  ) {
    return _WebPDemuxInternal(
      arg0,
      arg1,
      arg2,
      arg3,
    );
  }

  late final _WebPDemuxInternalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<WebPDemuxer> Function(ffi.Pointer<WebPData>, ffi.Int,
              ffi.Pointer<ffi.Int32>, ffi.Int)>>('WebPDemuxInternal');
  late final _WebPDemuxInternal = _WebPDemuxInternalPtr.asFunction<
      ffi.Pointer<WebPDemuxer> Function(
          ffi.Pointer<WebPData>, int, ffi.Pointer<ffi.Int32>, int)>();

  /// Frees memory associated with 'dmux'.
  void WebPDemuxDelete(
    ffi.Pointer<WebPDemuxer> dmux,
  ) {
    return _WebPDemuxDelete(
      dmux,
    );
  }

  late final _WebPDemuxDeletePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<WebPDemuxer>)>>(
          'WebPDemuxDelete');
  late final _WebPDemuxDelete =
      _WebPDemuxDeletePtr.asFunction<void Function(ffi.Pointer<WebPDemuxer>)>();

  /// Get the 'feature' value from the 'dmux'.
  /// NOTE: values are only valid if WebPDemux() was used or WebPDemuxPartial()
  /// returned a state > WEBP_DEMUX_PARSING_HEADER.
  /// If 'feature' is WEBP_FF_FORMAT_FLAGS, the returned value is a bit-wise
  /// combination of WebPFeatureFlags values.
  /// If 'feature' is WEBP_FF_LOOP_COUNT, WEBP_FF_BACKGROUND_COLOR, the returned
  /// value is only meaningful if the bitstream is animated.
  int WebPDemuxGetI(
    ffi.Pointer<WebPDemuxer> dmux,
    int feature,
  ) {
    return _WebPDemuxGetI(
      dmux,
      feature,
    );
  }

  late final _WebPDemuxGetIPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint32 Function(
              ffi.Pointer<WebPDemuxer>, ffi.Int32)>>('WebPDemuxGetI');
  late final _WebPDemuxGetI = _WebPDemuxGetIPtr.asFunction<
      int Function(ffi.Pointer<WebPDemuxer>, int)>();

  /// Retrieves frame 'frame_number' from 'dmux'.
  /// 'iter->fragment' points to the frame on return from this function.
  /// Setting 'frame_number' equal to 0 will return the last frame of the image.
  /// Returns false if 'dmux' is NULL or frame 'frame_number' is not present.
  /// Call WebPDemuxReleaseIterator() when use of the iterator is complete.
  /// NOTE: 'dmux' must persist for the lifetime of 'iter'.
  int WebPDemuxGetFrame(
    ffi.Pointer<WebPDemuxer> dmux,
    int frame_number,
    ffi.Pointer<WebPIterator> iter,
  ) {
    return _WebPDemuxGetFrame(
      dmux,
      frame_number,
      iter,
    );
  }

  late final _WebPDemuxGetFramePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<WebPDemuxer>, ffi.Int,
              ffi.Pointer<WebPIterator>)>>('WebPDemuxGetFrame');
  late final _WebPDemuxGetFrame = _WebPDemuxGetFramePtr.asFunction<
      int Function(ffi.Pointer<WebPDemuxer>, int, ffi.Pointer<WebPIterator>)>();

  /// Sets 'iter->fragment' to point to the next ('iter->frame_num' + 1) or
  /// previous ('iter->frame_num' - 1) frame. These functions do not loop.
  /// Returns true on success, false otherwise.
  int WebPDemuxNextFrame(
    ffi.Pointer<WebPIterator> iter,
  ) {
    return _WebPDemuxNextFrame(
      iter,
    );
  }

  late final _WebPDemuxNextFramePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<WebPIterator>)>>(
          'WebPDemuxNextFrame');
  late final _WebPDemuxNextFrame = _WebPDemuxNextFramePtr.asFunction<
      int Function(ffi.Pointer<WebPIterator>)>();

  int WebPDemuxPrevFrame(
    ffi.Pointer<WebPIterator> iter,
  ) {
    return _WebPDemuxPrevFrame(
      iter,
    );
  }

  late final _WebPDemuxPrevFramePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<WebPIterator>)>>(
          'WebPDemuxPrevFrame');
  late final _WebPDemuxPrevFrame = _WebPDemuxPrevFramePtr.asFunction<
      int Function(ffi.Pointer<WebPIterator>)>();

  /// Releases any memory associated with 'iter'.
  /// Must be called before any subsequent calls to WebPDemuxGetChunk() on the same
  /// iter. Also, must be called before destroying the associated WebPDemuxer with
  /// WebPDemuxDelete().
  void WebPDemuxReleaseIterator(
    ffi.Pointer<WebPIterator> iter,
  ) {
    return _WebPDemuxReleaseIterator(
      iter,
    );
  }

  late final _WebPDemuxReleaseIteratorPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<WebPIterator>)>>(
          'WebPDemuxReleaseIterator');
  late final _WebPDemuxReleaseIterator = _WebPDemuxReleaseIteratorPtr
      .asFunction<void Function(ffi.Pointer<WebPIterator>)>();

  /// Retrieves the 'chunk_number' instance of the chunk with id 'fourcc' from
  /// 'dmux'.
  /// 'fourcc' is a character array containing the fourcc of the chunk to return,
  /// e.g., "ICCP", "XMP ", "EXIF", etc.
  /// Setting 'chunk_number' equal to 0 will return the last chunk in a set.
  /// Returns true if the chunk is found, false otherwise. Image related chunk
  /// payloads are accessed through WebPDemuxGetFrame() and related functions.
  /// Call WebPDemuxReleaseChunkIterator() when use of the iterator is complete.
  /// NOTE: 'dmux' must persist for the lifetime of the iterator.
  int WebPDemuxGetChunk(
    ffi.Pointer<WebPDemuxer> dmux,
    ffi.Pointer<ffi.Char> fourcc,
    int chunk_number,
    ffi.Pointer<WebPChunkIterator> iter,
  ) {
    return _WebPDemuxGetChunk(
      dmux,
      fourcc,
      chunk_number,
      iter,
    );
  }

  late final _WebPDemuxGetChunkPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<WebPDemuxer>, ffi.Pointer<ffi.Char>,
              ffi.Int, ffi.Pointer<WebPChunkIterator>)>>('WebPDemuxGetChunk');
  late final _WebPDemuxGetChunk = _WebPDemuxGetChunkPtr.asFunction<
      int Function(ffi.Pointer<WebPDemuxer>, ffi.Pointer<ffi.Char>, int,
          ffi.Pointer<WebPChunkIterator>)>();

  /// Sets 'iter->chunk' to point to the next ('iter->chunk_num' + 1) or previous
  /// ('iter->chunk_num' - 1) chunk. These functions do not loop.
  /// Returns true on success, false otherwise.
  int WebPDemuxNextChunk(
    ffi.Pointer<WebPChunkIterator> iter,
  ) {
    return _WebPDemuxNextChunk(
      iter,
    );
  }

  late final _WebPDemuxNextChunkPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<WebPChunkIterator>)>>(
      'WebPDemuxNextChunk');
  late final _WebPDemuxNextChunk = _WebPDemuxNextChunkPtr.asFunction<
      int Function(ffi.Pointer<WebPChunkIterator>)>();

  int WebPDemuxPrevChunk(
    ffi.Pointer<WebPChunkIterator> iter,
  ) {
    return _WebPDemuxPrevChunk(
      iter,
    );
  }

  late final _WebPDemuxPrevChunkPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<WebPChunkIterator>)>>(
      'WebPDemuxPrevChunk');
  late final _WebPDemuxPrevChunk = _WebPDemuxPrevChunkPtr.asFunction<
      int Function(ffi.Pointer<WebPChunkIterator>)>();

  /// Releases any memory associated with 'iter'.
  /// Must be called before destroying the associated WebPDemuxer with
  /// WebPDemuxDelete().
  void WebPDemuxReleaseChunkIterator(
    ffi.Pointer<WebPChunkIterator> iter,
  ) {
    return _WebPDemuxReleaseChunkIterator(
      iter,
    );
  }

  late final _WebPDemuxReleaseChunkIteratorPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<WebPChunkIterator>)>>(
      'WebPDemuxReleaseChunkIterator');
  late final _WebPDemuxReleaseChunkIterator = _WebPDemuxReleaseChunkIteratorPtr
      .asFunction<void Function(ffi.Pointer<WebPChunkIterator>)>();

  /// Internal, version-checked, entry point.
  int WebPAnimDecoderOptionsInitInternal(
    ffi.Pointer<WebPAnimDecoderOptions> arg0,
    int arg1,
  ) {
    return _WebPAnimDecoderOptionsInitInternal(
      arg0,
      arg1,
    );
  }

  late final _WebPAnimDecoderOptionsInitInternalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<WebPAnimDecoderOptions>,
              ffi.Int)>>('WebPAnimDecoderOptionsInitInternal');
  late final _WebPAnimDecoderOptionsInitInternal =
      _WebPAnimDecoderOptionsInitInternalPtr.asFunction<
          int Function(ffi.Pointer<WebPAnimDecoderOptions>, int)>();

  /// Internal, version-checked, entry point.
  ffi.Pointer<WebPAnimDecoder> WebPAnimDecoderNewInternal(
    ffi.Pointer<WebPData> arg0,
    ffi.Pointer<WebPAnimDecoderOptions> arg1,
    int arg2,
  ) {
    return _WebPAnimDecoderNewInternal(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _WebPAnimDecoderNewInternalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<WebPAnimDecoder> Function(
              ffi.Pointer<WebPData>,
              ffi.Pointer<WebPAnimDecoderOptions>,
              ffi.Int)>>('WebPAnimDecoderNewInternal');
  late final _WebPAnimDecoderNewInternal =
      _WebPAnimDecoderNewInternalPtr.asFunction<
          ffi.Pointer<WebPAnimDecoder> Function(ffi.Pointer<WebPData>,
              ffi.Pointer<WebPAnimDecoderOptions>, int)>();

  /// Get global information about the animation.
  /// Parameters:
  /// dec - (in) decoder instance to get information from.
  /// info - (out) global information fetched from the animation.
  /// Returns:
  /// True on success.
  int WebPAnimDecoderGetInfo(
    ffi.Pointer<WebPAnimDecoder> dec,
    ffi.Pointer<WebPAnimInfo> info,
  ) {
    return _WebPAnimDecoderGetInfo(
      dec,
      info,
    );
  }

  late final _WebPAnimDecoderGetInfoPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<WebPAnimDecoder>,
              ffi.Pointer<WebPAnimInfo>)>>('WebPAnimDecoderGetInfo');
  late final _WebPAnimDecoderGetInfo = _WebPAnimDecoderGetInfoPtr.asFunction<
      int Function(ffi.Pointer<WebPAnimDecoder>, ffi.Pointer<WebPAnimInfo>)>();

  /// Fetch the next frame from 'dec' based on options supplied to
  /// WebPAnimDecoderNew(). This will be a fully reconstructed canvas of size
  /// 'canvas_width * 4 * canvas_height', and not just the frame sub-rectangle. The
  /// returned buffer 'buf' is valid only until the next call to
  /// WebPAnimDecoderGetNext(), WebPAnimDecoderReset() or WebPAnimDecoderDelete().
  /// Parameters:
  /// dec - (in/out) decoder instance from which the next frame is to be fetched.
  /// buf - (out) decoded frame.
  /// timestamp - (out) timestamp of the frame in milliseconds.
  /// Returns:
  /// False if any of the arguments are NULL, or if there is a parsing or
  /// decoding error, or if there are no more frames. Otherwise, returns true.
  int WebPAnimDecoderGetNext(
    ffi.Pointer<WebPAnimDecoder> dec,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> buf,
    ffi.Pointer<ffi.Int> timestamp,
  ) {
    return _WebPAnimDecoderGetNext(
      dec,
      buf,
      timestamp,
    );
  }

  late final _WebPAnimDecoderGetNextPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<WebPAnimDecoder>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.Int>)>>('WebPAnimDecoderGetNext');
  late final _WebPAnimDecoderGetNext = _WebPAnimDecoderGetNextPtr.asFunction<
      int Function(ffi.Pointer<WebPAnimDecoder>,
          ffi.Pointer<ffi.Pointer<ffi.Uint8>>, ffi.Pointer<ffi.Int>)>();

  /// Check if there are more frames left to decode.
  /// Parameters:
  /// dec - (in) decoder instance to be checked.
  /// Returns:
  /// True if 'dec' is not NULL and some frames are yet to be decoded.
  /// Otherwise, returns false.
  int WebPAnimDecoderHasMoreFrames(
    ffi.Pointer<WebPAnimDecoder> dec,
  ) {
    return _WebPAnimDecoderHasMoreFrames(
      dec,
    );
  }

  late final _WebPAnimDecoderHasMoreFramesPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<WebPAnimDecoder>)>>(
      'WebPAnimDecoderHasMoreFrames');
  late final _WebPAnimDecoderHasMoreFrames = _WebPAnimDecoderHasMoreFramesPtr
      .asFunction<int Function(ffi.Pointer<WebPAnimDecoder>)>();

  /// Resets the WebPAnimDecoder object, so that next call to
  /// WebPAnimDecoderGetNext() will restart decoding from 1st frame. This would be
  /// helpful when all frames need to be decoded multiple times (e.g.
  /// info.loop_count times) without destroying and recreating the 'dec' object.
  /// Parameters:
  /// dec - (in/out) decoder instance to be reset
  void WebPAnimDecoderReset(
    ffi.Pointer<WebPAnimDecoder> dec,
  ) {
    return _WebPAnimDecoderReset(
      dec,
    );
  }

  late final _WebPAnimDecoderResetPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<WebPAnimDecoder>)>>(
      'WebPAnimDecoderReset');
  late final _WebPAnimDecoderReset = _WebPAnimDecoderResetPtr.asFunction<
      void Function(ffi.Pointer<WebPAnimDecoder>)>();

  /// Grab the internal demuxer object.
  /// Getting the demuxer object can be useful if one wants to use operations only
  /// available through demuxer; e.g. to get XMP/EXIF/ICC metadata. The returned
  /// demuxer object is owned by 'dec' and is valid only until the next call to
  /// WebPAnimDecoderDelete().
  ///
  /// Parameters:
  /// dec - (in) decoder instance from which the demuxer object is to be fetched.
  ffi.Pointer<WebPDemuxer> WebPAnimDecoderGetDemuxer(
    ffi.Pointer<WebPAnimDecoder> dec,
  ) {
    return _WebPAnimDecoderGetDemuxer(
      dec,
    );
  }

  late final _WebPAnimDecoderGetDemuxerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<WebPDemuxer> Function(
              ffi.Pointer<WebPAnimDecoder>)>>('WebPAnimDecoderGetDemuxer');
  late final _WebPAnimDecoderGetDemuxer =
      _WebPAnimDecoderGetDemuxerPtr.asFunction<
          ffi.Pointer<WebPDemuxer> Function(ffi.Pointer<WebPAnimDecoder>)>();

  /// Deletes the WebPAnimDecoder object.
  /// Parameters:
  /// dec - (in/out) decoder instance to be deleted
  void WebPAnimDecoderDelete(
    ffi.Pointer<WebPAnimDecoder> dec,
  ) {
    return _WebPAnimDecoderDelete(
      dec,
    );
  }

  late final _WebPAnimDecoderDeletePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<WebPAnimDecoder>)>>(
      'WebPAnimDecoderDelete');
  late final _WebPAnimDecoderDelete = _WebPAnimDecoderDeletePtr.asFunction<
      void Function(ffi.Pointer<WebPAnimDecoder>)>();

  /// Return the encoder's version number, packed in hexadecimal using 8bits for
  /// each of major/minor/revision. E.g: v2.5.7 is 0x020507.
  int WebPGetEncoderVersion() {
    return _WebPGetEncoderVersion();
  }

  late final _WebPGetEncoderVersionPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('WebPGetEncoderVersion');
  late final _WebPGetEncoderVersion =
      _WebPGetEncoderVersionPtr.asFunction<int Function()>();

  /// Returns the size of the compressed data (pointed to by *output), or 0 if
  /// an error occurred. The compressed data must be released by the caller
  /// using the call 'WebPFree(*output)'.
  /// These functions compress using the lossy format, and the quality_factor
  /// can go from 0 (smaller output, lower quality) to 100 (best quality,
  /// larger output).
  int WebPEncodeRGB(
    ffi.Pointer<ffi.Uint8> rgb,
    int width,
    int height,
    int stride,
    double quality_factor,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> output,
  ) {
    return _WebPEncodeRGB(
      rgb,
      width,
      height,
      stride,
      quality_factor,
      output,
    );
  }

  late final _WebPEncodeRGBPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(
              ffi.Pointer<ffi.Uint8>,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Float,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>)>>('WebPEncodeRGB');
  late final _WebPEncodeRGB = _WebPEncodeRGBPtr.asFunction<
      int Function(ffi.Pointer<ffi.Uint8>, int, int, int, double,
          ffi.Pointer<ffi.Pointer<ffi.Uint8>>)>();

  int WebPEncodeBGR(
    ffi.Pointer<ffi.Uint8> bgr,
    int width,
    int height,
    int stride,
    double quality_factor,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> output,
  ) {
    return _WebPEncodeBGR(
      bgr,
      width,
      height,
      stride,
      quality_factor,
      output,
    );
  }

  late final _WebPEncodeBGRPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(
              ffi.Pointer<ffi.Uint8>,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Float,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>)>>('WebPEncodeBGR');
  late final _WebPEncodeBGR = _WebPEncodeBGRPtr.asFunction<
      int Function(ffi.Pointer<ffi.Uint8>, int, int, int, double,
          ffi.Pointer<ffi.Pointer<ffi.Uint8>>)>();

  int WebPEncodeRGBA(
    ffi.Pointer<ffi.Uint8> rgba,
    int width,
    int height,
    int stride,
    double quality_factor,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> output,
  ) {
    return _WebPEncodeRGBA(
      rgba,
      width,
      height,
      stride,
      quality_factor,
      output,
    );
  }

  late final _WebPEncodeRGBAPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(
              ffi.Pointer<ffi.Uint8>,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Float,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>)>>('WebPEncodeRGBA');
  late final _WebPEncodeRGBA = _WebPEncodeRGBAPtr.asFunction<
      int Function(ffi.Pointer<ffi.Uint8>, int, int, int, double,
          ffi.Pointer<ffi.Pointer<ffi.Uint8>>)>();

  int WebPEncodeBGRA(
    ffi.Pointer<ffi.Uint8> bgra,
    int width,
    int height,
    int stride,
    double quality_factor,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> output,
  ) {
    return _WebPEncodeBGRA(
      bgra,
      width,
      height,
      stride,
      quality_factor,
      output,
    );
  }

  late final _WebPEncodeBGRAPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(
              ffi.Pointer<ffi.Uint8>,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Float,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>)>>('WebPEncodeBGRA');
  late final _WebPEncodeBGRA = _WebPEncodeBGRAPtr.asFunction<
      int Function(ffi.Pointer<ffi.Uint8>, int, int, int, double,
          ffi.Pointer<ffi.Pointer<ffi.Uint8>>)>();

  /// These functions are the equivalent of the above, but compressing in a
  /// lossless manner. Files are usually larger than lossy format, but will
  /// not suffer any compression loss.
  /// Note these functions, like the lossy versions, use the library's default
  /// settings. For lossless this means 'exact' is disabled. RGB values in
  /// transparent areas will be modified to improve compression. To avoid this,
  /// use WebPEncode() and set WebPConfig::exact to 1.
  int WebPEncodeLosslessRGB(
    ffi.Pointer<ffi.Uint8> rgb,
    int width,
    int height,
    int stride,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> output,
  ) {
    return _WebPEncodeLosslessRGB(
      rgb,
      width,
      height,
      stride,
      output,
    );
  }

  late final _WebPEncodeLosslessRGBPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Uint8>, ffi.Int, ffi.Int, ffi.Int,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>)>>('WebPEncodeLosslessRGB');
  late final _WebPEncodeLosslessRGB = _WebPEncodeLosslessRGBPtr.asFunction<
      int Function(ffi.Pointer<ffi.Uint8>, int, int, int,
          ffi.Pointer<ffi.Pointer<ffi.Uint8>>)>();

  int WebPEncodeLosslessBGR(
    ffi.Pointer<ffi.Uint8> bgr,
    int width,
    int height,
    int stride,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> output,
  ) {
    return _WebPEncodeLosslessBGR(
      bgr,
      width,
      height,
      stride,
      output,
    );
  }

  late final _WebPEncodeLosslessBGRPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Uint8>, ffi.Int, ffi.Int, ffi.Int,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>)>>('WebPEncodeLosslessBGR');
  late final _WebPEncodeLosslessBGR = _WebPEncodeLosslessBGRPtr.asFunction<
      int Function(ffi.Pointer<ffi.Uint8>, int, int, int,
          ffi.Pointer<ffi.Pointer<ffi.Uint8>>)>();

  int WebPEncodeLosslessRGBA(
    ffi.Pointer<ffi.Uint8> rgba,
    int width,
    int height,
    int stride,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> output,
  ) {
    return _WebPEncodeLosslessRGBA(
      rgba,
      width,
      height,
      stride,
      output,
    );
  }

  late final _WebPEncodeLosslessRGBAPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Uint8>, ffi.Int, ffi.Int, ffi.Int,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>)>>('WebPEncodeLosslessRGBA');
  late final _WebPEncodeLosslessRGBA = _WebPEncodeLosslessRGBAPtr.asFunction<
      int Function(ffi.Pointer<ffi.Uint8>, int, int, int,
          ffi.Pointer<ffi.Pointer<ffi.Uint8>>)>();

  int WebPEncodeLosslessBGRA(
    ffi.Pointer<ffi.Uint8> bgra,
    int width,
    int height,
    int stride,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> output,
  ) {
    return _WebPEncodeLosslessBGRA(
      bgra,
      width,
      height,
      stride,
      output,
    );
  }

  late final _WebPEncodeLosslessBGRAPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Uint8>, ffi.Int, ffi.Int, ffi.Int,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>)>>('WebPEncodeLosslessBGRA');
  late final _WebPEncodeLosslessBGRA = _WebPEncodeLosslessBGRAPtr.asFunction<
      int Function(ffi.Pointer<ffi.Uint8>, int, int, int,
          ffi.Pointer<ffi.Pointer<ffi.Uint8>>)>();

  /// Internal, version-checked, entry point
  int WebPConfigInitInternal(
    ffi.Pointer<WebPConfig> arg0,
    int arg1,
    double arg2,
    int arg3,
  ) {
    return _WebPConfigInitInternal(
      arg0,
      arg1,
      arg2,
      arg3,
    );
  }

  late final _WebPConfigInitInternalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<WebPConfig>, ffi.Int32, ffi.Float,
              ffi.Int)>>('WebPConfigInitInternal');
  late final _WebPConfigInitInternal = _WebPConfigInitInternalPtr.asFunction<
      int Function(ffi.Pointer<WebPConfig>, int, double, int)>();

  /// Activate the lossless compression mode with the desired efficiency level
  /// between 0 (fastest, lowest compression) and 9 (slower, best compression).
  /// A good default level is '6', providing a fair tradeoff between compression
  /// speed and final compressed size.
  /// This function will overwrite several fields from config: 'method', 'quality'
  /// and 'lossless'. Returns false in case of parameter error.
  int WebPConfigLosslessPreset(
    ffi.Pointer<WebPConfig> config,
    int level,
  ) {
    return _WebPConfigLosslessPreset(
      config,
      level,
    );
  }

  late final _WebPConfigLosslessPresetPtr = _lookup<
          ffi
          .NativeFunction<ffi.Int Function(ffi.Pointer<WebPConfig>, ffi.Int)>>(
      'WebPConfigLosslessPreset');
  late final _WebPConfigLosslessPreset = _WebPConfigLosslessPresetPtr
      .asFunction<int Function(ffi.Pointer<WebPConfig>, int)>();

  /// Returns true if 'config' is non-NULL and all configuration parameters are
  /// within their valid ranges.
  int WebPValidateConfig(
    ffi.Pointer<WebPConfig> config,
  ) {
    return _WebPValidateConfig(
      config,
    );
  }

  late final _WebPValidateConfigPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<WebPConfig>)>>(
          'WebPValidateConfig');
  late final _WebPValidateConfig = _WebPValidateConfigPtr.asFunction<
      int Function(ffi.Pointer<WebPConfig>)>();

  /// The following must be called first before any use.
  void WebPMemoryWriterInit(
    ffi.Pointer<WebPMemoryWriter> writer,
  ) {
    return _WebPMemoryWriterInit(
      writer,
    );
  }

  late final _WebPMemoryWriterInitPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<WebPMemoryWriter>)>>(
      'WebPMemoryWriterInit');
  late final _WebPMemoryWriterInit = _WebPMemoryWriterInitPtr.asFunction<
      void Function(ffi.Pointer<WebPMemoryWriter>)>();

  /// The following must be called to deallocate writer->mem memory. The 'writer'
  /// object itself is not deallocated.
  void WebPMemoryWriterClear(
    ffi.Pointer<WebPMemoryWriter> writer,
  ) {
    return _WebPMemoryWriterClear(
      writer,
    );
  }

  late final _WebPMemoryWriterClearPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<WebPMemoryWriter>)>>(
      'WebPMemoryWriterClear');
  late final _WebPMemoryWriterClear = _WebPMemoryWriterClearPtr.asFunction<
      void Function(ffi.Pointer<WebPMemoryWriter>)>();

  /// The custom writer to be used with WebPMemoryWriter as custom_ptr. Upon
  /// completion, writer.mem and writer.size will hold the coded data.
  /// writer.mem must be freed by calling WebPMemoryWriterClear.
  int WebPMemoryWrite(
    ffi.Pointer<ffi.Uint8> data,
    int data_size,
    ffi.Pointer<WebPPicture> picture,
  ) {
    return _WebPMemoryWrite(
      data,
      data_size,
      picture,
    );
  }

  late final _WebPMemoryWritePtr =
      _lookup<ffi.NativeFunction<NativeWebPMemoryWrite>>('WebPMemoryWrite');
  late final _WebPMemoryWrite =
      _WebPMemoryWritePtr.asFunction<DartWebPMemoryWrite>();

  /// Internal, version-checked, entry point
  int WebPPictureInitInternal(
    ffi.Pointer<WebPPicture> arg0,
    int arg1,
  ) {
    return _WebPPictureInitInternal(
      arg0,
      arg1,
    );
  }

  late final _WebPPictureInitInternalPtr = _lookup<
          ffi
          .NativeFunction<ffi.Int Function(ffi.Pointer<WebPPicture>, ffi.Int)>>(
      'WebPPictureInitInternal');
  late final _WebPPictureInitInternal = _WebPPictureInitInternalPtr.asFunction<
      int Function(ffi.Pointer<WebPPicture>, int)>();

  /// Convenience allocation / deallocation based on picture->width/height:
  /// Allocate y/u/v buffers as per colorspace/width/height specification.
  /// Note! This function will free the previous buffer if needed.
  /// Returns false in case of memory error.
  int WebPPictureAlloc(
    ffi.Pointer<WebPPicture> picture,
  ) {
    return _WebPPictureAlloc(
      picture,
    );
  }

  late final _WebPPictureAllocPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<WebPPicture>)>>(
          'WebPPictureAlloc');
  late final _WebPPictureAlloc =
      _WebPPictureAllocPtr.asFunction<int Function(ffi.Pointer<WebPPicture>)>();

  /// Release the memory allocated by WebPPictureAlloc() or WebPPictureImport*().
  /// Note that this function does _not_ free the memory used by the 'picture'
  /// object itself.
  /// Besides memory (which is reclaimed) all other fields of 'picture' are
  /// preserved.
  void WebPPictureFree(
    ffi.Pointer<WebPPicture> picture,
  ) {
    return _WebPPictureFree(
      picture,
    );
  }

  late final _WebPPictureFreePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<WebPPicture>)>>(
          'WebPPictureFree');
  late final _WebPPictureFree =
      _WebPPictureFreePtr.asFunction<void Function(ffi.Pointer<WebPPicture>)>();

  /// Copy the pixels of *src into *dst, using WebPPictureAlloc. Upon return, *dst
  /// will fully own the copied pixels (this is not a view). The 'dst' picture need
  /// not be initialized as its content is overwritten.
  /// Returns false in case of memory allocation error.
  int WebPPictureCopy(
    ffi.Pointer<WebPPicture> src,
    ffi.Pointer<WebPPicture> dst,
  ) {
    return _WebPPictureCopy(
      src,
      dst,
    );
  }

  late final _WebPPictureCopyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<WebPPicture>,
              ffi.Pointer<WebPPicture>)>>('WebPPictureCopy');
  late final _WebPPictureCopy = _WebPPictureCopyPtr.asFunction<
      int Function(ffi.Pointer<WebPPicture>, ffi.Pointer<WebPPicture>)>();

  /// Compute the single distortion for packed planes of samples.
  /// 'src' will be compared to 'ref', and the raw distortion stored into
  /// '*distortion'. The refined metric (log(MSE), log(1 - ssim),...' will be
  /// stored in '*result'.
  /// 'x_step' is the horizontal stride (in bytes) between samples.
  /// 'src/ref_stride' is the byte distance between rows.
  /// Returns false in case of error (bad parameter, memory allocation error, ...).
  int WebPPlaneDistortion(
    ffi.Pointer<ffi.Uint8> src,
    int src_stride,
    ffi.Pointer<ffi.Uint8> ref,
    int ref_stride,
    int width,
    int height,
    int x_step,
    int type,
    ffi.Pointer<ffi.Float> distortion,
    ffi.Pointer<ffi.Float> result,
  ) {
    return _WebPPlaneDistortion(
      src,
      src_stride,
      ref,
      ref_stride,
      width,
      height,
      x_step,
      type,
      distortion,
      result,
    );
  }

  late final _WebPPlaneDistortionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Uint8>,
              ffi.Size,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size,
              ffi.Int,
              ffi.Int,
              ffi.Size,
              ffi.Int,
              ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Float>)>>('WebPPlaneDistortion');
  late final _WebPPlaneDistortion = _WebPPlaneDistortionPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Uint8>,
          int,
          ffi.Pointer<ffi.Uint8>,
          int,
          int,
          int,
          int,
          int,
          ffi.Pointer<ffi.Float>,
          ffi.Pointer<ffi.Float>)>();

  /// Compute PSNR, SSIM or LSIM distortion metric between two pictures. Results
  /// are in dB, stored in result[] in the B/G/R/A/All order. The distortion is
  /// always performed using ARGB samples. Hence if the input is YUV(A), the
  /// picture will be internally converted to ARGB (just for the measurement).
  /// Warning: this function is rather CPU-intensive.
  int WebPPictureDistortion(
    ffi.Pointer<WebPPicture> src,
    ffi.Pointer<WebPPicture> ref,
    int metric_type,
    ffi.Pointer<ffi.Float> result,
  ) {
    return _WebPPictureDistortion(
      src,
      ref,
      metric_type,
      result,
    );
  }

  late final _WebPPictureDistortionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<WebPPicture>, ffi.Pointer<WebPPicture>,
              ffi.Int, ffi.Pointer<ffi.Float>)>>('WebPPictureDistortion');
  late final _WebPPictureDistortion = _WebPPictureDistortionPtr.asFunction<
      int Function(ffi.Pointer<WebPPicture>, ffi.Pointer<WebPPicture>, int,
          ffi.Pointer<ffi.Float>)>();

  /// self-crops a picture to the rectangle defined by top/left/width/height.
  /// Returns false in case of memory allocation error, or if the rectangle is
  /// outside of the source picture.
  /// The rectangle for the view is defined by the top-left corner pixel
  /// coordinates (left, top) as well as its width and height. This rectangle
  /// must be fully be comprised inside the 'src' source picture. If the source
  /// picture uses the YUV420 colorspace, the top and left coordinates will be
  /// snapped to even values.
  int WebPPictureCrop(
    ffi.Pointer<WebPPicture> picture,
    int left,
    int top,
    int width,
    int height,
  ) {
    return _WebPPictureCrop(
      picture,
      left,
      top,
      width,
      height,
    );
  }

  late final _WebPPictureCropPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<WebPPicture>, ffi.Int, ffi.Int, ffi.Int,
              ffi.Int)>>('WebPPictureCrop');
  late final _WebPPictureCrop = _WebPPictureCropPtr.asFunction<
      int Function(ffi.Pointer<WebPPicture>, int, int, int, int)>();

  /// Extracts a view from 'src' picture into 'dst'. The rectangle for the view
  /// is defined by the top-left corner pixel coordinates (left, top) as well
  /// as its width and height. This rectangle must be fully be comprised inside
  /// the 'src' source picture. If the source picture uses the YUV420 colorspace,
  /// the top and left coordinates will be snapped to even values.
  /// Picture 'src' must out-live 'dst' picture. Self-extraction of view is allowed
  /// ('src' equal to 'dst') as a mean of fast-cropping (but note that doing so,
  /// the original dimension will be lost). Picture 'dst' need not be initialized
  /// with WebPPictureInit() if it is different from 'src', since its content will
  /// be overwritten.
  /// Returns false in case of invalid parameters.
  int WebPPictureView(
    ffi.Pointer<WebPPicture> src,
    int left,
    int top,
    int width,
    int height,
    ffi.Pointer<WebPPicture> dst,
  ) {
    return _WebPPictureView(
      src,
      left,
      top,
      width,
      height,
      dst,
    );
  }

  late final _WebPPictureViewPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<WebPPicture>, ffi.Int, ffi.Int, ffi.Int,
              ffi.Int, ffi.Pointer<WebPPicture>)>>('WebPPictureView');
  late final _WebPPictureView = _WebPPictureViewPtr.asFunction<
      int Function(ffi.Pointer<WebPPicture>, int, int, int, int,
          ffi.Pointer<WebPPicture>)>();

  /// Returns true if the 'picture' is actually a view and therefore does
  /// not own the memory for pixels.
  int WebPPictureIsView(
    ffi.Pointer<WebPPicture> picture,
  ) {
    return _WebPPictureIsView(
      picture,
    );
  }

  late final _WebPPictureIsViewPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<WebPPicture>)>>(
          'WebPPictureIsView');
  late final _WebPPictureIsView = _WebPPictureIsViewPtr.asFunction<
      int Function(ffi.Pointer<WebPPicture>)>();

  /// Rescale a picture to new dimension width x height.
  /// If either 'width' or 'height' (but not both) is 0 the corresponding
  /// dimension will be calculated preserving the aspect ratio.
  /// No gamma correction is applied.
  /// Returns false in case of error (invalid parameter or insufficient memory).
  int WebPPictureRescale(
    ffi.Pointer<WebPPicture> picture,
    int width,
    int height,
  ) {
    return _WebPPictureRescale(
      picture,
      width,
      height,
    );
  }

  late final _WebPPictureRescalePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<WebPPicture>, ffi.Int,
              ffi.Int)>>('WebPPictureRescale');
  late final _WebPPictureRescale = _WebPPictureRescalePtr.asFunction<
      int Function(ffi.Pointer<WebPPicture>, int, int)>();

  /// Colorspace conversion function to import RGB samples.
  /// Previous buffer will be free'd, if any.
  /// *rgb buffer should have a size of at least height * rgb_stride.
  /// Returns false in case of memory error.
  int WebPPictureImportRGB(
    ffi.Pointer<WebPPicture> picture,
    ffi.Pointer<ffi.Uint8> rgb,
    int rgb_stride,
  ) {
    return _WebPPictureImportRGB(
      picture,
      rgb,
      rgb_stride,
    );
  }

  late final _WebPPictureImportRGBPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<WebPPicture>, ffi.Pointer<ffi.Uint8>,
              ffi.Int)>>('WebPPictureImportRGB');
  late final _WebPPictureImportRGB = _WebPPictureImportRGBPtr.asFunction<
      int Function(ffi.Pointer<WebPPicture>, ffi.Pointer<ffi.Uint8>, int)>();

  /// Same, but for RGBA buffer.
  int WebPPictureImportRGBA(
    ffi.Pointer<WebPPicture> picture,
    ffi.Pointer<ffi.Uint8> rgba,
    int rgba_stride,
  ) {
    return _WebPPictureImportRGBA(
      picture,
      rgba,
      rgba_stride,
    );
  }

  late final _WebPPictureImportRGBAPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<WebPPicture>, ffi.Pointer<ffi.Uint8>,
              ffi.Int)>>('WebPPictureImportRGBA');
  late final _WebPPictureImportRGBA = _WebPPictureImportRGBAPtr.asFunction<
      int Function(ffi.Pointer<WebPPicture>, ffi.Pointer<ffi.Uint8>, int)>();

  /// Same, but for RGBA buffer. Imports the RGB direct from the 32-bit format
  /// input buffer ignoring the alpha channel. Avoids needing to copy the data
  /// to a temporary 24-bit RGB buffer to import the RGB only.
  int WebPPictureImportRGBX(
    ffi.Pointer<WebPPicture> picture,
    ffi.Pointer<ffi.Uint8> rgbx,
    int rgbx_stride,
  ) {
    return _WebPPictureImportRGBX(
      picture,
      rgbx,
      rgbx_stride,
    );
  }

  late final _WebPPictureImportRGBXPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<WebPPicture>, ffi.Pointer<ffi.Uint8>,
              ffi.Int)>>('WebPPictureImportRGBX');
  late final _WebPPictureImportRGBX = _WebPPictureImportRGBXPtr.asFunction<
      int Function(ffi.Pointer<WebPPicture>, ffi.Pointer<ffi.Uint8>, int)>();

  /// Variants of the above, but taking BGR(A|X) input.
  int WebPPictureImportBGR(
    ffi.Pointer<WebPPicture> picture,
    ffi.Pointer<ffi.Uint8> bgr,
    int bgr_stride,
  ) {
    return _WebPPictureImportBGR(
      picture,
      bgr,
      bgr_stride,
    );
  }

  late final _WebPPictureImportBGRPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<WebPPicture>, ffi.Pointer<ffi.Uint8>,
              ffi.Int)>>('WebPPictureImportBGR');
  late final _WebPPictureImportBGR = _WebPPictureImportBGRPtr.asFunction<
      int Function(ffi.Pointer<WebPPicture>, ffi.Pointer<ffi.Uint8>, int)>();

  int WebPPictureImportBGRA(
    ffi.Pointer<WebPPicture> picture,
    ffi.Pointer<ffi.Uint8> bgra,
    int bgra_stride,
  ) {
    return _WebPPictureImportBGRA(
      picture,
      bgra,
      bgra_stride,
    );
  }

  late final _WebPPictureImportBGRAPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<WebPPicture>, ffi.Pointer<ffi.Uint8>,
              ffi.Int)>>('WebPPictureImportBGRA');
  late final _WebPPictureImportBGRA = _WebPPictureImportBGRAPtr.asFunction<
      int Function(ffi.Pointer<WebPPicture>, ffi.Pointer<ffi.Uint8>, int)>();

  int WebPPictureImportBGRX(
    ffi.Pointer<WebPPicture> picture,
    ffi.Pointer<ffi.Uint8> bgrx,
    int bgrx_stride,
  ) {
    return _WebPPictureImportBGRX(
      picture,
      bgrx,
      bgrx_stride,
    );
  }

  late final _WebPPictureImportBGRXPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<WebPPicture>, ffi.Pointer<ffi.Uint8>,
              ffi.Int)>>('WebPPictureImportBGRX');
  late final _WebPPictureImportBGRX = _WebPPictureImportBGRXPtr.asFunction<
      int Function(ffi.Pointer<WebPPicture>, ffi.Pointer<ffi.Uint8>, int)>();

  /// Converts picture->argb data to the YUV420A format. The 'colorspace'
  /// parameter is deprecated and should be equal to WEBP_YUV420.
  /// Upon return, picture->use_argb is set to false. The presence of real
  /// non-opaque transparent values is detected, and 'colorspace' will be
  /// adjusted accordingly. Note that this method is lossy.
  /// Returns false in case of error.
  int WebPPictureARGBToYUVA(
    ffi.Pointer<WebPPicture> picture,
    int arg1,
  ) {
    return _WebPPictureARGBToYUVA(
      picture,
      arg1,
    );
  }

  late final _WebPPictureARGBToYUVAPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<WebPPicture>, ffi.Int32)>>('WebPPictureARGBToYUVA');
  late final _WebPPictureARGBToYUVA = _WebPPictureARGBToYUVAPtr.asFunction<
      int Function(ffi.Pointer<WebPPicture>, int)>();

  /// Same as WebPPictureARGBToYUVA(), but the conversion is done using
  /// pseudo-random dithering with a strength 'dithering' between
  /// 0.0 (no dithering) and 1.0 (maximum dithering). This is useful
  /// for photographic picture.
  int WebPPictureARGBToYUVADithered(
    ffi.Pointer<WebPPicture> picture,
    int colorspace,
    double dithering,
  ) {
    return _WebPPictureARGBToYUVADithered(
      picture,
      colorspace,
      dithering,
    );
  }

  late final _WebPPictureARGBToYUVADitheredPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<WebPPicture>, ffi.Int32,
              ffi.Float)>>('WebPPictureARGBToYUVADithered');
  late final _WebPPictureARGBToYUVADithered = _WebPPictureARGBToYUVADitheredPtr
      .asFunction<int Function(ffi.Pointer<WebPPicture>, int, double)>();

  /// Performs 'sharp' RGBA->YUVA420 downsampling and colorspace conversion.
  /// Downsampling is handled with extra care in case of color clipping. This
  /// method is roughly 2x slower than WebPPictureARGBToYUVA() but produces better
  /// and sharper YUV representation.
  /// Returns false in case of error.
  int WebPPictureSharpARGBToYUVA(
    ffi.Pointer<WebPPicture> picture,
  ) {
    return _WebPPictureSharpARGBToYUVA(
      picture,
    );
  }

  late final _WebPPictureSharpARGBToYUVAPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<WebPPicture>)>>(
          'WebPPictureSharpARGBToYUVA');
  late final _WebPPictureSharpARGBToYUVA = _WebPPictureSharpARGBToYUVAPtr
      .asFunction<int Function(ffi.Pointer<WebPPicture>)>();

  /// kept for backward compatibility:
  int WebPPictureSmartARGBToYUVA(
    ffi.Pointer<WebPPicture> picture,
  ) {
    return _WebPPictureSmartARGBToYUVA(
      picture,
    );
  }

  late final _WebPPictureSmartARGBToYUVAPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<WebPPicture>)>>(
          'WebPPictureSmartARGBToYUVA');
  late final _WebPPictureSmartARGBToYUVA = _WebPPictureSmartARGBToYUVAPtr
      .asFunction<int Function(ffi.Pointer<WebPPicture>)>();

  /// Converts picture->yuv to picture->argb and sets picture->use_argb to true.
  /// The input format must be YUV_420 or YUV_420A. The conversion from YUV420 to
  /// ARGB incurs a small loss too.
  /// Note that the use of this colorspace is discouraged if one has access to the
  /// raw ARGB samples, since using YUV420 is comparatively lossy.
  /// Returns false in case of error.
  int WebPPictureYUVAToARGB(
    ffi.Pointer<WebPPicture> picture,
  ) {
    return _WebPPictureYUVAToARGB(
      picture,
    );
  }

  late final _WebPPictureYUVAToARGBPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<WebPPicture>)>>(
          'WebPPictureYUVAToARGB');
  late final _WebPPictureYUVAToARGB = _WebPPictureYUVAToARGBPtr.asFunction<
      int Function(ffi.Pointer<WebPPicture>)>();

  /// Helper function: given a width x height plane of RGBA or YUV(A) samples
  /// clean-up or smoothen the YUV or RGB samples under fully transparent area,
  /// to help compressibility (no guarantee, though).
  void WebPCleanupTransparentArea(
    ffi.Pointer<WebPPicture> picture,
  ) {
    return _WebPCleanupTransparentArea(
      picture,
    );
  }

  late final _WebPCleanupTransparentAreaPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<WebPPicture>)>>(
          'WebPCleanupTransparentArea');
  late final _WebPCleanupTransparentArea = _WebPCleanupTransparentAreaPtr
      .asFunction<void Function(ffi.Pointer<WebPPicture>)>();

  /// Scan the picture 'picture' for the presence of non fully opaque alpha values.
  /// Returns true in such case. Otherwise returns false (indicating that the
  /// alpha plane can be ignored altogether e.g.).
  int WebPPictureHasTransparency(
    ffi.Pointer<WebPPicture> picture,
  ) {
    return _WebPPictureHasTransparency(
      picture,
    );
  }

  late final _WebPPictureHasTransparencyPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<WebPPicture>)>>(
          'WebPPictureHasTransparency');
  late final _WebPPictureHasTransparency = _WebPPictureHasTransparencyPtr
      .asFunction<int Function(ffi.Pointer<WebPPicture>)>();

  /// Remove the transparency information (if present) by blending the color with
  /// the background color 'background_rgb' (specified as 24bit RGB triplet).
  /// After this call, all alpha values are reset to 0xff.
  void WebPBlendAlpha(
    ffi.Pointer<WebPPicture> picture,
    int background_rgb,
  ) {
    return _WebPBlendAlpha(
      picture,
      background_rgb,
    );
  }

  late final _WebPBlendAlphaPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<WebPPicture>, ffi.Uint32)>>('WebPBlendAlpha');
  late final _WebPBlendAlpha = _WebPBlendAlphaPtr.asFunction<
      void Function(ffi.Pointer<WebPPicture>, int)>();

  /// Main encoding call, after config and picture have been initialized.
  /// 'picture' must be less than 16384x16384 in dimension (cf WEBP_MAX_DIMENSION),
  /// and the 'config' object must be a valid one.
  /// Returns false in case of error, true otherwise.
  /// In case of error, picture->error_code is updated accordingly.
  /// 'picture' can hold the source samples in both YUV(A) or ARGB input, depending
  /// on the value of 'picture->use_argb'. It is highly recommended to use
  /// the former for lossy encoding, and the latter for lossless encoding
  /// (when config.lossless is true). Automatic conversion from one format to
  /// another is provided but they both incur some loss.
  int WebPEncode(
    ffi.Pointer<WebPConfig> config,
    ffi.Pointer<WebPPicture> picture,
  ) {
    return _WebPEncode(
      config,
      picture,
    );
  }

  late final _WebPEncodePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<WebPConfig>,
              ffi.Pointer<WebPPicture>)>>('WebPEncode');
  late final _WebPEncode = _WebPEncodePtr.asFunction<
      int Function(ffi.Pointer<WebPConfig>, ffi.Pointer<WebPPicture>)>();

  /// Returns the version number of the mux library, packed in hexadecimal using
  /// 8bits for each of major/minor/revision. E.g: v2.5.7 is 0x020507.
  int WebPGetMuxVersion() {
    return _WebPGetMuxVersion();
  }

  late final _WebPGetMuxVersionPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('WebPGetMuxVersion');
  late final _WebPGetMuxVersion =
      _WebPGetMuxVersionPtr.asFunction<int Function()>();

  /// Internal, version-checked, entry point
  ffi.Pointer<WebPMux> WebPNewInternal(
    int arg0,
  ) {
    return _WebPNewInternal(
      arg0,
    );
  }

  late final _WebPNewInternalPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<WebPMux> Function(ffi.Int)>>(
          'WebPNewInternal');
  late final _WebPNewInternal =
      _WebPNewInternalPtr.asFunction<ffi.Pointer<WebPMux> Function(int)>();

  /// Deletes the mux object.
  /// Parameters:
  /// mux - (in/out) object to be deleted
  void WebPMuxDelete(
    ffi.Pointer<WebPMux> mux,
  ) {
    return _WebPMuxDelete(
      mux,
    );
  }

  late final _WebPMuxDeletePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<WebPMux>)>>(
          'WebPMuxDelete');
  late final _WebPMuxDelete =
      _WebPMuxDeletePtr.asFunction<void Function(ffi.Pointer<WebPMux>)>();

  /// Internal, version-checked, entry point
  ffi.Pointer<WebPMux> WebPMuxCreateInternal(
    ffi.Pointer<WebPData> arg0,
    int arg1,
    int arg2,
  ) {
    return _WebPMuxCreateInternal(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _WebPMuxCreateInternalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<WebPMux> Function(ffi.Pointer<WebPData>, ffi.Int,
              ffi.Int)>>('WebPMuxCreateInternal');
  late final _WebPMuxCreateInternal = _WebPMuxCreateInternalPtr.asFunction<
      ffi.Pointer<WebPMux> Function(ffi.Pointer<WebPData>, int, int)>();

  /// Adds a chunk with id 'fourcc' and data 'chunk_data' in the mux object.
  /// Any existing chunk(s) with the same id will be removed.
  /// Parameters:
  /// mux - (in/out) object to which the chunk is to be added
  /// fourcc - (in) a character array containing the fourcc of the given chunk;
  /// e.g., "ICCP", "XMP ", "EXIF" etc.
  /// chunk_data - (in) the chunk data to be added
  /// copy_data - (in) value 1 indicates given data WILL be copied to the mux
  /// object and value 0 indicates data will NOT be copied.
  /// Returns:
  /// WEBP_MUX_INVALID_ARGUMENT - if mux, fourcc or chunk_data is NULL
  /// or if fourcc corresponds to an image chunk.
  /// WEBP_MUX_MEMORY_ERROR - on memory allocation error.
  /// WEBP_MUX_OK - on success.
  int WebPMuxSetChunk(
    ffi.Pointer<WebPMux> mux,
    ffi.Pointer<ffi.Char> fourcc,
    ffi.Pointer<WebPData> chunk_data,
    int copy_data,
  ) {
    return _WebPMuxSetChunk(
      mux,
      fourcc,
      chunk_data,
      copy_data,
    );
  }

  late final _WebPMuxSetChunkPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<WebPMux>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<WebPData>, ffi.Int)>>('WebPMuxSetChunk');
  late final _WebPMuxSetChunk = _WebPMuxSetChunkPtr.asFunction<
      int Function(ffi.Pointer<WebPMux>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<WebPData>, int)>();

  /// Gets a reference to the data of the chunk with id 'fourcc' in the mux object.
  /// The caller should NOT free the returned data.
  /// Parameters:
  /// mux - (in) object from which the chunk data is to be fetched
  /// fourcc - (in) a character array containing the fourcc of the chunk;
  /// e.g., "ICCP", "XMP ", "EXIF" etc.
  /// chunk_data - (out) returned chunk data
  /// Returns:
  /// WEBP_MUX_INVALID_ARGUMENT - if mux, fourcc or chunk_data is NULL
  /// or if fourcc corresponds to an image chunk.
  /// WEBP_MUX_NOT_FOUND - If mux does not contain a chunk with the given id.
  /// WEBP_MUX_OK - on success.
  int WebPMuxGetChunk(
    ffi.Pointer<WebPMux> mux,
    ffi.Pointer<ffi.Char> fourcc,
    ffi.Pointer<WebPData> chunk_data,
  ) {
    return _WebPMuxGetChunk(
      mux,
      fourcc,
      chunk_data,
    );
  }

  late final _WebPMuxGetChunkPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<WebPMux>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<WebPData>)>>('WebPMuxGetChunk');
  late final _WebPMuxGetChunk = _WebPMuxGetChunkPtr.asFunction<
      int Function(ffi.Pointer<WebPMux>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<WebPData>)>();

  /// Deletes the chunk with the given 'fourcc' from the mux object.
  /// Parameters:
  /// mux - (in/out) object from which the chunk is to be deleted
  /// fourcc - (in) a character array containing the fourcc of the chunk;
  /// e.g., "ICCP", "XMP ", "EXIF" etc.
  /// Returns:
  /// WEBP_MUX_INVALID_ARGUMENT - if mux or fourcc is NULL
  /// or if fourcc corresponds to an image chunk.
  /// WEBP_MUX_NOT_FOUND - If mux does not contain a chunk with the given fourcc.
  /// WEBP_MUX_OK - on success.
  int WebPMuxDeleteChunk(
    ffi.Pointer<WebPMux> mux,
    ffi.Pointer<ffi.Char> fourcc,
  ) {
    return _WebPMuxDeleteChunk(
      mux,
      fourcc,
    );
  }

  late final _WebPMuxDeleteChunkPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<WebPMux>,
              ffi.Pointer<ffi.Char>)>>('WebPMuxDeleteChunk');
  late final _WebPMuxDeleteChunk = _WebPMuxDeleteChunkPtr.asFunction<
      int Function(ffi.Pointer<WebPMux>, ffi.Pointer<ffi.Char>)>();

  /// Sets the (non-animated) image in the mux object.
  /// Note: Any existing images (including frames) will be removed.
  /// Parameters:
  /// mux - (in/out) object in which the image is to be set
  /// bitstream - (in) can be a raw VP8/VP8L bitstream or a single-image
  /// WebP file (non-animated)
  /// copy_data - (in) value 1 indicates given data WILL be copied to the mux
  /// object and value 0 indicates data will NOT be copied.
  /// Returns:
  /// WEBP_MUX_INVALID_ARGUMENT - if mux is NULL or bitstream is NULL.
  /// WEBP_MUX_MEMORY_ERROR - on memory allocation error.
  /// WEBP_MUX_OK - on success.
  int WebPMuxSetImage(
    ffi.Pointer<WebPMux> mux,
    ffi.Pointer<WebPData> bitstream,
    int copy_data,
  ) {
    return _WebPMuxSetImage(
      mux,
      bitstream,
      copy_data,
    );
  }

  late final _WebPMuxSetImagePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<WebPMux>, ffi.Pointer<WebPData>,
              ffi.Int)>>('WebPMuxSetImage');
  late final _WebPMuxSetImage = _WebPMuxSetImagePtr.asFunction<
      int Function(ffi.Pointer<WebPMux>, ffi.Pointer<WebPData>, int)>();

  /// Adds a frame at the end of the mux object.
  /// Notes: (1) frame.id should be WEBP_CHUNK_ANMF
  /// (2) For setting a non-animated image, use WebPMuxSetImage() instead.
  /// (3) Type of frame being pushed must be same as the frames in mux.
  /// (4) As WebP only supports even offsets, any odd offset will be snapped
  /// to an even location using: offset &= ~1
  /// Parameters:
  /// mux - (in/out) object to which the frame is to be added
  /// frame - (in) frame data.
  /// copy_data - (in) value 1 indicates given data WILL be copied to the mux
  /// object and value 0 indicates data will NOT be copied.
  /// Returns:
  /// WEBP_MUX_INVALID_ARGUMENT - if mux or frame is NULL
  /// or if content of 'frame' is invalid.
  /// WEBP_MUX_MEMORY_ERROR - on memory allocation error.
  /// WEBP_MUX_OK - on success.
  int WebPMuxPushFrame(
    ffi.Pointer<WebPMux> mux,
    ffi.Pointer<WebPMuxFrameInfo> frame,
    int copy_data,
  ) {
    return _WebPMuxPushFrame(
      mux,
      frame,
      copy_data,
    );
  }

  late final _WebPMuxPushFramePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<WebPMux>,
              ffi.Pointer<WebPMuxFrameInfo>, ffi.Int)>>('WebPMuxPushFrame');
  late final _WebPMuxPushFrame = _WebPMuxPushFramePtr.asFunction<
      int Function(ffi.Pointer<WebPMux>, ffi.Pointer<WebPMuxFrameInfo>, int)>();

  /// Gets the nth frame from the mux object.
  /// The content of 'frame->bitstream' is allocated using WebPMalloc(), and NOT
  /// owned by the 'mux' object. It MUST be deallocated by the caller by calling
  /// WebPDataClear().
  /// nth=0 has a special meaning - last position.
  /// Parameters:
  /// mux - (in) object from which the info is to be fetched
  /// nth - (in) index of the frame in the mux object
  /// frame - (out) data of the returned frame
  /// Returns:
  /// WEBP_MUX_INVALID_ARGUMENT - if mux or frame is NULL.
  /// WEBP_MUX_NOT_FOUND - if there are less than nth frames in the mux object.
  /// WEBP_MUX_BAD_DATA - if nth frame chunk in mux is invalid.
  /// WEBP_MUX_MEMORY_ERROR - on memory allocation error.
  /// WEBP_MUX_OK - on success.
  int WebPMuxGetFrame(
    ffi.Pointer<WebPMux> mux,
    int nth,
    ffi.Pointer<WebPMuxFrameInfo> frame,
  ) {
    return _WebPMuxGetFrame(
      mux,
      nth,
      frame,
    );
  }

  late final _WebPMuxGetFramePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<WebPMux>, ffi.Uint32,
              ffi.Pointer<WebPMuxFrameInfo>)>>('WebPMuxGetFrame');
  late final _WebPMuxGetFrame = _WebPMuxGetFramePtr.asFunction<
      int Function(ffi.Pointer<WebPMux>, int, ffi.Pointer<WebPMuxFrameInfo>)>();

  /// Deletes a frame from the mux object.
  /// nth=0 has a special meaning - last position.
  /// Parameters:
  /// mux - (in/out) object from which a frame is to be deleted
  /// nth - (in) The position from which the frame is to be deleted
  /// Returns:
  /// WEBP_MUX_INVALID_ARGUMENT - if mux is NULL.
  /// WEBP_MUX_NOT_FOUND - If there are less than nth frames in the mux object
  /// before deletion.
  /// WEBP_MUX_OK - on success.
  int WebPMuxDeleteFrame(
    ffi.Pointer<WebPMux> mux,
    int nth,
  ) {
    return _WebPMuxDeleteFrame(
      mux,
      nth,
    );
  }

  late final _WebPMuxDeleteFramePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<WebPMux>, ffi.Uint32)>>('WebPMuxDeleteFrame');
  late final _WebPMuxDeleteFrame = _WebPMuxDeleteFramePtr.asFunction<
      int Function(ffi.Pointer<WebPMux>, int)>();

  /// Sets the animation parameters in the mux object. Any existing ANIM chunks
  /// will be removed.
  /// Parameters:
  /// mux - (in/out) object in which ANIM chunk is to be set/added
  /// params - (in) animation parameters.
  /// Returns:
  /// WEBP_MUX_INVALID_ARGUMENT - if mux or params is NULL.
  /// WEBP_MUX_MEMORY_ERROR - on memory allocation error.
  /// WEBP_MUX_OK - on success.
  int WebPMuxSetAnimationParams(
    ffi.Pointer<WebPMux> mux,
    ffi.Pointer<WebPMuxAnimParams> params,
  ) {
    return _WebPMuxSetAnimationParams(
      mux,
      params,
    );
  }

  late final _WebPMuxSetAnimationParamsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<WebPMux>,
              ffi.Pointer<WebPMuxAnimParams>)>>('WebPMuxSetAnimationParams');
  late final _WebPMuxSetAnimationParams =
      _WebPMuxSetAnimationParamsPtr.asFunction<
          int Function(ffi.Pointer<WebPMux>, ffi.Pointer<WebPMuxAnimParams>)>();

  /// Gets the animation parameters from the mux object.
  /// Parameters:
  /// mux - (in) object from which the animation parameters to be fetched
  /// params - (out) animation parameters extracted from the ANIM chunk
  /// Returns:
  /// WEBP_MUX_INVALID_ARGUMENT - if mux or params is NULL.
  /// WEBP_MUX_NOT_FOUND - if ANIM chunk is not present in mux object.
  /// WEBP_MUX_OK - on success.
  int WebPMuxGetAnimationParams(
    ffi.Pointer<WebPMux> mux,
    ffi.Pointer<WebPMuxAnimParams> params,
  ) {
    return _WebPMuxGetAnimationParams(
      mux,
      params,
    );
  }

  late final _WebPMuxGetAnimationParamsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<WebPMux>,
              ffi.Pointer<WebPMuxAnimParams>)>>('WebPMuxGetAnimationParams');
  late final _WebPMuxGetAnimationParams =
      _WebPMuxGetAnimationParamsPtr.asFunction<
          int Function(ffi.Pointer<WebPMux>, ffi.Pointer<WebPMuxAnimParams>)>();

  /// Sets the canvas size for the mux object. The width and height can be
  /// specified explicitly or left as zero (0, 0).
  /// * When width and height are specified explicitly, then this frame bound is
  /// enforced during subsequent calls to WebPMuxAssemble() and an error is
  /// reported if any animated frame does not completely fit within the canvas.
  /// * When unspecified (0, 0), the constructed canvas will get the frame bounds
  /// from the bounding-box over all frames after calling WebPMuxAssemble().
  /// Parameters:
  /// mux - (in) object to which the canvas size is to be set
  /// width - (in) canvas width
  /// height - (in) canvas height
  /// Returns:
  /// WEBP_MUX_INVALID_ARGUMENT - if mux is NULL; or
  /// width or height are invalid or out of bounds
  /// WEBP_MUX_OK - on success.
  int WebPMuxSetCanvasSize(
    ffi.Pointer<WebPMux> mux,
    int width,
    int height,
  ) {
    return _WebPMuxSetCanvasSize(
      mux,
      width,
      height,
    );
  }

  late final _WebPMuxSetCanvasSizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<WebPMux>, ffi.Int, ffi.Int)>>('WebPMuxSetCanvasSize');
  late final _WebPMuxSetCanvasSize = _WebPMuxSetCanvasSizePtr.asFunction<
      int Function(ffi.Pointer<WebPMux>, int, int)>();

  /// Gets the canvas size from the mux object.
  /// Note: This method assumes that the VP8X chunk, if present, is up-to-date.
  /// That is, the mux object hasn't been modified since the last call to
  /// WebPMuxAssemble() or WebPMuxCreate().
  /// Parameters:
  /// mux - (in) object from which the canvas size is to be fetched
  /// width - (out) canvas width
  /// height - (out) canvas height
  /// Returns:
  /// WEBP_MUX_INVALID_ARGUMENT - if mux, width or height is NULL.
  /// WEBP_MUX_BAD_DATA - if VP8X/VP8/VP8L chunk or canvas size is invalid.
  /// WEBP_MUX_OK - on success.
  int WebPMuxGetCanvasSize(
    ffi.Pointer<WebPMux> mux,
    ffi.Pointer<ffi.Int> width,
    ffi.Pointer<ffi.Int> height,
  ) {
    return _WebPMuxGetCanvasSize(
      mux,
      width,
      height,
    );
  }

  late final _WebPMuxGetCanvasSizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<WebPMux>, ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('WebPMuxGetCanvasSize');
  late final _WebPMuxGetCanvasSize = _WebPMuxGetCanvasSizePtr.asFunction<
      int Function(
          ffi.Pointer<WebPMux>, ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>();

  /// Gets the feature flags from the mux object.
  /// Note: This method assumes that the VP8X chunk, if present, is up-to-date.
  /// That is, the mux object hasn't been modified since the last call to
  /// WebPMuxAssemble() or WebPMuxCreate().
  /// Parameters:
  /// mux - (in) object from which the features are to be fetched
  /// flags - (out) the flags specifying which features are present in the
  /// mux object. This will be an OR of various flag values.
  /// Enum 'WebPFeatureFlags' can be used to test individual flag values.
  /// Returns:
  /// WEBP_MUX_INVALID_ARGUMENT - if mux or flags is NULL.
  /// WEBP_MUX_BAD_DATA - if VP8X/VP8/VP8L chunk or canvas size is invalid.
  /// WEBP_MUX_OK - on success.
  int WebPMuxGetFeatures(
    ffi.Pointer<WebPMux> mux,
    ffi.Pointer<ffi.Uint32> flags,
  ) {
    return _WebPMuxGetFeatures(
      mux,
      flags,
    );
  }

  late final _WebPMuxGetFeaturesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<WebPMux>,
              ffi.Pointer<ffi.Uint32>)>>('WebPMuxGetFeatures');
  late final _WebPMuxGetFeatures = _WebPMuxGetFeaturesPtr.asFunction<
      int Function(ffi.Pointer<WebPMux>, ffi.Pointer<ffi.Uint32>)>();

  /// Gets number of chunks with the given 'id' in the mux object.
  /// Parameters:
  /// mux - (in) object from which the info is to be fetched
  /// id - (in) chunk id specifying the type of chunk
  /// num_elements - (out) number of chunks with the given chunk id
  /// Returns:
  /// WEBP_MUX_INVALID_ARGUMENT - if mux, or num_elements is NULL.
  /// WEBP_MUX_OK - on success.
  int WebPMuxNumChunks(
    ffi.Pointer<WebPMux> mux,
    int id,
    ffi.Pointer<ffi.Int> num_elements,
  ) {
    return _WebPMuxNumChunks(
      mux,
      id,
      num_elements,
    );
  }

  late final _WebPMuxNumChunksPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<WebPMux>, ffi.Int32,
              ffi.Pointer<ffi.Int>)>>('WebPMuxNumChunks');
  late final _WebPMuxNumChunks = _WebPMuxNumChunksPtr.asFunction<
      int Function(ffi.Pointer<WebPMux>, int, ffi.Pointer<ffi.Int>)>();

  /// Assembles all chunks in WebP RIFF format and returns in 'assembled_data'.
  /// This function also validates the mux object.
  /// Note: The content of 'assembled_data' will be ignored and overwritten.
  /// Also, the content of 'assembled_data' is allocated using WebPMalloc(), and
  /// NOT owned by the 'mux' object. It MUST be deallocated by the caller by
  /// calling WebPDataClear(). It's always safe to call WebPDataClear() upon
  /// return, even in case of error.
  /// Parameters:
  /// mux - (in/out) object whose chunks are to be assembled
  /// assembled_data - (out) assembled WebP data
  /// Returns:
  /// WEBP_MUX_BAD_DATA - if mux object is invalid.
  /// WEBP_MUX_INVALID_ARGUMENT - if mux or assembled_data is NULL.
  /// WEBP_MUX_MEMORY_ERROR - on memory allocation error.
  /// WEBP_MUX_OK - on success.
  int WebPMuxAssemble(
    ffi.Pointer<WebPMux> mux,
    ffi.Pointer<WebPData> assembled_data,
  ) {
    return _WebPMuxAssemble(
      mux,
      assembled_data,
    );
  }

  late final _WebPMuxAssemblePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<WebPMux>, ffi.Pointer<WebPData>)>>('WebPMuxAssemble');
  late final _WebPMuxAssemble = _WebPMuxAssemblePtr.asFunction<
      int Function(ffi.Pointer<WebPMux>, ffi.Pointer<WebPData>)>();

  /// Internal, version-checked, entry point.
  int WebPAnimEncoderOptionsInitInternal(
    ffi.Pointer<WebPAnimEncoderOptions> arg0,
    int arg1,
  ) {
    return _WebPAnimEncoderOptionsInitInternal(
      arg0,
      arg1,
    );
  }

  late final _WebPAnimEncoderOptionsInitInternalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<WebPAnimEncoderOptions>,
              ffi.Int)>>('WebPAnimEncoderOptionsInitInternal');
  late final _WebPAnimEncoderOptionsInitInternal =
      _WebPAnimEncoderOptionsInitInternalPtr.asFunction<
          int Function(ffi.Pointer<WebPAnimEncoderOptions>, int)>();

  /// Internal, version-checked, entry point.
  ffi.Pointer<WebPAnimEncoder> WebPAnimEncoderNewInternal(
    int arg0,
    int arg1,
    ffi.Pointer<WebPAnimEncoderOptions> arg2,
    int arg3,
  ) {
    return _WebPAnimEncoderNewInternal(
      arg0,
      arg1,
      arg2,
      arg3,
    );
  }

  late final _WebPAnimEncoderNewInternalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<WebPAnimEncoder> Function(
              ffi.Int,
              ffi.Int,
              ffi.Pointer<WebPAnimEncoderOptions>,
              ffi.Int)>>('WebPAnimEncoderNewInternal');
  late final _WebPAnimEncoderNewInternal =
      _WebPAnimEncoderNewInternalPtr.asFunction<
          ffi.Pointer<WebPAnimEncoder> Function(
              int, int, ffi.Pointer<WebPAnimEncoderOptions>, int)>();

  /// Optimize the given frame for WebP, encode it and add it to the
  /// WebPAnimEncoder object.
  /// The last call to 'WebPAnimEncoderAdd' should be with frame = NULL, which
  /// indicates that no more frames are to be added. This call is also used to
  /// determine the duration of the last frame.
  /// Parameters:
  /// enc - (in/out) object to which the frame is to be added.
  /// frame - (in/out) frame data in ARGB or YUV(A) format. If it is in YUV(A)
  /// format, it will be converted to ARGB, which incurs a small loss.
  /// timestamp_ms - (in) timestamp of this frame in milliseconds.
  /// Duration of a frame would be calculated as
  /// "timestamp of next frame - timestamp of this frame".
  /// Hence, timestamps should be in non-decreasing order.
  /// config - (in) encoding options; can be passed NULL to pick
  /// reasonable defaults.
  /// Returns:
  /// On error, returns false and frame->error_code is set appropriately.
  /// Otherwise, returns true.
  int WebPAnimEncoderAdd(
    ffi.Pointer<WebPAnimEncoder> enc,
    ffi.Pointer<WebPPicture> frame,
    int timestamp_ms,
    ffi.Pointer<WebPConfig> config,
  ) {
    return _WebPAnimEncoderAdd(
      enc,
      frame,
      timestamp_ms,
      config,
    );
  }

  late final _WebPAnimEncoderAddPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<WebPAnimEncoder>,
              ffi.Pointer<WebPPicture>,
              ffi.Int,
              ffi.Pointer<WebPConfig>)>>('WebPAnimEncoderAdd');
  late final _WebPAnimEncoderAdd = _WebPAnimEncoderAddPtr.asFunction<
      int Function(ffi.Pointer<WebPAnimEncoder>, ffi.Pointer<WebPPicture>, int,
          ffi.Pointer<WebPConfig>)>();

  /// Assemble all frames added so far into a WebP bitstream.
  /// This call should be preceded by  a call to 'WebPAnimEncoderAdd' with
  /// frame = NULL; if not, the duration of the last frame will be internally
  /// estimated.
  /// Parameters:
  /// enc - (in/out) object from which the frames are to be assembled.
  /// webp_data - (out) generated WebP bitstream.
  /// Returns:
  /// True on success.
  int WebPAnimEncoderAssemble(
    ffi.Pointer<WebPAnimEncoder> enc,
    ffi.Pointer<WebPData> webp_data,
  ) {
    return _WebPAnimEncoderAssemble(
      enc,
      webp_data,
    );
  }

  late final _WebPAnimEncoderAssemblePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<WebPAnimEncoder>,
              ffi.Pointer<WebPData>)>>('WebPAnimEncoderAssemble');
  late final _WebPAnimEncoderAssemble = _WebPAnimEncoderAssemblePtr.asFunction<
      int Function(ffi.Pointer<WebPAnimEncoder>, ffi.Pointer<WebPData>)>();

  /// Get error string corresponding to the most recent call using 'enc'. The
  /// returned string is owned by 'enc' and is valid only until the next call to
  /// WebPAnimEncoderAdd() or WebPAnimEncoderAssemble() or WebPAnimEncoderDelete().
  /// Parameters:
  /// enc - (in/out) object from which the error string is to be fetched.
  /// Returns:
  /// NULL if 'enc' is NULL. Otherwise, returns the error string if the last call
  /// to 'enc' had an error, or an empty string if the last call was a success.
  ffi.Pointer<ffi.Char> WebPAnimEncoderGetError(
    ffi.Pointer<WebPAnimEncoder> enc,
  ) {
    return _WebPAnimEncoderGetError(
      enc,
    );
  }

  late final _WebPAnimEncoderGetErrorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<WebPAnimEncoder>)>>('WebPAnimEncoderGetError');
  late final _WebPAnimEncoderGetError = _WebPAnimEncoderGetErrorPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<WebPAnimEncoder>)>();

  /// Deletes the WebPAnimEncoder object.
  /// Parameters:
  /// enc - (in/out) object to be deleted
  void WebPAnimEncoderDelete(
    ffi.Pointer<WebPAnimEncoder> enc,
  ) {
    return _WebPAnimEncoderDelete(
      enc,
    );
  }

  late final _WebPAnimEncoderDeletePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<WebPAnimEncoder>)>>(
      'WebPAnimEncoderDelete');
  late final _WebPAnimEncoderDelete = _WebPAnimEncoderDeletePtr.asFunction<
      void Function(ffi.Pointer<WebPAnimEncoder>)>();
}

typedef va_list = ffi.Pointer<ffi.Char>;

final class __crt_locale_data_public extends ffi.Struct {
  external ffi.Pointer<ffi.UnsignedShort> _locale_pctype;

  @ffi.Int()
  external int _locale_mb_cur_max;

  @ffi.UnsignedInt()
  external int _locale_lc_codepage;
}

final class __crt_locale_pointers extends ffi.Struct {
  external ffi.Pointer<__crt_locale_data> locinfo;

  external ffi.Pointer<__crt_multibyte_data> mbcinfo;
}

final class __crt_locale_data extends ffi.Opaque {}

final class __crt_multibyte_data extends ffi.Opaque {}

final class _Mbstatet extends ffi.Struct {
  @ffi.UnsignedLong()
  external int _Wchar;

  @ffi.UnsignedShort()
  external int _Byte;

  @ffi.UnsignedShort()
  external int _State;
}

typedef errno_t = ffi.Int;
typedef Darterrno_t = int;

/// ------------------------------------------------------------------------------
/// WebPDecBuffer: Generic structure for describing the output sample buffer.
final class WebPRGBABuffer extends ffi.Struct {
  /// pointer to RGBA samples
  external ffi.Pointer<ffi.Uint8> rgba;

  /// stride in bytes from one scanline to the next.
  @ffi.Int()
  external int stride;

  /// total size of the *rgba buffer.
  @ffi.Size()
  external int size;
}

final class WebPYUVABuffer extends ffi.Struct {
  /// pointer to luma, chroma U/V, alpha samples
  external ffi.Pointer<ffi.Uint8> y;

  external ffi.Pointer<ffi.Uint8> u;

  external ffi.Pointer<ffi.Uint8> v;

  external ffi.Pointer<ffi.Uint8> a;

  /// luma stride
  @ffi.Int()
  external int y_stride;

  /// chroma strides
  @ffi.Int()
  external int u_stride;

  @ffi.Int()
  external int v_stride;

  /// alpha stride
  @ffi.Int()
  external int a_stride;

  /// luma plane size
  @ffi.Size()
  external int y_size;

  /// chroma planes size
  @ffi.Size()
  external int u_size;

  @ffi.Size()
  external int v_size;

  /// alpha-plane size
  @ffi.Size()
  external int a_size;
}

/// Output buffer
final class WebPDecBuffer extends ffi.Struct {
  /// Colorspace.
  @ffi.Int32()
  external int colorspace;

  /// Dimensions.
  @ffi.Int()
  external int width;

  @ffi.Int()
  external int height;

  /// If non-zero, 'internal_memory' pointer is not
  /// used. If value is '2' or more, the external
  /// memory is considered 'slow' and multiple
  /// read/write will be avoided.
  @ffi.Int()
  external int is_external_memory;

  /// Nameless union of buffer parameters.
  external UnnamedUnion1 u;

  /// padding for later use
  @ffi.Array.multi([4])
  external ffi.Array<ffi.Uint32> pad;

  /// Internally allocated memory (only when
  /// is_external_memory is 0). Should not be used
  /// externally, but accessed via the buffer union.
  external ffi.Pointer<ffi.Uint8> private_memory;
}

/// Colorspaces
/// Note: the naming describes the byte-ordering of packed samples in memory.
/// For instance, MODE_BGRA relates to samples ordered as B,G,R,A,B,G,R,A,...
/// Non-capital names (e.g.:MODE_Argb) relates to pre-multiplied RGB channels.
/// RGBA-4444 and RGB-565 colorspaces are represented by following byte-order:
/// RGBA-4444: [r3 r2 r1 r0 g3 g2 g1 g0], [b3 b2 b1 b0 a3 a2 a1 a0], ...
/// RGB-565: [r4 r3 r2 r1 r0 g5 g4 g3], [g2 g1 g0 b4 b3 b2 b1 b0], ...
/// In the case WEBP_SWAP_16BITS_CSP is defined, the bytes are swapped for
/// these two modes:
/// RGBA-4444: [b3 b2 b1 b0 a3 a2 a1 a0], [r3 r2 r1 r0 g3 g2 g1 g0], ...
/// RGB-565: [g2 g1 g0 b4 b3 b2 b1 b0], [r4 r3 r2 r1 r0 g5 g4 g3], ...
abstract class WEBP_CSP_MODE {
  static const int MODE_RGB = 0;
  static const int MODE_RGBA = 1;
  static const int MODE_BGR = 2;
  static const int MODE_BGRA = 3;
  static const int MODE_ARGB = 4;
  static const int MODE_RGBA_4444 = 5;
  static const int MODE_RGB_565 = 6;

  /// RGB-premultiplied transparent modes (alpha value is preserved)
  static const int MODE_rgbA = 7;
  static const int MODE_bgrA = 8;
  static const int MODE_Argb = 9;
  static const int MODE_rgbA_4444 = 10;

  /// yuv 4:2:0
  static const int MODE_YUV = 11;
  static const int MODE_YUVA = 12;
  static const int MODE_LAST = 13;
}

final class UnnamedUnion1 extends ffi.Union {
  external WebPRGBABuffer RGBA;

  external WebPYUVABuffer YUVA;
}

final class WebPIDecoder extends ffi.Opaque {}

/// Features gathered from the bitstream
final class WebPBitstreamFeatures extends ffi.Struct {
  /// Width in pixels, as read from the bitstream.
  @ffi.Int()
  external int width;

  /// Height in pixels, as read from the bitstream.
  @ffi.Int()
  external int height;

  /// True if the bitstream contains an alpha channel.
  @ffi.Int()
  external int has_alpha;

  /// True if the bitstream is an animation.
  @ffi.Int()
  external int has_animation;

  /// 0 = undefined (/mixed), 1 = lossy, 2 = lossless
  @ffi.Int()
  external int format;

  /// padding for later use
  @ffi.Array.multi([5])
  external ffi.Array<ffi.Uint32> pad;
}

/// Decoding options
final class WebPDecoderOptions extends ffi.Struct {
  /// if true, skip the in-loop filtering
  @ffi.Int()
  external int bypass_filtering;

  /// if true, use faster pointwise upsampler
  @ffi.Int()
  external int no_fancy_upsampling;

  /// if true, cropping is applied _first_
  @ffi.Int()
  external int use_cropping;

  /// top-left position for cropping.
  /// Will be snapped to even values.
  @ffi.Int()
  external int crop_left;

  @ffi.Int()
  external int crop_top;

  /// dimension of the cropping area
  @ffi.Int()
  external int crop_width;

  @ffi.Int()
  external int crop_height;

  /// if true, scaling is applied _afterward_
  @ffi.Int()
  external int use_scaling;

  /// final resolution
  @ffi.Int()
  external int scaled_width;

  @ffi.Int()
  external int scaled_height;

  /// if true, use multi-threaded decoding
  @ffi.Int()
  external int use_threads;

  /// dithering strength (0=Off, 100=full)
  @ffi.Int()
  external int dithering_strength;

  /// if true, flip output vertically
  @ffi.Int()
  external int flip;

  /// alpha dithering strength in [0..100]
  @ffi.Int()
  external int alpha_dithering_strength;

  /// padding for later use
  @ffi.Array.multi([5])
  external ffi.Array<ffi.Uint32> pad;
}

/// Main object storing the configuration for advanced decoding.
final class WebPDecoderConfig extends ffi.Struct {
  /// Immutable bitstream features (optional)
  external WebPBitstreamFeatures input;

  /// Output buffer (can point to external mem)
  external WebPDecBuffer output;

  /// Decoding options
  external WebPDecoderOptions options;
}

/// ------------------------------------------------------------------------------
/// Enumeration of the status codes
abstract class VP8StatusCode {
  static const int VP8_STATUS_OK = 0;
  static const int VP8_STATUS_OUT_OF_MEMORY = 1;
  static const int VP8_STATUS_INVALID_PARAM = 2;
  static const int VP8_STATUS_BITSTREAM_ERROR = 3;
  static const int VP8_STATUS_UNSUPPORTED_FEATURE = 4;
  static const int VP8_STATUS_SUSPENDED = 5;
  static const int VP8_STATUS_USER_ABORT = 6;
  static const int VP8_STATUS_NOT_ENOUGH_DATA = 7;
}

typedef _locale_t = ffi.Pointer<__crt_locale_pointers>;
typedef rsize_t = ffi.Size;
typedef Dartrsize_t = int;

/// Data type used to describe 'raw' data, e.g., chunk data
/// (ICC profile, metadata) and WebP compressed image data.
/// 'bytes' memory must be allocated using WebPMalloc() and such.
final class WebPData extends ffi.Struct {
  external ffi.Pointer<ffi.Uint8> bytes;

  @ffi.Size()
  external int size;
}

/// VP8X Feature Flags.
abstract class WebPFeatureFlags {
  static const int ANIMATION_FLAG = 2;
  static const int XMP_FLAG = 4;
  static const int EXIF_FLAG = 8;
  static const int ALPHA_FLAG = 16;
  static const int ICCP_FLAG = 32;
  static const int ALL_VALID_FLAGS = 62;
}

/// Dispose method (animation only). Indicates how the area used by the current
/// frame is to be treated before rendering the next frame on the canvas.
abstract class WebPMuxAnimDispose {
  /// Do not dispose.
  static const int WEBP_MUX_DISPOSE_NONE = 0;

  /// Dispose to background color.
  static const int WEBP_MUX_DISPOSE_BACKGROUND = 1;
}

/// Blend operation (animation only). Indicates how transparent pixels of the
/// current frame are blended with those of the previous canvas.
abstract class WebPMuxAnimBlend {
  /// Blend.
  static const int WEBP_MUX_BLEND = 0;

  /// Do not blend.
  static const int WEBP_MUX_NO_BLEND = 1;
}

final class WebPDemuxer extends ffi.Opaque {}

/// ------------------------------------------------------------------------------
/// Frame iteration.
final class WebPIterator extends ffi.Struct {
  @ffi.Int()
  external int frame_num;

  /// equivalent to WEBP_FF_FRAME_COUNT.
  @ffi.Int()
  external int num_frames;

  /// offset relative to the canvas.
  @ffi.Int()
  external int x_offset;

  @ffi.Int()
  external int y_offset;

  /// dimensions of this frame.
  @ffi.Int()
  external int width;

  @ffi.Int()
  external int height;

  /// display duration in milliseconds.
  @ffi.Int()
  external int duration;

  /// dispose method for the frame.
  @ffi.Int32()
  external int dispose_method;

  /// true if 'fragment' contains a full frame. partial images
  /// may still be decoded with the WebP incremental decoder.
  @ffi.Int()
  external int complete;

  /// The frame given by 'frame_num'. Note for historical
  /// reasons this is called a fragment.
  external WebPData fragment;

  /// True if the frame contains transparency.
  @ffi.Int()
  external int has_alpha;

  /// Blend operation for the frame.
  @ffi.Int32()
  external int blend_method;

  /// padding for later use.
  @ffi.Array.multi([2])
  external ffi.Array<ffi.Uint32> pad;

  /// for internal use only.
  external ffi.Pointer<ffi.Void> private_;
}

/// ------------------------------------------------------------------------------
/// Chunk iteration.
final class WebPChunkIterator extends ffi.Struct {
  /// The current and total number of chunks with the fourcc given to
  /// WebPDemuxGetChunk().
  @ffi.Int()
  external int chunk_num;

  @ffi.Int()
  external int num_chunks;

  /// The payload of the chunk.
  external WebPData chunk;

  /// padding for later use
  @ffi.Array.multi([6])
  external ffi.Array<ffi.Uint32> pad;

  external ffi.Pointer<ffi.Void> private_;
}

/// Global information about the animation..
final class WebPAnimInfo extends ffi.Struct {
  @ffi.Uint32()
  external int canvas_width;

  @ffi.Uint32()
  external int canvas_height;

  @ffi.Uint32()
  external int loop_count;

  @ffi.Uint32()
  external int bgcolor;

  @ffi.Uint32()
  external int frame_count;

  /// padding for later use
  @ffi.Array.multi([4])
  external ffi.Array<ffi.Uint32> pad;
}

/// Global options.
final class WebPAnimDecoderOptions extends ffi.Struct {
  /// Output colorspace. Only the following modes are supported:
  /// MODE_RGBA, MODE_BGRA, MODE_rgbA and MODE_bgrA.
  @ffi.Int32()
  external int color_mode;

  /// If true, use multi-threaded decoding.
  @ffi.Int()
  external int use_threads;

  /// Padding for later use.
  @ffi.Array.multi([7])
  external ffi.Array<ffi.Uint32> padding;
}

/// ------------------------------------------------------------------------------
/// Life of a Demux object
abstract class WebPDemuxState {
  /// An error occurred while parsing.
  static const int WEBP_DEMUX_PARSE_ERROR = -1;

  /// Not enough data to parse full header.
  static const int WEBP_DEMUX_PARSING_HEADER = 0;

  /// Header parsing complete,
  /// data may be available.
  static const int WEBP_DEMUX_PARSED_HEADER = 1;

  /// Entire file has been parsed.
  static const int WEBP_DEMUX_DONE = 2;
}

/// ------------------------------------------------------------------------------
/// Data/information extraction.
abstract class WebPFormatFeature {
  /// bit-wise combination of WebPFeatureFlags
  /// corresponding to the 'VP8X' chunk (if present).
  static const int WEBP_FF_FORMAT_FLAGS = 0;
  static const int WEBP_FF_CANVAS_WIDTH = 1;
  static const int WEBP_FF_CANVAS_HEIGHT = 2;

  /// only relevant for animated file
  static const int WEBP_FF_LOOP_COUNT = 3;

  /// idem.
  static const int WEBP_FF_BACKGROUND_COLOR = 4;

  /// Number of frames present in the demux object.
  /// In case of a partial demux, this is the number
  /// of frames seen so far, with the last frame
  /// possibly being partial.
  static const int WEBP_FF_FRAME_COUNT = 5;
}

final class WebPAnimDecoder extends ffi.Opaque {}

/// Compression parameters.
final class WebPConfig extends ffi.Struct {
  /// Lossless encoding (0=lossy(default), 1=lossless).
  @ffi.Int()
  external int lossless;

  /// between 0 and 100. For lossy, 0 gives the smallest
  /// size and 100 the largest. For lossless, this
  /// parameter is the amount of effort put into the
  /// compression: 0 is the fastest but gives larger
  /// files compared to the slowest, but best, 100.
  @ffi.Float()
  external double quality;

  /// quality/speed trade-off (0=fast, 6=slower-better)
  @ffi.Int()
  external int method;

  /// Hint for image type (lossless only for now).
  @ffi.Int32()
  external int image_hint;

  /// if non-zero, set the desired target size in bytes.
  /// Takes precedence over the 'compression' parameter.
  @ffi.Int()
  external int target_size;

  /// if non-zero, specifies the minimal distortion to
  /// try to achieve. Takes precedence over target_size.
  @ffi.Float()
  external double target_PSNR;

  /// maximum number of segments to use, in [1..4]
  @ffi.Int()
  external int segments;

  /// Spatial Noise Shaping. 0=off, 100=maximum.
  @ffi.Int()
  external int sns_strength;

  /// range: [0 = off .. 100 = strongest]
  @ffi.Int()
  external int filter_strength;

  /// range: [0 = off .. 7 = least sharp]
  @ffi.Int()
  external int filter_sharpness;

  /// filtering type: 0 = simple, 1 = strong (only used
  /// if filter_strength > 0 or autofilter > 0)
  @ffi.Int()
  external int filter_type;

  /// Auto adjust filter's strength [0 = off, 1 = on]
  @ffi.Int()
  external int autofilter;

  /// Algorithm for encoding the alpha plane (0 = none,
  /// 1 = compressed with WebP lossless). Default is 1.
  @ffi.Int()
  external int alpha_compression;

  /// Predictive filtering method for alpha plane.
  /// 0: none, 1: fast, 2: best. Default if 1.
  @ffi.Int()
  external int alpha_filtering;

  /// Between 0 (smallest size) and 100 (lossless).
  /// Default is 100.
  @ffi.Int()
  external int alpha_quality;

  /// number of entropy-analysis passes (in [1..10]).
  @ffi.Int()
  external int pass;

  /// if true, export the compressed picture back.
  /// In-loop filtering is not applied.
  @ffi.Int()
  external int show_compressed;

  /// preprocessing filter:
  /// 0=none, 1=segment-smooth, 2=pseudo-random dithering
  @ffi.Int()
  external int preprocessing;

  /// log2(number of token partitions) in [0..3]. Default
  /// is set to 0 for easier progressive decoding.
  @ffi.Int()
  external int partitions;

  /// quality degradation allowed to fit the 512k limit
  /// on prediction modes coding (0: no degradation,
  /// 100: maximum possible degradation).
  @ffi.Int()
  external int partition_limit;

  /// If true, compression parameters will be remapped
  /// to better match the expected output size from
  /// JPEG compression. Generally, the output size will
  /// be similar but the degradation will be lower.
  @ffi.Int()
  external int emulate_jpeg_size;

  /// If non-zero, try and use multi-threaded encoding.
  @ffi.Int()
  external int thread_level;

  /// If set, reduce memory usage (but increase CPU use).
  @ffi.Int()
  external int low_memory;

  /// Near lossless encoding [0 = max loss .. 100 = off
  /// (default)].
  @ffi.Int()
  external int near_lossless;

  /// if non-zero, preserve the exact RGB values under
  /// transparent area. Otherwise, discard this invisible
  /// RGB information for better compression. The default
  /// value is 0.
  @ffi.Int()
  external int exact;

  /// reserved for future lossless feature
  @ffi.Int()
  external int use_delta_palette;

  /// if needed, use sharp (and slow) RGB->YUV conversion
  @ffi.Int()
  external int use_sharp_yuv;

  /// minimum permissible quality factor
  @ffi.Int()
  external int qmin;

  /// maximum permissible quality factor
  @ffi.Int()
  external int qmax;
}

/// Image characteristics hint for the underlying encoder.
abstract class WebPImageHint {
  /// default preset.
  static const int WEBP_HINT_DEFAULT = 0;

  /// digital picture, like portrait, inner shot
  static const int WEBP_HINT_PICTURE = 1;

  /// outdoor photograph, with natural lighting
  static const int WEBP_HINT_PHOTO = 2;

  /// Discrete tone image (graph, map-tile etc).
  static const int WEBP_HINT_GRAPH = 3;
  static const int WEBP_HINT_LAST = 4;
}

/// Main exchange structure (input samples, output bytes, statistics)
///
/// Once WebPPictureInit() has been called, it's ok to make all the INPUT fields
/// (use_argb, y/u/v, argb, ...) point to user-owned data, even if
/// WebPPictureAlloc() has been called. Depending on the value use_argb,
/// it's guaranteed that either *argb or *y/*u/*v content will be kept untouched.
final class WebPPicture extends ffi.Struct {
  /// INPUT
  /// ///////////
  /// Main flag for encoder selecting between ARGB or YUV input.
  /// It is recommended to use ARGB input (*argb, argb_stride) for lossless
  /// compression, and YUV input (*y, *u, *v, etc.) for lossy compression
  /// since these are the respective native colorspace for these formats.
  @ffi.Int()
  external int use_argb;

  /// colorspace: should be YUV420 for now (=Y'CbCr).
  @ffi.Int32()
  external int colorspace;

  /// dimensions (less or equal to WEBP_MAX_DIMENSION)
  @ffi.Int()
  external int width;

  @ffi.Int()
  external int height;

  /// pointers to luma/chroma planes.
  external ffi.Pointer<ffi.Uint8> y;

  external ffi.Pointer<ffi.Uint8> u;

  external ffi.Pointer<ffi.Uint8> v;

  /// luma/chroma strides.
  @ffi.Int()
  external int y_stride;

  @ffi.Int()
  external int uv_stride;

  /// pointer to the alpha plane
  external ffi.Pointer<ffi.Uint8> a;

  /// stride of the alpha plane
  @ffi.Int()
  external int a_stride;

  /// padding for later use
  @ffi.Array.multi([2])
  external ffi.Array<ffi.Uint32> pad1;

  /// Pointer to argb (32 bit) plane.
  external ffi.Pointer<ffi.Uint32> argb;

  /// This is stride in pixels units, not bytes.
  @ffi.Int()
  external int argb_stride;

  /// padding for later use
  @ffi.Array.multi([3])
  external ffi.Array<ffi.Uint32> pad2;

  /// can be NULL
  external WebPWriterFunction writer;

  /// can be used by the writer.
  external ffi.Pointer<ffi.Void> custom_ptr;

  /// 1: intra type, 2: segment, 3: quant
  /// 4: intra-16 prediction mode,
  /// 5: chroma prediction mode,
  /// 6: bit cost, 7: distortion
  @ffi.Int()
  external int extra_info_type;

  /// if not NULL, points to an array of size
  /// ((width + 15) / 16) * ((height + 15) / 16) that
  /// will be filled with a macroblock map, depending
  /// on extra_info_type.
  external ffi.Pointer<ffi.Uint8> extra_info;

  /// STATS AND REPORTS
  /// ////////////////////////
  /// Pointer to side statistics (updated only if not NULL)
  external ffi.Pointer<WebPAuxStats> stats;

  /// Error code for the latest error encountered during encoding
  @ffi.Int32()
  external int error_code;

  /// If not NULL, report progress during encoding.
  external WebPProgressHook progress_hook;

  /// this field is free to be set to any value and
  /// used during callbacks (like progress-report e.g.).
  external ffi.Pointer<ffi.Void> user_data;

  /// padding for later use
  @ffi.Array.multi([3])
  external ffi.Array<ffi.Uint32> pad3;

  /// Unused for now
  external ffi.Pointer<ffi.Uint8> pad4;

  external ffi.Pointer<ffi.Uint8> pad5;

  /// padding for later use
  @ffi.Array.multi([8])
  external ffi.Array<ffi.Uint32> pad6;

  /// row chunk of memory for yuva planes
  external ffi.Pointer<ffi.Void> memory_;

  /// and for argb too.
  external ffi.Pointer<ffi.Void> memory_argb_;

  /// padding for later use
  @ffi.Array.multi([2])
  external ffi.Array<ffi.Pointer<ffi.Void>> pad7;
}

/// Color spaces.
abstract class WebPEncCSP {
  /// 4:2:0
  static const int WEBP_YUV420 = 0;

  /// alpha channel variant
  static const int WEBP_YUV420A = 4;

  /// bit-mask to get the UV sampling factors
  static const int WEBP_CSP_UV_MASK = 3;

  /// bit that is set if alpha is present
  static const int WEBP_CSP_ALPHA_BIT = 4;
}

/// Signature for output function. Should return true if writing was successful.
/// data/data_size is the segment of data to write, and 'picture' is for
/// reference (and so one can make use of picture->custom_ptr).
typedef WebPWriterFunction
    = ffi.Pointer<ffi.NativeFunction<WebPWriterFunctionFunction>>;
typedef WebPWriterFunctionFunction = ffi.Int Function(
    ffi.Pointer<ffi.Uint8> data,
    ffi.Size data_size,
    ffi.Pointer<WebPPicture> picture);
typedef DartWebPWriterFunctionFunction = int Function(
    ffi.Pointer<ffi.Uint8> data,
    int data_size,
    ffi.Pointer<WebPPicture> picture);

/// ------------------------------------------------------------------------------
/// Input / Output
/// Structure for storing auxiliary statistics.
final class WebPAuxStats extends ffi.Struct {
  /// final size
  @ffi.Int()
  external int coded_size;

  /// peak-signal-to-noise ratio for Y/U/V/All/Alpha
  @ffi.Array.multi([5])
  external ffi.Array<ffi.Float> PSNR;

  /// number of intra4/intra16/skipped macroblocks
  @ffi.Array.multi([3])
  external ffi.Array<ffi.Int> block_count;

  /// approximate number of bytes spent for header
  /// and mode-partition #0
  @ffi.Array.multi([2])
  external ffi.Array<ffi.Int> header_bytes;

  /// approximate number of bytes spent for
  /// DC/AC/uv coefficients for each (0..3) segments.
  @ffi.Array.multi([3, 4])
  external ffi.Array<ffi.Array<ffi.Int>> residual_bytes;

  /// number of macroblocks in each segments
  @ffi.Array.multi([4])
  external ffi.Array<ffi.Int> segment_size;

  /// quantizer values for each segments
  @ffi.Array.multi([4])
  external ffi.Array<ffi.Int> segment_quant;

  /// filtering strength for each segments [0..63]
  @ffi.Array.multi([4])
  external ffi.Array<ffi.Int> segment_level;

  /// size of the transparency data
  @ffi.Int()
  external int alpha_data_size;

  /// size of the enhancement layer data
  @ffi.Int()
  external int layer_data_size;

  /// bit0:predictor bit1:cross-color transform
  /// bit2:subtract-green bit3:color indexing
  @ffi.Uint32()
  external int lossless_features;

  /// number of precision bits of histogram
  @ffi.Int()
  external int histogram_bits;

  /// precision bits for transform
  @ffi.Int()
  external int transform_bits;

  /// number of bits for color cache lookup
  @ffi.Int()
  external int cache_bits;

  /// number of color in palette, if used
  @ffi.Int()
  external int palette_size;

  /// final lossless size
  @ffi.Int()
  external int lossless_size;

  /// lossless header (transform, huffman etc) size
  @ffi.Int()
  external int lossless_hdr_size;

  /// lossless image data size
  @ffi.Int()
  external int lossless_data_size;

  /// padding for later use
  @ffi.Array.multi([2])
  external ffi.Array<ffi.Uint32> pad;
}

/// Encoding error conditions.
abstract class WebPEncodingError {
  static const int VP8_ENC_OK = 0;

  /// memory error allocating objects
  static const int VP8_ENC_ERROR_OUT_OF_MEMORY = 1;

  /// memory error while flushing bits
  static const int VP8_ENC_ERROR_BITSTREAM_OUT_OF_MEMORY = 2;

  /// a pointer parameter is NULL
  static const int VP8_ENC_ERROR_NULL_PARAMETER = 3;

  /// configuration is invalid
  static const int VP8_ENC_ERROR_INVALID_CONFIGURATION = 4;

  /// picture has invalid width/height
  static const int VP8_ENC_ERROR_BAD_DIMENSION = 5;

  /// partition is bigger than 512k
  static const int VP8_ENC_ERROR_PARTITION0_OVERFLOW = 6;

  /// partition is bigger than 16M
  static const int VP8_ENC_ERROR_PARTITION_OVERFLOW = 7;

  /// error while flushing bytes
  static const int VP8_ENC_ERROR_BAD_WRITE = 8;

  /// file is bigger than 4G
  static const int VP8_ENC_ERROR_FILE_TOO_BIG = 9;

  /// abort request by user
  static const int VP8_ENC_ERROR_USER_ABORT = 10;

  /// list terminator. always last.
  static const int VP8_ENC_ERROR_LAST = 11;
}

/// Progress hook, called from time to time to report progress. It can return
/// false to request an abort of the encoding process, or true otherwise if
/// everything is OK.
typedef WebPProgressHook
    = ffi.Pointer<ffi.NativeFunction<WebPProgressHookFunction>>;
typedef WebPProgressHookFunction = ffi.Int Function(
    ffi.Int percent, ffi.Pointer<WebPPicture> picture);
typedef DartWebPProgressHookFunction = int Function(
    int percent, ffi.Pointer<WebPPicture> picture);

/// WebPMemoryWrite: a special WebPWriterFunction that writes to memory using
/// the following WebPMemoryWriter object (to be set as a custom_ptr).
final class WebPMemoryWriter extends ffi.Struct {
  /// final buffer (of size 'max_size', larger than 'size').
  external ffi.Pointer<ffi.Uint8> mem;

  /// final size
  @ffi.Size()
  external int size;

  /// total capacity
  @ffi.Size()
  external int max_size;

  /// padding for later use
  @ffi.Array.multi([1])
  external ffi.Array<ffi.Uint32> pad;
}

/// Enumerate some predefined settings for WebPConfig, depending on the type
/// of source picture. These presets are used when calling WebPConfigPreset().
abstract class WebPPreset {
  /// default preset.
  static const int WEBP_PRESET_DEFAULT = 0;

  /// digital picture, like portrait, inner shot
  static const int WEBP_PRESET_PICTURE = 1;

  /// outdoor photograph, with natural lighting
  static const int WEBP_PRESET_PHOTO = 2;

  /// hand or line drawing, with high-contrast details
  static const int WEBP_PRESET_DRAWING = 3;

  /// small-sized colorful images
  static const int WEBP_PRESET_ICON = 4;

  /// text-like
  static const int WEBP_PRESET_TEXT = 5;
}

typedef NativeWebPMemoryWrite = ffi.Int Function(ffi.Pointer<ffi.Uint8> data,
    ffi.Size data_size, ffi.Pointer<WebPPicture> picture);
typedef DartWebPMemoryWrite = int Function(ffi.Pointer<ffi.Uint8> data,
    int data_size, ffi.Pointer<WebPPicture> picture);

final class WebPMux extends ffi.Opaque {}

/// Encapsulates data about a single frame.
final class WebPMuxFrameInfo extends ffi.Struct {
  /// image data: can be a raw VP8/VP8L bitstream
  /// or a single-image WebP file.
  external WebPData bitstream;

  /// x-offset of the frame.
  @ffi.Int()
  external int x_offset;

  /// y-offset of the frame.
  @ffi.Int()
  external int y_offset;

  /// duration of the frame (in milliseconds).
  @ffi.Int()
  external int duration;

  /// frame type: should be one of WEBP_CHUNK_ANMF
  /// or WEBP_CHUNK_IMAGE
  @ffi.Int32()
  external int id;

  /// Disposal method for the frame.
  @ffi.Int32()
  external int dispose_method;

  /// Blend operation for the frame.
  @ffi.Int32()
  external int blend_method;

  /// padding for later use
  @ffi.Array.multi([1])
  external ffi.Array<ffi.Uint32> pad;
}

/// IDs for different types of chunks.
abstract class WebPChunkId {
  /// VP8X
  static const int WEBP_CHUNK_VP8X = 0;

  /// ICCP
  static const int WEBP_CHUNK_ICCP = 1;

  /// ANIM
  static const int WEBP_CHUNK_ANIM = 2;

  /// ANMF
  static const int WEBP_CHUNK_ANMF = 3;

  /// (deprecated from FRGM)
  static const int WEBP_CHUNK_DEPRECATED = 4;

  /// ALPH
  static const int WEBP_CHUNK_ALPHA = 5;

  /// VP8/VP8L
  static const int WEBP_CHUNK_IMAGE = 6;

  /// EXIF
  static const int WEBP_CHUNK_EXIF = 7;

  /// XMP
  static const int WEBP_CHUNK_XMP = 8;

  /// Other chunks.
  static const int WEBP_CHUNK_UNKNOWN = 9;
  static const int WEBP_CHUNK_NIL = 10;
}

/// Animation parameters.
final class WebPMuxAnimParams extends ffi.Struct {
  /// Background color of the canvas stored (in MSB order) as:
  /// Bits 00 to 07: Alpha.
  /// Bits 08 to 15: Red.
  /// Bits 16 to 23: Green.
  /// Bits 24 to 31: Blue.
  @ffi.Uint32()
  external int bgcolor;

  /// Number of times to repeat the animation [0 = infinite].
  @ffi.Int()
  external int loop_count;
}

/// Global options.
final class WebPAnimEncoderOptions extends ffi.Struct {
  /// Animation parameters.
  external WebPMuxAnimParams anim_params;

  /// If true, minimize the output size (slow). Implicitly
  /// disables key-frame insertion.
  @ffi.Int()
  external int minimize_size;

  @ffi.Int()
  external int kmin;

  /// Minimum and maximum distance between consecutive key
  /// frames in the output. The library may insert some key
  /// frames as needed to satisfy this criteria.
  /// Note that these conditions should hold: kmax > kmin
  /// and kmin >= kmax / 2 + 1. Also, if kmax <= 0, then
  /// key-frame insertion is disabled; and if kmax == 1,
  /// then all frames will be key-frames (kmin value does
  /// not matter for these special cases).
  @ffi.Int()
  external int kmax;

  /// If true, use mixed compression mode; may choose
  /// either lossy and lossless for each frame.
  @ffi.Int()
  external int allow_mixed;

  /// If true, print info and warning messages to stderr.
  @ffi.Int()
  external int verbose;

  /// Padding for later use.
  @ffi.Array.multi([4])
  external ffi.Array<ffi.Uint32> padding;
}

/// Error codes
abstract class WebPMuxError {
  static const int WEBP_MUX_OK = 1;
  static const int WEBP_MUX_NOT_FOUND = 0;
  static const int WEBP_MUX_INVALID_ARGUMENT = -1;
  static const int WEBP_MUX_BAD_DATA = -2;
  static const int WEBP_MUX_MEMORY_ERROR = -3;
  static const int WEBP_MUX_NOT_ENOUGH_DATA = -4;
}

final class WebPAnimEncoder extends ffi.Opaque {}

const int _VCRT_COMPILER_PREPROCESSOR = 1;

const int _SAL_VERSION = 20;

const int __SAL_H_VERSION = 180000000;

const int _USE_DECLSPECS_FOR_SAL = 0;

const int _USE_ATTRIBUTES_FOR_SAL = 0;

const int _CRT_PACKING = 8;

const int _VCRUNTIME_DISABLED_WARNINGS = 4514;

const int _HAS_EXCEPTIONS = 1;

const int _WCHAR_T_DEFINED = 1;

const int NULL = 0;

const int _HAS_CXX17 = 0;

const int _HAS_CXX20 = 0;

const int _HAS_CXX23 = 0;

const int _HAS_NODISCARD = 1;

const int _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE = 1;

const int _CRT_BUILD_DESKTOP_APP = 1;

const int _UCRT_DISABLED_WARNINGS = 4324;

const int _ARGMAX = 100;

const int _TRUNCATE = -1;

const int _CRT_INT_MAX = 2147483647;

const int _CRT_SIZE_MAX = -1;

const String __FILEW__ = 'C';

const int _CRT_FUNCTIONS_REQUIRED = 1;

const int _CRT_HAS_CXX17 = 0;

const int _CRT_HAS_C11 = 0;

const int _CRT_INTERNAL_NONSTDC_NAMES = 1;

const int __STDC_SECURE_LIB__ = 200411;

const int __GOT_SECURE_LIB__ = 200411;

const int __STDC_WANT_SECURE_LIB__ = 1;

const int _SECURECRT_FILL_BUFFER_PATTERN = 254;

const int _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES = 0;

const int _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT = 0;

const int _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES = 1;

const int _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY = 0;

const int _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY = 0;

const int WEBP_DECODER_ABI_VERSION = 521;

const int EPERM = 1;

const int ENOENT = 2;

const int ESRCH = 3;

const int EINTR = 4;

const int EIO = 5;

const int ENXIO = 6;

const int E2BIG = 7;

const int ENOEXEC = 8;

const int EBADF = 9;

const int ECHILD = 10;

const int EAGAIN = 11;

const int ENOMEM = 12;

const int EACCES = 13;

const int EFAULT = 14;

const int EBUSY = 16;

const int EEXIST = 17;

const int EXDEV = 18;

const int ENODEV = 19;

const int ENOTDIR = 20;

const int EISDIR = 21;

const int ENFILE = 23;

const int EMFILE = 24;

const int ENOTTY = 25;

const int EFBIG = 27;

const int ENOSPC = 28;

const int ESPIPE = 29;

const int EROFS = 30;

const int EMLINK = 31;

const int EPIPE = 32;

const int EDOM = 33;

const int EDEADLK = 36;

const int ENAMETOOLONG = 38;

const int ENOLCK = 39;

const int ENOSYS = 40;

const int ENOTEMPTY = 41;

const int EINVAL = 22;

const int ERANGE = 34;

const int EILSEQ = 42;

const int STRUNCATE = 80;

const int EDEADLOCK = 36;

const int EADDRINUSE = 100;

const int EADDRNOTAVAIL = 101;

const int EAFNOSUPPORT = 102;

const int EALREADY = 103;

const int EBADMSG = 104;

const int ECANCELED = 105;

const int ECONNABORTED = 106;

const int ECONNREFUSED = 107;

const int ECONNRESET = 108;

const int EDESTADDRREQ = 109;

const int EHOSTUNREACH = 110;

const int EIDRM = 111;

const int EINPROGRESS = 112;

const int EISCONN = 113;

const int ELOOP = 114;

const int EMSGSIZE = 115;

const int ENETDOWN = 116;

const int ENETRESET = 117;

const int ENETUNREACH = 118;

const int ENOBUFS = 119;

const int ENODATA = 120;

const int ENOLINK = 121;

const int ENOMSG = 122;

const int ENOPROTOOPT = 123;

const int ENOSR = 124;

const int ENOSTR = 125;

const int ENOTCONN = 126;

const int ENOTRECOVERABLE = 127;

const int ENOTSOCK = 128;

const int ENOTSUP = 129;

const int EOPNOTSUPP = 130;

const int EOTHER = 131;

const int EOVERFLOW = 132;

const int EOWNERDEAD = 133;

const int EPROTO = 134;

const int EPROTONOSUPPORT = 135;

const int EPROTOTYPE = 136;

const int ETIME = 137;

const int ETIMEDOUT = 138;

const int ETXTBSY = 139;

const int EWOULDBLOCK = 140;

const int _NLSCMPERROR = 2147483647;

const int WEBP_DEMUX_ABI_VERSION = 263;

const int WEBP_ENCODER_ABI_VERSION = 527;

const int WEBP_MAX_DIMENSION = 16383;

const int WEBP_MUX_ABI_VERSION = 264;
